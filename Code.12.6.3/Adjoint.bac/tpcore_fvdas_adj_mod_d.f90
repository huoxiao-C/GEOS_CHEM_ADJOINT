!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (master) -  9 Oct 2020 17:46
!
! $Id: tpcore_fvdas_mod.f90,v 1.5 2011/02/23 00:08:47 daven Exp $
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !MODULE: Tpcore_FvDas_Mod
!
! !DESCRIPTION: \subsection*{Overview}
!  Module Tpcore\_Fvdas\_Mod contains routines for the TPCORE
!  transport scheme, as implemented in the GMI model (cf. John Tannahill),
!  based on Lin \ Rood 1995.  The Harvard Atmospheric Chemistry Modeling Group
!  has added modifications to implement the Philip-Cameron Smith pressure
!  fixer for mass conservation.  Mass flux diagnostics have also been added.
!
!\subsection*{References}
!  \begin{enumerate}
!  \item Lin, S.-J., and R. B. Rood, 1996: \emph{Multidimensional flux
!         form semi-Lagrangian transport schemes},
!         \underline{ Mon. Wea. Rev.}, \textbf{124}, 2046-2070.
!  \item Lin, S.-J., W. C. Chao, Y. C. Sud, and G. K. Walker, 1994:
!         \emph{A class of the van Leer-type transport schemes and its
!         applications to the moisture transport in a General Circulation
!         Model}, \underline{Mon. Wea. Rev.}, \textbf{122}, 1575-1593.
!  \end{enumerate}
!
!\subsection*{Selecting E/W, N/S and vertical advection options}
!
!  The flags IORD, JORD, KORD select which transport schemes are used in the
!  E/W, N/S, and vertical directions, respectively.  Here is a list of the
!  possible values that IORD, JORD, KORD may be set to (original notes from
!  S-J Lin):
!
!  \begin{enumerate}
!  \item 1st order upstream scheme (too diffusive, not a real option;
!         it can be used for debugging purposes; this is THE only known
!         "linear" monotonic advection scheme.).
!  \item 2nd order van Leer (full monotonicity constraint;
!         see Lin et al 1994, MWR)
!  \item monotonic PPM* (Collela \& Woodward 1984)
!  \item semi-monotonic PPM (same as 3, but overshoots are allowed)
!  \item positive-definite PPM (constraint on the subgrid distribution is
!         only strong enough to prevent generation of negative values;
!         both overshoots \& undershoots are possible).
!  \item un-constrained PPM (nearly diffusion free; faster but
!         positivity of the subgrid distribution is not quaranteed. Use
!         this option only when the fields and winds are very smooth.
!  \item Huynh/Van Leer/Lin full monotonicity constraint.  Only KORD can be
!         set to 7 to enable the use of Huynh's 2nd monotonicity constraint
!         for piece-wise parabolic distribution.
!  \end {enumerate}
!
!  Recommended values:
!
!  \begin{itemize}
!  \item IORD=JORD=3 for high horizontal resolution.
!  \item KORD=3 or 7
!  \end{itemize}
!
!  The implicit numerical diffusion decreases as \_ORD increases.
!  DO NOT use option 4 or 5 for non-positive definite scalars
!  (such as Ertel Potential Vorticity).
!\\
!\\
! In GEOS-Chem we have been using IORD=3, JORD=3, KORD=7.  We have tested
! the OpenMP parallelization with these options.  GEOS-Chem users who wish to
! use different (I,J,K)ORD options should consider doing single-procsessor
! vs. multi-processor tests to test the implementation of the parallelization.
!
!\subsection*{GEOS-4 and GEOS-5 Hybrid Grid Definition}
!
!  For GEOS-4 and GEOS-5 met fields, the pressure at the bottom edge of
!  grid box (I,J,L) is defined as follows:
!
!     $$P_{edge}(I,J,L) = A_{k}(L) + [ B_{k}(L) * P_{surface}(I,J) ]$$
!
!  where
!
!  \begin{itemize}
!  \item $P_{surface}$(I,J) is the "true" surface pressure at lon,lat (I,J)
!  \item $A_{k}$(L) has the same units as surface pressure [hPa]
!  \item $B_{k}$(L) is a unitless constant given at level edges
!  \end{itemize}
!
!  $A_{k}(L)$ and $B_{k}(L)$ are supplied to us by GMAO.
!\\
!\\
! !REMARKS:
!  Ak(L) and Bk(L) are defined at layer edges.
!
!
!                  /////////////////////////////////
!              / \ ------ Model top P=ak(1) --------- ak(1), bk(1)
!               |
!    delp(1)    |  ........... q(i,j,1) ............
!               |
!              \ / ---------------------------------  ak(2), bk(2)
!
!
!
!              / \ ---------------------------------  ak(k), bk(k)
!               |
!    delp(k)    |  ........... q(i,j,k) ............
!               |
!              \ / ---------------------------------  ak(k+1), bk(k+1)
!
!
!
!              / \ ---------------------------------  ak(km), bk(km)
!               |
!    delp(km)   |  ........... q(i,j,km) .........
!               |
!              \ / -----Earth's surface P=Psfc ------ ak(km+1), bk(km+1)
!                 //////////////////////////////////
!
! Note: surface pressure can be of any unit (e.g., pascal or mb) as
! long as it is consistent with the definition of (ak, bk) defined above.
!
! Winds (u,v), ps, and q are assumed to be defined at the same points.
!
! The latitudes are given to the initialization routine: init_tpcore.
!
! !INTERFACE:
!
MODULE TPCORE_FVDAS_ADJ_MOD_DIFF
  IMPLICIT NONE
  PRIVATE 
!
! !PUBLIC MEMBER FUNCTIONS:
!
  PUBLIC :: init_tpcore_d
  PUBLIC :: exit_tpcore
  PUBLIC :: tpcore_fvdas
  PUBLIC :: tpcore_fvdas_d
!
! !PRIVATE MEMBER FUNCTIONS:
!
  PRIVATE :: average_const_poles
  PRIVATE :: average_const_poles_d
  PRIVATE :: set_cross_terms
  PRIVATE :: calc_vert_mass_flux
  PRIVATE :: set_jn_js
  PRIVATE :: calc_advec_cross_terms
  PRIVATE :: calc_advec_cross_terms_d
  PRIVATE :: qckxyz
  PRIVATE :: qckxyz_d
  PRIVATE :: set_lmts
  PRIVATE :: set_press_terms
  PRIVATE :: calc_courant
  PRIVATE :: calc_divergence
  PRIVATE :: do_divergence_pole_sum
  PRIVATE :: do_cross_terms_pole_i2d2
  PRIVATE :: xadv_dao2
  PRIVATE :: xadv_dao2_d
  PRIVATE :: yadv_dao2
  PRIVATE :: yadv_dao2_d
  PRIVATE :: do_yadv_pole_i2d2
  PRIVATE :: do_yadv_pole_i2d2_d
  PRIVATE :: do_yadv_pole_sum
  PRIVATE :: do_yadv_pole_sum_d
  PRIVATE :: xtp
  PRIVATE :: xtp_d
  PRIVATE :: xmist
  PRIVATE :: xmist_d
  PRIVATE :: fxppm
  PRIVATE :: fxppm_d
  PRIVATE :: lmtppm
  PRIVATE :: lmtppm_d
  PRIVATE :: ytp
  PRIVATE :: ytp_d
  PRIVATE :: ymist
  PRIVATE :: ymist_d
  PRIVATE :: do_ymist_pole1_i2d2
  PRIVATE :: do_ymist_pole1_i2d2_d
  PRIVATE :: do_ymist_pole2_i2d2
  PRIVATE :: do_ymist_pole2_i2d2_d
  PRIVATE :: fyppm
  PRIVATE :: fyppm_d
  PRIVATE :: do_fyppm_pole_i2d2
  PRIVATE :: do_fyppm_pole_i2d2_d
  PRIVATE :: do_ytp_pole_sum
  PRIVATE :: do_ytp_pole_sum_d
  PRIVATE :: fzppm
  PRIVATE :: fzppm_d
  PRIVATE :: average_press_poles
!
! !PRIVATE DATA MEMBERS:
!
  REAL*8, ALLOCATABLE, SAVE :: dtdx5(:)
  REAL*8, ALLOCATABLE, SAVE :: dtdy5(:)
  REAL*8, ALLOCATABLE, SAVE :: cosp(:)
  REAL*8, ALLOCATABLE, SAVE :: cose(:)
  REAL*8, ALLOCATABLE, SAVE :: gw(:)
  REAL*8, ALLOCATABLE, SAVE :: dlat(:)

CONTAINS
!
! !AUTHOR:
! Original code from Shian-Jiann Lin, GMAO
! Modified for GMI model by John Tannahill, LLNL (jrt@llnl.gov)
! Implemented into GEOS-Chem by Claire Carouge (ccarouge@seas.harvard.edu)
! ProTeX documentation added by Bob Yantosca (yantosca@seas.harvard.edu)
! OpenMP parallelization added by Bob Yantosca (yantosca@seas.harvard.edu)
!
! !REVISION HISTORY:
! 05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                             Yeh with the TPCORE routines from the GMI model.
!                             This eliminates the polar overshoot in the
!                             stratosphere.
! 05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                             Declare all REAL variables as REAL*8.  Added
!                             OpenMP parallel loops in various routines (and
!                             made some modifications to facilitate OpenMP).
! 01 Apr 2009 - C. Carouge  - Modified OpenMp parallelization and move the
!                             loops over vertical levels outside the
!                             horizontal transport routines for reducing
!                             processing time.
!EOP
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Init_Tpcore
!
! !DESCRIPTION: Subroutine Init\_Tpcore allocates and initializes all module
!  variables,
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE INIT_TPCORE_D(im, jm, km, jfirst, jlast, ng, mg, dt, ae, clat&
& )
!
! !USES:
!
! Physical constants etc.
    USE PHYSCONSTANTS
    IMPLICIT NONE
! Echo info to stdout
! adjoint delete output
!    WRITE( 6, '(a)' ) REPEAT( '=', 79 )
!    WRITE( 6, '(a)' ) &
! 'TPCORE_FVDAS (based on GMI) Tracer Transport Module successfully initialized'
!    WRITE( 6, '(a)' ) REPEAT( '=', 79 )
!
! !INPUT PARAMETERS:
!
! Global E-W dimension
    INTEGER, INTENT(IN) :: im
! Global N-S dimension
    INTEGER, INTENT(IN) :: jm
! Vertical dimension
    INTEGER, INTENT(IN) :: km
! large ghost width
    INTEGER, INTENT(IN) :: ng
! small ghost width
    INTEGER, INTENT(IN) :: mg
! Time step in seconds
    REAL*8, INTENT(IN) :: dt
! Earth's radius (m)
    REAL*8, INTENT(IN) :: ae
! latitude in radian
    REAL*8, INTENT(IN) :: clat(jm)
!
! !OUTPUT PARAMETERS:
!
! Local first index for N-S direction
    INTEGER, INTENT(OUT) :: jfirst
! Local last  index for N-S direction
    INTEGER, INTENT(OUT) :: jlast
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! cell edge latitude in radian
    REAL*8 :: elat(jm+1)
    REAL*8 :: sine(jm+1)
!
    REAL*8 :: sine_25(jm+1)
    REAL*8 :: dlon
!----------------------------------------
! Prior to 12/12/08:
! Use PI from CMN_GCTM (bmy, 12/12/08)
!REAL*8  :: pi
!----------------------------------------
    INTEGER :: i, j
    INTRINSIC DBLE
    INTRINSIC SIN
    INTRINSIC COS
! NOTE: since we are not using MPI parallelization, we can set JFIRST
! and JLAST to the global grid limits in latitude. (bmy, 12/3/08)
    jfirst = 1
    jlast = jm
    IF (jlast - jfirst .LT. 2) WRITE(*, *) &
&                              'Minimum size of subdomain is 3'
!----------------
! Allocate arrays
!----------------
    ALLOCATE(cosp(jm))
    ALLOCATE(cose(jm))
    ALLOCATE(gw(jm))
    ALLOCATE(dtdx5(jm))
    ALLOCATE(dtdy5(jm))
    ALLOCATE(dlat(jm))
! For PJC pressure-fixer
!----------------------------------------
! Prior to 12/12/08:
! Use PI from CMN_GCTM (bmy, 12/12/08)
!PI   = 4.0d0 * ATAN(1.0d0)
!----------------------------------------
!----------------------------------------
! Prior to 12/12/08:
! Use double precision (bmy, 12/12/08)
!dlon = 2.d0 * PI / float(im)
!----------------------------------------
    dlon = 2.d0*pi/DBLE(im)
! S. Pole
    elat(1) = -(0.5d0*pi)
    sine(1) = -1.0d0
    sine_25(1) = -1.0d0
    cose(1) = 0.0d0
    DO j=2,jm
      elat(j) = 0.5d0*(clat(j-1)+clat(j))
      sine(j) = SIN(elat(j))
      sine_25(j) = SIN(clat(j))
      cose(j) = COS(elat(j))
    END DO
! N. Pole
    elat(jm+1) = 0.5d0*pi
    sine(jm+1) = 1.0d0
    sine_25(jm+1) = 1.0d0
! Polar cap (S. Pole)
    dlat(1) = 2.d0*(elat(2)-elat(1))
    DO j=2,jm-1
      dlat(j) = elat(j+1) - elat(j)
    END DO
! Polar cap (N. Pole)
    dlat(jm) = 2.0d0*(elat(jm+1)-elat(jm))
    DO j=1,jm
      gw(j) = sine(j+1) - sine(j)
      cosp(j) = gw(j)/dlat(j)
      dtdx5(j) = 0.5d0*dt/(dlon*ae*cosp(j))
      dtdy5(j) = 0.5d0*dt/(ae*dlat(j))
    END DO
  END SUBROUTINE INIT_TPCORE_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Exit_Tpcore
!
! !DESCRIPTION: Subroutine Exit\_Tpcore deallocates all module variables.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE EXIT_TPCORE()
    IMPLICIT NONE
    INTRINSIC ALLOCATED
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!EOP
!------------------------------------------------------------------------------
!BOC
! Deallocate arrays only if they are allocated
    IF (ALLOCATED(cosp)) THEN
      DEALLOCATE(cosp)
    END IF
    IF (ALLOCATED(cose)) THEN
      DEALLOCATE(cose)
    END IF
    IF (ALLOCATED(gw)) THEN
      DEALLOCATE(gw)
    END IF
    IF (ALLOCATED(dtdx5)) THEN
      DEALLOCATE(dtdx5)
    END IF
    IF (ALLOCATED(dtdy5)) THEN
      DEALLOCATE(dtdy5)
    END IF
    IF (ALLOCATED(dlat)) THEN
      DEALLOCATE(dlat)
    END IF
  END SUBROUTINE EXIT_TPCORE

!  Differentiation of tpcore_fvdas in forward (tangent) mode:
!   variations   of useful results: q
!   with respect to varying inputs: q
!   RW status of diff variables: q:in-out
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Tpcore_FvDas
!
! !DESCRIPTION: Subroutine Tpcore\_FvDas takes horizontal winds on sigma
!  (or hybrid sigma-p) surfaces and calculates mass fluxes, and then updates
!   the 3D mixing ratio fields one time step (tdt).  The basic scheme is a
!   Multi-Dimensional Flux Form Semi-Lagrangian (FFSL) based on the van Leer
!   or PPM (see Lin and Rood, 1995).
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE TPCORE_FVDAS_D(dt, ae, im, jm, km, jfirst, jlast, ng, mg, &
&   nq, ak, bk, u, v, ps1, ps2, ps, q, qd, iord, jord, kord, n_adj, &
&   xmass, ymass, massflew, massflns, massflup, area_m2, tcvv, nd24, &
&   nd25, nd26, fill)
!
! !USES:
!
! Include file w/ physical constants
    USE PHYSCONSTANTS
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Transport time step [s]
    REAL*8, INTENT(IN) :: dt
! Earth's radius [m]
    REAL*8, INTENT(IN) :: ae
! Global E-W, N-S, and vertical dimensions
    INTEGER, INTENT(IN) :: im
    INTEGER, INTENT(IN) :: jm
    INTEGER, INTENT(IN) :: km
! Latitude indices for local first box and local last box
! (NOTE: for global grids these are 1 and JM, respectively)
    INTEGER, INTENT(IN) :: jfirst
    INTEGER, INTENT(IN) :: jlast
! Primary ghost region
! (NOTE: only required for MPI parallelization; use 0 otherwise)
    INTEGER, INTENT(IN) :: ng
! Secondary ghost region
! (NOTE: only required for MPI parallelization; use 0 otherwise)
    INTEGER, INTENT(IN) :: mg
! Ghosted latitudes (3 required by PPM)
! (NOTE: only required for MPI parallelization; use 0 otherwise)
    INTEGER, INTENT(IN) :: nq
! Flags to denote E-W, N-S, and vertical transport schemes
    INTEGER, INTENT(IN) :: iord
    INTEGER, INTENT(IN) :: jord
    INTEGER, INTENT(IN) :: kord
! Number of adjustments to air_mass_flux (0 = no adjustment)
    INTEGER, INTENT(IN) :: n_adj
! Ak and Bk coordinates to specify the hybrid grid
! (see the REMARKS section below)
    REAL*8, INTENT(IN) :: ak(km+1)
    REAL*8, INTENT(IN) :: bk(km+1)
! u-wind (m/s) at mid-time-level (t=t+dt/2)
    REAL*8, INTENT(IN) :: u(:, :, :)
! E/W and N/S mass fluxes [kg/s]
! (These are computed by the pressure fixer, and passed into TPCORE)
    REAL*8, INTENT(IN) :: xmass(:, :, :)
    REAL*8, INTENT(IN) :: ymass(:, :, :)
! Grid box surface area for mass flux diag [m2]
    REAL*8, INTENT(IN) :: area_m2(jm)
! Tracer masses for flux diag
    REAL*8, INTENT(IN) :: tcvv(nq)
! Diagnostic flags
! Turns on E/W     flux diagnostic
    INTEGER, INTENT(IN) :: nd24
! Turns on N/S     flux diagnostic
    INTEGER, INTENT(IN) :: nd25
! Turns on up/down flux diagnostic
    INTEGER, INTENT(IN) :: nd26
! Negative Concentration Filling Parameter
! Turns on up/down flux diagnostic
    LOGICAL, INTENT(IN) :: fill
!
! !INPUT/OUTPUT PARAMETERS:
!
! V-wind (m/s) at mid-time-level (t=t+dt/2)
    REAL*8, INTENT(INOUT) :: v(:, :, :)
! surface pressure at current time
    REAL*8, INTENT(INOUT) :: ps1(im, jfirst:jlast)
! surface pressure at future time=t+dt
    REAL*8, INTENT(INOUT) :: ps2(im, jfirst:jlast)
! Tracer "mixing ratios" [v/v]
    REAL*8, INTENT(INOUT), TARGET :: q(:, :, :, :)
    REAL*8, INTENT(INOUT), TARGET :: qd(:, :, :, :)
! Add pointer to avoid array temporary in call to FZPPM (bmy, 6/5/13)
    REAL*8, POINTER :: ptr_q(:, :, :)
    REAL*8, POINTER :: ptr_qd(:, :, :)
! E/W, N/S, and up/down diagnostic mass fluxes
!--- Previous to (ccc, 12/3/09)
!    REAL*8,  INTENT(INOUT) :: MASSFLEW(IM,JM,KM,NQ)  ! for ND24 diagnostic
!    REAL*8,  INTENT(INOUT) :: MASSFLNS(IM,JM,KM,NQ)  ! for ND25 diagnostic
!    REAL*8,  INTENT(INOUT) :: MASSFLUP(IM,JM,KM,NQ)  ! for ND26 diagnostic
! for ND24 diagnostic
    REAL*8, INTENT(INOUT) :: massflew(:, :, :, :)
! for ND25 diagnostic
    REAL*8, INTENT(INOUT) :: massflns(:, :, :, :)
! for ND26 diagnostic
    REAL*8, INTENT(INOUT) :: massflup(:, :, :, :)
! !OUTPUT PARAMETERS:
!
! "Predicted" surface pressure [hPa]
    REAL*8, INTENT(OUT) :: ps(im, jfirst:jlast)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO)
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Modified OpenMp parallelization and move the
!                               loops over vertical levels outside the
!                               horizontal transport routines for reducing
!                               processing time.
!
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !DEFINED PARAMETERS:
!
!    LOGICAL, PARAMETER :: FILL = .true.                 ! Fill negatives ?
! 2=floating pressure
    INTEGER, PARAMETER :: advec_consrv_opt=2
    LOGICAL, PARAMETER :: cross=.true.
!
! !LOCAL VARIABLES:
!
    INTEGER :: rj2m1
    INTEGER :: j1p, j2p
    INTEGER :: jn(km)
    INTEGER :: js(km)
    INTEGER :: il, ij, ik, iq, k, j, i
    INTEGER :: num, k2m1
    REAL*8 :: dap(km)
    REAL*8 :: dbk(km)
! E-W CFL # on C-grid
    REAL*8 :: cx(im, jfirst-ng:jlast+ng, km)
! N-S CFL # on C-grid
    REAL*8 :: cy(im, jfirst:jlast+mg, km)
    REAL*8 :: delp1(im, jm, km)
    REAL*8 :: delp2(im, jm, km)
    REAL*8 :: delpm(im, jm, km)
    REAL*8 :: pu(im, jm, km)
    REAL*8 :: dpi(im, jm, km)
! geometrical factor for meridional
    REAL*8 :: geofac(jm)
! advection; geofac uses correct
! spherical geometry, and replaces
! RGW_25. (ccc, 4/1/09)
! geometrical gactor for poles.
    REAL*8 :: geofac_pc
    REAL*8 :: dp
    REAL*8 :: dps_ctm(im, jm)
    REAL*8 :: ua(im, jm, km)
    REAL*8 :: va(im, jm, km)
    REAL*8 :: wz(im, jm, km)
    REAL*8 :: dq1(im, jfirst-ng:jlast+ng, km)
    REAL*8 :: dq1d(im, jfirst-ng:jlast+ng, km)
! qqu, qqv, adx and ady are now 2d arrays for parallelization purposes.
!(ccc, 4/1/08)
    REAL*8 :: qqu(im, jm)
    REAL*8 :: qqud(im, jm)
    REAL*8 :: qqv(im, jm)
    REAL*8 :: qqvd(im, jm)
    REAL*8 :: adx(im, jm)
    REAL*8 :: adxd(im, jm)
    REAL*8 :: ady(im, jm)
    REAL*8 :: adyd(im, jm)
! fx, fy, fz and qtemp are now 4D arrays for parallelization purposes.
! (ccc, 4/1/09)
    REAL*8 :: fx(im, jm, km, nq)
    REAL*8 :: fxd(im, jm, km, nq)
! one more for edges
    REAL*8 :: fy(im, jm+1, km, nq)
    REAL*8 :: fz(im, jm, km, nq)
    REAL*8 :: qtemp(im, jm, km, nq)
! up/down flux temp array
    REAL*8 :: dtc(im, jm, km)
! up/down flux variable
    REAL*8 :: trace_diff
    LOGICAL, SAVE :: first=.true.
!     ----------------------------------------------------
!     ilmt : controls various options in E-W     advection
!     jlmt : controls various options in N-S     advection
!     klmt : controls various options in vertcal advection
!     ----------------------------------------------------
    INTEGER, SAVE :: ilmt, jlmt, klmt
    INTEGER :: js2g0, jn2g0
    INTRINSIC SUM
    INTRINSIC MAX
    INTRINSIC MIN
!     ----------------
!     Begin execution.
!     ----------------
! adj_group: BUG FIX During the adjoint call to GEOS-5 transport, the array "va" sometimes
! ends up with random values, say in locations like va(71,2), which are never
! inititialized or explicitly defined. Shouldn't they be defined somewhere?
! That could be a bug in fwd model... but initializing va to 0d0 at the
! start of TPCORE fixes the problem.  Note that the symptom is:
!   forrtl: severe (408): fort: (3): Subscript #2 of the array QQUWK has
!   value -2 which is less than the lower bound of -1
! So initialize va to 0d0 for now (dkh, 09/20/09).
    va = 0d0
! Add definition of j1p and j2p for enlarge polar cap. (ccc, 11/20/08)
    j1p = 3
    j2p = jm - j1p + 1
! Average surf. pressures in the polar cap. (ccc, 11/20/08)
    CALL AVERAGE_PRESS_POLES(area_m2, ps1, 1, im, 1, jm, 1, im, 1, jm)
    CALL AVERAGE_PRESS_POLES(area_m2, ps2, 1, im, 1, jm, 1, im, 1, jm)
! Calculation of some geographic factors. (ccc, 11/20/08)
    rj2m1 = jm - 1
    dp = pi/rj2m1
    DO ij=1,jm
      geofac(ij) = dp/(2.0d0*area_m2(ij)/(SUM(area_m2)*im)*im)
    END DO
    geofac_pc = dp/(2.0d0*(SUM(area_m2(1:2))/(SUM(area_m2)*im))*im)
    IF (first) THEN
      first = .false.
! =============
! =============
      CALL SET_LMTS(ilmt, jlmt, klmt, im, jm, iord, jord, kord)
    END IF
! Pressure calculations. (ccc, 11/20/08)
    DO ik=1,km
      dap(ik) = ak(ik+1) - ak(ik)
      dbk(ik) = bk(ik+1) - bk(ik)
    END DO
!$OMP PARALLEL DO        &
!$OMP DEFAULT( SHARED   )&
!$OMP PRIVATE( IK, IQ )
    DO ik=1,km
! ====================
! ====================
      CALL SET_PRESS_TERMS(dap(ik), dbk(ik), ps1, ps2, delp1(:, :, ik), &
&                    delpm(:, :, ik), pu(:, :, ik), 1, jm, 1, im, 1, jm&
&                    , j1p, j2p, 1, im, 1, jm)
!
!...intent(in)  dap - difference in ai across layer (mb)
!...intent(in)  dbk - difference in bi across layer (mb)
!...intent(in)  pres1 - surface pressure at t1 (mb)
!...intent(in)  pres2 - surface pressure at t1+tdt (mb)
!...intent(out) delp1 - pressure thickness at t1 (mb)
!...intent(out) delpm - pressure thickness at t1+tdt/2 (mb)
!...intent(out) pu - pressure at edges of box for "u" (mb)
!
      IF (j1p .NE. 1 + 1) THEN
        DO iq=1,nq
!  ========================
!  ========================
          CALL AVERAGE_CONST_POLES_D(dap(ik), dbk(ik), area_m2, ps1, q(:&
&                              , :, ik, iq), qd(:, :, ik, iq), 1, jm, im&
&                              , 1, im, 1, jm, 1, im, 1, jm)
        END DO
      END IF
! =================
! =================
      CALL CALC_COURANT(cose, delpm(:, :, ik), pu(:, :, ik), xmass(:, :&
&                 , ik), ymass(:, :, ik), cx(:, :, ik), cy(:, :, ik), &
&                 j1p, j2p, 1, jm, 1, im, 1, jm, 1, im, 1, jm)
! ====================
! ====================
      CALL CALC_DIVERGENCE(.true., geofac_pc, geofac, dpi(:, :, ik), &
&                    xmass(:, :, ik), ymass(:, :, ik), j1p, j2p, 1, im, &
&                    1, jm, 1, im, 1, jm, 1, im, 1, jm)
! ====================
! ====================
      CALL SET_CROSS_TERMS(cx(:, :, ik), cy(:, :, ik), ua(:, :, ik), va(&
&                    :, :, ik), j1p, j2p, 1, im, 1, jm, 1, im, 1, jm, 1&
&                    , im, 1, jm, cross)
    END DO
!$OMP END PARALLEL DO
    dps_ctm(:, :) = SUM(dpi(:, :, :), dim=3)
! ========================
! ========================
    CALL CALC_VERT_MASS_FLUX(dbk, dps_ctm, dpi, wz, 1, im, 1, jm, 1, km)
!.sds2.. have all mass flux here: east-west(xmass),
!        north-south(ymass), vertical(wz)
!.sds2.. save omega (vertical flux) as diagnostic
! ==============
! ==============
    CALL SET_JN_JS(jn, js, cx, 1, im, 1, jm, 1, jm, j1p, j2p, 1, im, 1, &
&            jm, 1, km)
    IF (advec_consrv_opt .EQ. 0) THEN
!----------------------------------------------------------------
! Prior to 12/5/08:
! Replace these with explicit DO loops to facilitate
! OpenMP parallelization (bmy, 12/5/08)
!do ik = 1, km
!
!   delp2(:,:,ik) =  &
!        dap(ik) +  &
!        (dbk(ik) * (ps1(:,:) +  &
!        dps_ctm(:,:)))
!
!end do
!----------------------------------------------------------------
!$OMP PARALLEL DO           &
!$OMP DEFAULT( SHARED     ) &
!$OMP PRIVATE( IK, IJ, IL )
      DO ik=1,km
        DO ij=1,jm
          DO il=1,im
            delp2(il, ij, ik) = dap(ik) + dbk(ik)*(ps1(il, ij)+dps_ctm(&
&             il, ij))
          END DO
        END DO
      END DO
!$OMP END PARALLEL DO
    ELSE IF (advec_consrv_opt .EQ. 1 .OR. advec_consrv_opt .EQ. 2) THEN
!----------------------------------------------------------------
! Prior to 12/5/08:
! Replace these with explicit DO loops to facilitate
! OpenMP parallelization (bmy, 12/5/08)
!do il = 1, im
!
!   delp2(:,:,ik) =  &
!        dap(ik) +  &
!        (dbk(ik) * ps2(:,:))
!
!end do
!----------------------------------------------------------------
!$OMP PARALLEL DO           &
!$OMP DEFAULT( SHARED     ) &
!$OMP PRIVATE( IK, IJ, IL )
      DO ik=1,km
        DO ij=1,jm
          DO il=1,im
            delp2(il, ij, ik) = dap(ik) + dbk(ik)*ps2(il, ij)
          END DO
        END DO
      END DO
!$OMP END PARALLEL DO
    END IF
! Calculate surf. pressure at t+dt. (ccc, 11/20/08)
    ps = ak(1) + SUM(delp2, dim=3)
    dq1d = 0.0_8
!--------------------------------------------------------
! For time optimization : we parallelize over tracers and
! we loop over the levels outside horizontal transport
! subroutines. (ccc, 4/1/09)
!--------------------------------------------------------
!$OMP PARALLEL DO        &
!$OMP DEFAULT( SHARED   )&
!$OMP PRIVATE( IQ, IK, adx, ady, qqu, qqv, dq1, ptr_Q )
    DO iq=1,nq
      DO ik=1,km
!.sds.. convert to "mass"
        dq1d(:, :, ik) = delp1(:, :, ik)*qd(:, :, ik, iq)
        dq1(:, :, ik) = q(:, :, ik, iq)*delp1(:, :, ik)
! ===========================
! ===========================
        CALL CALC_ADVEC_CROSS_TERMS_D(jn(ik), js(ik), q(:, :, ik, iq), &
&                               qd(:, :, ik, iq), qqu, qqud, qqv, qqvd, &
&                               ua(:, :, ik), va(:, :, ik), j1p, j2p, im&
&                               , 1, jm, 1, im, 1, jm, 1, im, 1, jm, &
&                               cross)
!.sds.. notes on arrays
!  q (in)    - species mixing ratio
!  qqu (out) - concentration contribution from E-W
!             advection cross terms(mixing ratio)
!  qqv (out) - concentration contribution from N-S
!             advection cross terms(mixing ratio)
!  ua  (in)  - average of Courant numbers from il and il+1
!  va  (in)  - average of Courant numbers from ij and ij+1
! ----------------------------------------------------
!  Add advective form E-W operator for E-W cross terms.
! ----------------------------------------------------
! ==============
! ==============
        CALL XADV_DAO2_D(2, jn(ik), js(ik), adx, adxd, qqv, qqvd, ua(:, &
&                  :, ik), 1, im, 1, jm, 1, jm, j1p, j2p, 1, im, 1, jm)
!.sds notes on output arrays
!  adx (out)- cross term due to E-W advection (mixing ratio)
!  qqv (in) - concentration contribution from N-S
!             advection (mixing ratio)
!  ua  (in) - average of Courant numbers from il and il+1
!.sds
! ----------------------------------------------------
! Add advective form N-S operator for N-S cross terms.
! ----------------------------------------------------
! ==============
! ==============
        CALL YADV_DAO2_D(2, ady, adyd, qqu, qqud, va(:, :, ik), 1, im, 1&
&                  , jm, j1p, j2p, 1, im, 1, jm, 1, im, 1, jm)
!.sds notes on output arrays
!  ady (out)- cross term due to N-S advection (mixing ratio)
!  qqu (in) - concentration contribution from N-S advection
!             (mixing ratio)
!  va  (in) - average of Courant numbers from il and il+1
!.sds
!
!.bmy notes: use a polar cap of 2 boxes (i.e. the "2" as
! the first argument to YADV_DAO2.  The older TPCORE only had
! a polar cap of 1 box (just the Pole itself).  Claire figured
! this out.  (bmy, 12/11/08)
!... update constituent array qq1 by adding in cross terms
!           - use in fzppm
        qd(:, :, ik, iq) = qd(:, :, ik, iq) + adyd + adxd
        q(:, :, ik, iq) = q(:, :, ik, iq) + ady + adx
! ========
! ========
        CALL XTP_D(ilmt, jn(ik), js(ik), pu(:, :, ik), cx(:, :, ik), dq1&
&            (:, :, ik), dq1d(:, :, ik), qqv, qqvd, xmass(:, :, ik), fx(&
&            :, :, ik, iq), fxd(:, :, ik, iq), j1p, j2p, im, 1, jm, 1, &
&            im, 1, jm, 1, im, 1, jm, iord)
!.sds notes on output arrays
!  pu  (in)    - pressure at edges in "u" (mb)
!  crx (in)    - Courant number in E-W direction
!  dq1 (inout) - species density (mb) - updated with the E-W flux
!                fx in Xtp)
!  qqv (inout) - concentration contribution from N-S advection
!                (mixing ratio)
!  xmass(in)   - horizontal mass flux in E-W direction (mb)
!  fx  (out)   - species E-W mass flux
!.sds
! ========
! ========
        CALL YTP_D(jlmt, geofac_pc, geofac, cy(:, :, ik), dq1(:, :, ik)&
&            , dq1d(:, :, ik), qqu, qqud, qqv, qqvd, ymass(:, :, ik), fy&
&            (:, :, ik, iq), j1p, j2p, 1, im, 1, jm, im, 1, im, 1, jm, 1&
&            , im, 1, jm, jord)
      END DO
!.sds notes on output arrays
!  cy (in)     - Courant number in N-S direction
!  dq1 (inout) - species density (mb) - updated with the N-S flux
!                (fy in Ytp)
!  qqu (in)    - concentration contribution from E-W advection
!                (mixing ratio)
!  qqv (inout) - concentration contribution from N-S advection
!                (mixing ratio)
!  ymass(in)   - horizontal mass flux in E-W direction (mb)
!  fy  (out)   - species N-S mass flux (need to mult by geofac)
!.sds
      qtemp(:, :, :, iq) = q(:, :, :, iq)
! Set up temporary pointer to Q to avoid array temporary in FZPPM
! (bmy, 6/5/13)
      ptr_qd => qd(:, :, :, iq)
      ptr_q => q(:, :, :, iq)
! ==========
! ==========
      CALL FZPPM_D(klmt, delp1, wz, dq1, dq1d, ptr_q, ptr_qd, fz(:, :, :&
&            , iq), j1p, 1, jm, 1, im, 1, jm, im, km, 1, im, 1, jm, 1, &
&            km)
!.sds notes on output arrays
!   wz  (in) : vertical mass flux
!   dq1 (inout) : species density (mb)
!   q (in) : species concentration (mixing ratio)
!.sds
! Free pointer memory (bmy, 6/5/13)
      NULLIFY(ptr_q)
      IF (fill) THEN
! ===========
! ===========
        CALL QCKXYZ_D(dq1, dq1d, j1p, j2p, 1, jm, 1, im, 1, jm, 1, im, 1&
&               , jm, 1, km)
      END IF
      qd(:, :, :, iq) = dq1d/delp2
      q(:, :, :, iq) = dq1/delp2
      IF (j1p .NE. 2) THEN
        qd(:, 2, :, iq) = qd(:, 1, :, iq)
        q(:, 2, :, iq) = q(:, 1, :, iq)
        qd(:, jm-1, :, iq) = qd(:, jm, :, iq)
        q(:, jm-1, :, iq) = q(:, jm, :, iq)
      END IF
    END DO
!$OMP END PARALLEL DO
    DO iq=1,nq
      IF (j1p .LT. jfirst) THEN
        js2g0 = jfirst
      ELSE
        js2g0 = j1p
      END IF
      IF (j2p .GT. jlast) THEN
        jn2g0 = jlast
      ELSE
        jn2g0 = j2p
      END IF
!======================================================================
! MODIFICATION by Harvard Atmospheric Chemistry Modeling Group
!
! Implement ND24 diag: E/W flux of tracer [kg/s]  (ccarouge 12/2/08)
!
!  The unit conversion is:
!
!  Mass    P diff     100      1       area of     kg tracer     1
! ------ = in grid *  ---  *  ---   *  grid box * ----------- * ---
!  time    box         1       g       AREA_M2      kg air       s
!
!   kg       hPa       Pa     s^2        m^2          1          1
!  ----  =  -----  * ----- * -----  *   -----   *   ------  * --------
!   s         1       hPa      m          1          TCVV      DeltaT
!======================================================================
      IF (nd24 .GT. 0) THEN
! Zero temp array
        dtc = 0d0
!$OMP PARALLEL DO        &
!$OMP DEFAULT( SHARED  ) &
!$OMP PRIVATE( I, J, K )
        DO k=1,km
          DO j=js2g0,jn2g0
            DO i=1,im
! Compute mass flux
              dtc(i, j, k) = fx(i, j, k, iq)*area_m2(j)*100.d0/(tcvv(iq)&
&               *dt*9.8d0)
! Save into MASSFLEW diagnostic array
              massflew(i, j, k, iq) = massflew(i, j, k, iq) + dtc(i, j, &
&               k)
            END DO
          END DO
        END DO
!$OMP END PARALLEL DO
      END IF
!======================================================================
! MODIFICATION by Harvard Atmospheric Chemistry Modeling Group
!
! Implement ND25 diag: N/S flux of tracer [kg/s]
! (bdf, bmy, 9/28/04, ccarouge 12/12/08)
!
! NOTE, the unit conversion is the same as desciribed above for the
! ND24 E-W diagnostics.  The geometrical factor was already applied to
! fy in Ytp. (ccc, 4/1/09)
!======================================================================
      IF (nd25 .GT. 0) THEN
! Zero temp array
        dtc = 0d0
!$OMP PARALLEL DO        &
!$OMP DEFAULT( SHARED  ) &
!$OMP PRIVATE( I, J, K )
        DO k=1,km
          DO j=1,jm
            DO i=1,im
! Compute mass flux
              dtc(i, j, k) = fy(i, j, k, iq)*area_m2(j)*1d2/(tcvv(iq)*dt&
&               *9.8d0)
! Save into MASSFLNS diagnostic array
              massflns(i, j, k, iq) = massflns(i, j, k, iq) + dtc(i, j, &
&               k)
            END DO
          END DO
        END DO
!$OMP END PARALLEL DO
      END IF
!======================================================================
! MODIFICATION by Harvard Atmospheric Chemistry Modeling Group
!
! Implement ND26 diag: Up/down flux of tracer [kg/s]
! (bmy, bdf, 9/28/04, ccarouge 12/2/08)
!
! The vertical transport done in qmap.  We need to find the difference
! in order to to interpret transport.
!
! Break up diagnostic into up & down fluxes using the surface boundary
! conditions.  Start from top down (really surface up for flipped
! TPCORE)
!
! By construction, MASSFLUP is flux into the bottom of the box. The
! flux at the bottom of KM (the surface box) is not zero by design.
! (phs, 3/4/08)
!======================================================================
      IF (nd26 .GT. 0) THEN
! Zero temp array
        dtc = 0d0
!-----------------
! start with top
!-----------------
        k = 1
!$OMP PARALLEL DO       &
!$OMP DEFAULT( SHARED ) &
!$OMP PRIVATE( I, J )
        DO j=1,jm
          DO i=1,im
! Compute mass flux
            dtc(i, j, k) = (q(i, j, k, iq)*delp1(i, j, k)-qtemp(i, j, k&
&             , iq)*delp2(i, j, k))*100d0*area_m2(j)/(9.8d0*tcvv(iq))
! top layer should have no residual.  the small residual is
! from a non-pressure fixed flux diag.  The z direction may
! be off by a few percent.
!
! Uncomment now, since this is upflow into the box from its
! bottom (phs, 3/4/08)
            massflup(i, j, k, iq) = massflup(i, j, k, iq) + dtc(i, j, k)&
&             /dt
          END DO
        END DO
!$OMP END PARALLEL DO
!----------------------------------------------------
! Get the other fluxes using a mass balance equation
!----------------------------------------------------
        DO k=2,km
!$OMP PARALLEL DO                 &
!$OMP DEFAULT( SHARED )           &
!$OMP PRIVATE( I, J, TRACE_DIFF )
          DO j=1,jm
            DO i=1,im
! Compute tracer difference
              trace_diff = (q(i, j, k, iq)*delp1(i, j, k)-qtemp(i, j, k&
&               , iq)*delp2(i, j, k))*100d0*area_m2(j)/(9.8d0*tcvv(iq))
! Compute mass flux
              dtc(i, j, k) = dtc(i, j, k-1) + trace_diff
! Save to the MASSFLUP diagnostic array
              massflup(i, j, k, iq) = massflup(i, j, k, iq) + dtc(i, j, &
&               k)/dt
            END DO
          END DO
!$OMP END PARALLEL DO
        END DO
      END IF
    END DO
  END SUBROUTINE TPCORE_FVDAS_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Tpcore_FvDas
!
! !DESCRIPTION: Subroutine Tpcore\_FvDas takes horizontal winds on sigma
!  (or hybrid sigma-p) surfaces and calculates mass fluxes, and then updates
!   the 3D mixing ratio fields one time step (tdt).  The basic scheme is a
!   Multi-Dimensional Flux Form Semi-Lagrangian (FFSL) based on the van Leer
!   or PPM (see Lin and Rood, 1995).
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE TPCORE_FVDAS(dt, ae, im, jm, km, jfirst, jlast, ng, mg, nq&
&   , ak, bk, u, v, ps1, ps2, ps, q, iord, jord, kord, n_adj, xmass, &
&   ymass, massflew, massflns, massflup, area_m2, tcvv, nd24, nd25, nd26&
&   , fill)
!
! !USES:
!
! Include file w/ physical constants
    USE PHYSCONSTANTS
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Transport time step [s]
    REAL*8, INTENT(IN) :: dt
! Earth's radius [m]
    REAL*8, INTENT(IN) :: ae
! Global E-W, N-S, and vertical dimensions
    INTEGER, INTENT(IN) :: im
    INTEGER, INTENT(IN) :: jm
    INTEGER, INTENT(IN) :: km
! Latitude indices for local first box and local last box
! (NOTE: for global grids these are 1 and JM, respectively)
    INTEGER, INTENT(IN) :: jfirst
    INTEGER, INTENT(IN) :: jlast
! Primary ghost region
! (NOTE: only required for MPI parallelization; use 0 otherwise)
    INTEGER, INTENT(IN) :: ng
! Secondary ghost region
! (NOTE: only required for MPI parallelization; use 0 otherwise)
    INTEGER, INTENT(IN) :: mg
! Ghosted latitudes (3 required by PPM)
! (NOTE: only required for MPI parallelization; use 0 otherwise)
    INTEGER, INTENT(IN) :: nq
! Flags to denote E-W, N-S, and vertical transport schemes
    INTEGER, INTENT(IN) :: iord
    INTEGER, INTENT(IN) :: jord
    INTEGER, INTENT(IN) :: kord
! Number of adjustments to air_mass_flux (0 = no adjustment)
    INTEGER, INTENT(IN) :: n_adj
! Ak and Bk coordinates to specify the hybrid grid
! (see the REMARKS section below)
    REAL*8, INTENT(IN) :: ak(km+1)
    REAL*8, INTENT(IN) :: bk(km+1)
! u-wind (m/s) at mid-time-level (t=t+dt/2)
    REAL*8, INTENT(IN) :: u(:, :, :)
! E/W and N/S mass fluxes [kg/s]
! (These are computed by the pressure fixer, and passed into TPCORE)
    REAL*8, INTENT(IN) :: xmass(:, :, :)
    REAL*8, INTENT(IN) :: ymass(:, :, :)
! Grid box surface area for mass flux diag [m2]
    REAL*8, INTENT(IN) :: area_m2(jm)
! Tracer masses for flux diag
    REAL*8, INTENT(IN) :: tcvv(nq)
! Diagnostic flags
! Turns on E/W     flux diagnostic
    INTEGER, INTENT(IN) :: nd24
! Turns on N/S     flux diagnostic
    INTEGER, INTENT(IN) :: nd25
! Turns on up/down flux diagnostic
    INTEGER, INTENT(IN) :: nd26
! Negative Concentration Filling Parameter
! Turns on up/down flux diagnostic
    LOGICAL, INTENT(IN) :: fill
!
! !INPUT/OUTPUT PARAMETERS:
!
! V-wind (m/s) at mid-time-level (t=t+dt/2)
    REAL*8, INTENT(INOUT) :: v(:, :, :)
! surface pressure at current time
    REAL*8, INTENT(INOUT) :: ps1(im, jfirst:jlast)
! surface pressure at future time=t+dt
    REAL*8, INTENT(INOUT) :: ps2(im, jfirst:jlast)
! Tracer "mixing ratios" [v/v]
    REAL*8, INTENT(INOUT), TARGET :: q(:, :, :, :)
! Add pointer to avoid array temporary in call to FZPPM (bmy, 6/5/13)
    REAL*8, POINTER :: ptr_q(:, :, :)
! E/W, N/S, and up/down diagnostic mass fluxes
!--- Previous to (ccc, 12/3/09)
!    REAL*8,  INTENT(INOUT) :: MASSFLEW(IM,JM,KM,NQ)  ! for ND24 diagnostic
!    REAL*8,  INTENT(INOUT) :: MASSFLNS(IM,JM,KM,NQ)  ! for ND25 diagnostic
!    REAL*8,  INTENT(INOUT) :: MASSFLUP(IM,JM,KM,NQ)  ! for ND26 diagnostic
! for ND24 diagnostic
    REAL*8, INTENT(INOUT) :: massflew(:, :, :, :)
! for ND25 diagnostic
    REAL*8, INTENT(INOUT) :: massflns(:, :, :, :)
! for ND26 diagnostic
    REAL*8, INTENT(INOUT) :: massflup(:, :, :, :)
! !OUTPUT PARAMETERS:
!
! "Predicted" surface pressure [hPa]
    REAL*8, INTENT(OUT) :: ps(im, jfirst:jlast)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO)
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Modified OpenMp parallelization and move the
!                               loops over vertical levels outside the
!                               horizontal transport routines for reducing
!                               processing time.
!
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !DEFINED PARAMETERS:
!
!    LOGICAL, PARAMETER :: FILL = .true.                 ! Fill negatives ?
! 2=floating pressure
    INTEGER, PARAMETER :: advec_consrv_opt=2
    LOGICAL, PARAMETER :: cross=.true.
!
! !LOCAL VARIABLES:
!
    INTEGER :: rj2m1
    INTEGER :: j1p, j2p
    INTEGER :: jn(km)
    INTEGER :: js(km)
    INTEGER :: il, ij, ik, iq, k, j, i
    INTEGER :: num, k2m1
    REAL*8 :: dap(km)
    REAL*8 :: dbk(km)
! E-W CFL # on C-grid
    REAL*8 :: cx(im, jfirst-ng:jlast+ng, km)
! N-S CFL # on C-grid
    REAL*8 :: cy(im, jfirst:jlast+mg, km)
    REAL*8 :: delp1(im, jm, km)
    REAL*8 :: delp2(im, jm, km)
    REAL*8 :: delpm(im, jm, km)
    REAL*8 :: pu(im, jm, km)
    REAL*8 :: dpi(im, jm, km)
! geometrical factor for meridional
    REAL*8 :: geofac(jm)
! advection; geofac uses correct
! spherical geometry, and replaces
! RGW_25. (ccc, 4/1/09)
! geometrical gactor for poles.
    REAL*8 :: geofac_pc
    REAL*8 :: dp
    REAL*8 :: dps_ctm(im, jm)
    REAL*8 :: ua(im, jm, km)
    REAL*8 :: va(im, jm, km)
    REAL*8 :: wz(im, jm, km)
    REAL*8 :: dq1(im, jfirst-ng:jlast+ng, km)
! qqu, qqv, adx and ady are now 2d arrays for parallelization purposes.
!(ccc, 4/1/08)
    REAL*8 :: qqu(im, jm)
    REAL*8 :: qqv(im, jm)
    REAL*8 :: adx(im, jm)
    REAL*8 :: ady(im, jm)
! fx, fy, fz and qtemp are now 4D arrays for parallelization purposes.
! (ccc, 4/1/09)
    REAL*8 :: fx(im, jm, km, nq)
! one more for edges
    REAL*8 :: fy(im, jm+1, km, nq)
    REAL*8 :: fz(im, jm, km, nq)
    REAL*8 :: qtemp(im, jm, km, nq)
! up/down flux temp array
    REAL*8 :: dtc(im, jm, km)
! up/down flux variable
    REAL*8 :: trace_diff
    LOGICAL, SAVE :: first=.true.
!     ----------------------------------------------------
!     ilmt : controls various options in E-W     advection
!     jlmt : controls various options in N-S     advection
!     klmt : controls various options in vertcal advection
!     ----------------------------------------------------
    INTEGER, SAVE :: ilmt, jlmt, klmt
    INTEGER :: js2g0, jn2g0
    INTRINSIC SUM
    INTRINSIC MAX
    INTRINSIC MIN
!     ----------------
!     Begin execution.
!     ----------------
! adj_group: BUG FIX During the adjoint call to GEOS-5 transport, the array "va" sometimes
! ends up with random values, say in locations like va(71,2), which are never
! inititialized or explicitly defined. Shouldn't they be defined somewhere?
! That could be a bug in fwd model... but initializing va to 0d0 at the
! start of TPCORE fixes the problem.  Note that the symptom is:
!   forrtl: severe (408): fort: (3): Subscript #2 of the array QQUWK has
!   value -2 which is less than the lower bound of -1
! So initialize va to 0d0 for now (dkh, 09/20/09).
    va = 0d0
! Add definition of j1p and j2p for enlarge polar cap. (ccc, 11/20/08)
    j1p = 3
    j2p = jm - j1p + 1
! Average surf. pressures in the polar cap. (ccc, 11/20/08)
    CALL AVERAGE_PRESS_POLES(area_m2, ps1, 1, im, 1, jm, 1, im, 1, jm)
    CALL AVERAGE_PRESS_POLES(area_m2, ps2, 1, im, 1, jm, 1, im, 1, jm)
! Calculation of some geographic factors. (ccc, 11/20/08)
    rj2m1 = jm - 1
    dp = pi/rj2m1
    DO ij=1,jm
      geofac(ij) = dp/(2.0d0*area_m2(ij)/(SUM(area_m2)*im)*im)
    END DO
    geofac_pc = dp/(2.0d0*(SUM(area_m2(1:2))/(SUM(area_m2)*im))*im)
    IF (first) THEN
      first = .false.
! =============
! =============
      CALL SET_LMTS(ilmt, jlmt, klmt, im, jm, iord, jord, kord)
    END IF
! Pressure calculations. (ccc, 11/20/08)
    DO ik=1,km
      dap(ik) = ak(ik+1) - ak(ik)
      dbk(ik) = bk(ik+1) - bk(ik)
    END DO
!$OMP PARALLEL DO        &
!$OMP DEFAULT( SHARED   )&
!$OMP PRIVATE( IK, IQ )
    DO ik=1,km
! ====================
! ====================
      CALL SET_PRESS_TERMS(dap(ik), dbk(ik), ps1, ps2, delp1(:, :, ik), &
&                    delpm(:, :, ik), pu(:, :, ik), 1, jm, 1, im, 1, jm&
&                    , j1p, j2p, 1, im, 1, jm)
!
!...intent(in)  dap - difference in ai across layer (mb)
!...intent(in)  dbk - difference in bi across layer (mb)
!...intent(in)  pres1 - surface pressure at t1 (mb)
!...intent(in)  pres2 - surface pressure at t1+tdt (mb)
!...intent(out) delp1 - pressure thickness at t1 (mb)
!...intent(out) delpm - pressure thickness at t1+tdt/2 (mb)
!...intent(out) pu - pressure at edges of box for "u" (mb)
!
      IF (j1p .NE. 1 + 1) THEN
        DO iq=1,nq
!  ========================
!  ========================
          CALL AVERAGE_CONST_POLES(dap(ik), dbk(ik), area_m2, ps1, q(:, &
&                            :, ik, iq), 1, jm, im, 1, im, 1, jm, 1, im&
&                            , 1, jm)
        END DO
      END IF
! =================
! =================
      CALL CALC_COURANT(cose, delpm(:, :, ik), pu(:, :, ik), xmass(:, :&
&                 , ik), ymass(:, :, ik), cx(:, :, ik), cy(:, :, ik), &
&                 j1p, j2p, 1, jm, 1, im, 1, jm, 1, im, 1, jm)
! ====================
! ====================
      CALL CALC_DIVERGENCE(.true., geofac_pc, geofac, dpi(:, :, ik), &
&                    xmass(:, :, ik), ymass(:, :, ik), j1p, j2p, 1, im, &
&                    1, jm, 1, im, 1, jm, 1, im, 1, jm)
! ====================
! ====================
      CALL SET_CROSS_TERMS(cx(:, :, ik), cy(:, :, ik), ua(:, :, ik), va(&
&                    :, :, ik), j1p, j2p, 1, im, 1, jm, 1, im, 1, jm, 1&
&                    , im, 1, jm, cross)
    END DO
!$OMP END PARALLEL DO
    dps_ctm(:, :) = SUM(dpi(:, :, :), dim=3)
! ========================
! ========================
    CALL CALC_VERT_MASS_FLUX(dbk, dps_ctm, dpi, wz, 1, im, 1, jm, 1, km)
!.sds2.. have all mass flux here: east-west(xmass),
!        north-south(ymass), vertical(wz)
!.sds2.. save omega (vertical flux) as diagnostic
! ==============
! ==============
    CALL SET_JN_JS(jn, js, cx, 1, im, 1, jm, 1, jm, j1p, j2p, 1, im, 1, &
&            jm, 1, km)
    IF (advec_consrv_opt .EQ. 0) THEN
!----------------------------------------------------------------
! Prior to 12/5/08:
! Replace these with explicit DO loops to facilitate
! OpenMP parallelization (bmy, 12/5/08)
!do ik = 1, km
!
!   delp2(:,:,ik) =  &
!        dap(ik) +  &
!        (dbk(ik) * (ps1(:,:) +  &
!        dps_ctm(:,:)))
!
!end do
!----------------------------------------------------------------
!$OMP PARALLEL DO           &
!$OMP DEFAULT( SHARED     ) &
!$OMP PRIVATE( IK, IJ, IL )
      DO ik=1,km
        DO ij=1,jm
          DO il=1,im
            delp2(il, ij, ik) = dap(ik) + dbk(ik)*(ps1(il, ij)+dps_ctm(&
&             il, ij))
          END DO
        END DO
      END DO
!$OMP END PARALLEL DO
    ELSE IF (advec_consrv_opt .EQ. 1 .OR. advec_consrv_opt .EQ. 2) THEN
!----------------------------------------------------------------
! Prior to 12/5/08:
! Replace these with explicit DO loops to facilitate
! OpenMP parallelization (bmy, 12/5/08)
!do il = 1, im
!
!   delp2(:,:,ik) =  &
!        dap(ik) +  &
!        (dbk(ik) * ps2(:,:))
!
!end do
!----------------------------------------------------------------
!$OMP PARALLEL DO           &
!$OMP DEFAULT( SHARED     ) &
!$OMP PRIVATE( IK, IJ, IL )
      DO ik=1,km
        DO ij=1,jm
          DO il=1,im
            delp2(il, ij, ik) = dap(ik) + dbk(ik)*ps2(il, ij)
          END DO
        END DO
      END DO
!$OMP END PARALLEL DO
    END IF
! Calculate surf. pressure at t+dt. (ccc, 11/20/08)
    ps = ak(1) + SUM(delp2, dim=3)
!--------------------------------------------------------
! For time optimization : we parallelize over tracers and
! we loop over the levels outside horizontal transport
! subroutines. (ccc, 4/1/09)
!--------------------------------------------------------
!$OMP PARALLEL DO        &
!$OMP DEFAULT( SHARED   )&
!$OMP PRIVATE( IQ, IK, adx, ady, qqu, qqv, dq1, ptr_Q )
    DO iq=1,nq
      DO ik=1,km
!.sds.. convert to "mass"
        dq1(:, :, ik) = q(:, :, ik, iq)*delp1(:, :, ik)
! ===========================
! ===========================
        CALL CALC_ADVEC_CROSS_TERMS(jn(ik), js(ik), q(:, :, ik, iq), qqu&
&                             , qqv, ua(:, :, ik), va(:, :, ik), j1p, &
&                             j2p, im, 1, jm, 1, im, 1, jm, 1, im, 1, jm&
&                             , cross)
!.sds.. notes on arrays
!  q (in)    - species mixing ratio
!  qqu (out) - concentration contribution from E-W
!             advection cross terms(mixing ratio)
!  qqv (out) - concentration contribution from N-S
!             advection cross terms(mixing ratio)
!  ua  (in)  - average of Courant numbers from il and il+1
!  va  (in)  - average of Courant numbers from ij and ij+1
! ----------------------------------------------------
!  Add advective form E-W operator for E-W cross terms.
! ----------------------------------------------------
! ==============
! ==============
        CALL XADV_DAO2(2, jn(ik), js(ik), adx, qqv, ua(:, :, ik), 1, im&
&                , 1, jm, 1, jm, j1p, j2p, 1, im, 1, jm)
!.sds notes on output arrays
!  adx (out)- cross term due to E-W advection (mixing ratio)
!  qqv (in) - concentration contribution from N-S
!             advection (mixing ratio)
!  ua  (in) - average of Courant numbers from il and il+1
!.sds
! ----------------------------------------------------
! Add advective form N-S operator for N-S cross terms.
! ----------------------------------------------------
! ==============
! ==============
        CALL YADV_DAO2(2, ady, qqu, va(:, :, ik), 1, im, 1, jm, j1p, j2p&
&                , 1, im, 1, jm, 1, im, 1, jm)
!.sds notes on output arrays
!  ady (out)- cross term due to N-S advection (mixing ratio)
!  qqu (in) - concentration contribution from N-S advection
!             (mixing ratio)
!  va  (in) - average of Courant numbers from il and il+1
!.sds
!
!.bmy notes: use a polar cap of 2 boxes (i.e. the "2" as
! the first argument to YADV_DAO2.  The older TPCORE only had
! a polar cap of 1 box (just the Pole itself).  Claire figured
! this out.  (bmy, 12/11/08)
!... update constituent array qq1 by adding in cross terms
!           - use in fzppm
        q(:, :, ik, iq) = q(:, :, ik, iq) + ady + adx
! ========
! ========
        CALL XTP(ilmt, jn(ik), js(ik), pu(:, :, ik), cx(:, :, ik), dq1(:&
&          , :, ik), qqv, xmass(:, :, ik), fx(:, :, ik, iq), j1p, j2p, &
&          im, 1, jm, 1, im, 1, jm, 1, im, 1, jm, iord)
!.sds notes on output arrays
!  pu  (in)    - pressure at edges in "u" (mb)
!  crx (in)    - Courant number in E-W direction
!  dq1 (inout) - species density (mb) - updated with the E-W flux
!                fx in Xtp)
!  qqv (inout) - concentration contribution from N-S advection
!                (mixing ratio)
!  xmass(in)   - horizontal mass flux in E-W direction (mb)
!  fx  (out)   - species E-W mass flux
!.sds
! ========
! ========
        CALL YTP(jlmt, geofac_pc, geofac, cy(:, :, ik), dq1(:, :, ik), &
&          qqu, qqv, ymass(:, :, ik), fy(:, :, ik, iq), j1p, j2p, 1, im&
&          , 1, jm, im, 1, im, 1, jm, 1, im, 1, jm, jord)
      END DO
!.sds notes on output arrays
!  cy (in)     - Courant number in N-S direction
!  dq1 (inout) - species density (mb) - updated with the N-S flux
!                (fy in Ytp)
!  qqu (in)    - concentration contribution from E-W advection
!                (mixing ratio)
!  qqv (inout) - concentration contribution from N-S advection
!                (mixing ratio)
!  ymass(in)   - horizontal mass flux in E-W direction (mb)
!  fy  (out)   - species N-S mass flux (need to mult by geofac)
!.sds
      qtemp(:, :, :, iq) = q(:, :, :, iq)
! Set up temporary pointer to Q to avoid array temporary in FZPPM
! (bmy, 6/5/13)
      ptr_q => q(:, :, :, iq)
! ==========
! ==========
      CALL FZPPM(klmt, delp1, wz, dq1, ptr_q, fz(:, :, :, iq), j1p, 1, &
&          jm, 1, im, 1, jm, im, km, 1, im, 1, jm, 1, km)
!.sds notes on output arrays
!   wz  (in) : vertical mass flux
!   dq1 (inout) : species density (mb)
!   q (in) : species concentration (mixing ratio)
!.sds
! Free pointer memory (bmy, 6/5/13)
      NULLIFY(ptr_q)
      IF (fill) THEN
! ===========
! ===========
        CALL QCKXYZ(dq1, j1p, j2p, 1, jm, 1, im, 1, jm, 1, im, 1, jm, 1&
&             , km)
      END IF
      q(:, :, :, iq) = dq1/delp2
      IF (j1p .NE. 2) THEN
        q(:, 2, :, iq) = q(:, 1, :, iq)
        q(:, jm-1, :, iq) = q(:, jm, :, iq)
      END IF
    END DO
!$OMP END PARALLEL DO
    DO iq=1,nq
      IF (j1p .LT. jfirst) THEN
        js2g0 = jfirst
      ELSE
        js2g0 = j1p
      END IF
      IF (j2p .GT. jlast) THEN
        jn2g0 = jlast
      ELSE
        jn2g0 = j2p
      END IF
!======================================================================
! MODIFICATION by Harvard Atmospheric Chemistry Modeling Group
!
! Implement ND24 diag: E/W flux of tracer [kg/s]  (ccarouge 12/2/08)
!
!  The unit conversion is:
!
!  Mass    P diff     100      1       area of     kg tracer     1
! ------ = in grid *  ---  *  ---   *  grid box * ----------- * ---
!  time    box         1       g       AREA_M2      kg air       s
!
!   kg       hPa       Pa     s^2        m^2          1          1
!  ----  =  -----  * ----- * -----  *   -----   *   ------  * --------
!   s         1       hPa      m          1          TCVV      DeltaT
!======================================================================
      IF (nd24 .GT. 0) THEN
! Zero temp array
        dtc = 0d0
!$OMP PARALLEL DO        &
!$OMP DEFAULT( SHARED  ) &
!$OMP PRIVATE( I, J, K )
        DO k=1,km
          DO j=js2g0,jn2g0
            DO i=1,im
! Compute mass flux
              dtc(i, j, k) = fx(i, j, k, iq)*area_m2(j)*100.d0/(tcvv(iq)&
&               *dt*9.8d0)
! Save into MASSFLEW diagnostic array
              massflew(i, j, k, iq) = massflew(i, j, k, iq) + dtc(i, j, &
&               k)
            END DO
          END DO
        END DO
!$OMP END PARALLEL DO
      END IF
!======================================================================
! MODIFICATION by Harvard Atmospheric Chemistry Modeling Group
!
! Implement ND25 diag: N/S flux of tracer [kg/s]
! (bdf, bmy, 9/28/04, ccarouge 12/12/08)
!
! NOTE, the unit conversion is the same as desciribed above for the
! ND24 E-W diagnostics.  The geometrical factor was already applied to
! fy in Ytp. (ccc, 4/1/09)
!======================================================================
      IF (nd25 .GT. 0) THEN
! Zero temp array
        dtc = 0d0
!$OMP PARALLEL DO        &
!$OMP DEFAULT( SHARED  ) &
!$OMP PRIVATE( I, J, K )
        DO k=1,km
          DO j=1,jm
            DO i=1,im
! Compute mass flux
              dtc(i, j, k) = fy(i, j, k, iq)*area_m2(j)*1d2/(tcvv(iq)*dt&
&               *9.8d0)
! Save into MASSFLNS diagnostic array
              massflns(i, j, k, iq) = massflns(i, j, k, iq) + dtc(i, j, &
&               k)
            END DO
          END DO
        END DO
!$OMP END PARALLEL DO
      END IF
!======================================================================
! MODIFICATION by Harvard Atmospheric Chemistry Modeling Group
!
! Implement ND26 diag: Up/down flux of tracer [kg/s]
! (bmy, bdf, 9/28/04, ccarouge 12/2/08)
!
! The vertical transport done in qmap.  We need to find the difference
! in order to to interpret transport.
!
! Break up diagnostic into up & down fluxes using the surface boundary
! conditions.  Start from top down (really surface up for flipped
! TPCORE)
!
! By construction, MASSFLUP is flux into the bottom of the box. The
! flux at the bottom of KM (the surface box) is not zero by design.
! (phs, 3/4/08)
!======================================================================
      IF (nd26 .GT. 0) THEN
! Zero temp array
        dtc = 0d0
!-----------------
! start with top
!-----------------
        k = 1
!$OMP PARALLEL DO       &
!$OMP DEFAULT( SHARED ) &
!$OMP PRIVATE( I, J )
        DO j=1,jm
          DO i=1,im
! Compute mass flux
            dtc(i, j, k) = (q(i, j, k, iq)*delp1(i, j, k)-qtemp(i, j, k&
&             , iq)*delp2(i, j, k))*100d0*area_m2(j)/(9.8d0*tcvv(iq))
! top layer should have no residual.  the small residual is
! from a non-pressure fixed flux diag.  The z direction may
! be off by a few percent.
!
! Uncomment now, since this is upflow into the box from its
! bottom (phs, 3/4/08)
            massflup(i, j, k, iq) = massflup(i, j, k, iq) + dtc(i, j, k)&
&             /dt
          END DO
        END DO
!$OMP END PARALLEL DO
!----------------------------------------------------
! Get the other fluxes using a mass balance equation
!----------------------------------------------------
        DO k=2,km
!$OMP PARALLEL DO                 &
!$OMP DEFAULT( SHARED )           &
!$OMP PRIVATE( I, J, TRACE_DIFF )
          DO j=1,jm
            DO i=1,im
! Compute tracer difference
              trace_diff = (q(i, j, k, iq)*delp1(i, j, k)-qtemp(i, j, k&
&               , iq)*delp2(i, j, k))*100d0*area_m2(j)/(9.8d0*tcvv(iq))
! Compute mass flux
              dtc(i, j, k) = dtc(i, j, k-1) + trace_diff
! Save to the MASSFLUP diagnostic array
              massflup(i, j, k, iq) = massflup(i, j, k, iq) + dtc(i, j, &
&               k)/dt
            END DO
          END DO
!$OMP END PARALLEL DO
        END DO
      END IF
    END DO
  END SUBROUTINE TPCORE_FVDAS

!  Differentiation of average_const_poles in forward (tangent) mode:
!   variations   of useful results: const1
!   with respect to varying inputs: const1
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Average_Const_Poles
!
! !DESCRIPTION: Subroutine Average\_Const\_Poles averages the species
!  concentrations at the Poles when the Polar cap is enlarged.  It makes the
!  last two latitudes equal.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE AVERAGE_CONST_POLES_D(dap, dbk, rel_area, pctm1, const1, &
&   const1d, ju1_gl, j2_gl, i2_gl, i1, i2, ju1, j2, ilo, ihi, julo, jhi)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices of the South Pole and North Pole
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Global max longitude index
    INTEGER, INTENT(IN) :: i2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Pressure difference across layer from (ai * pt) term [hPa]
    REAL*8, INTENT(IN) :: dap
! Difference in bi across layer - the dSigma term
    REAL*8, INTENT(IN) :: dbk
! Relative surface area of grid box [fraction]
    REAL*8, INTENT(IN) :: rel_area(ju1:j2)
! CTM surface pressure at t1 [hPa]
    REAL*8, INTENT(IN) :: pctm1(ilo:ihi, julo:jhi)
!
! !INPUT/OUTPUT PARAMETERS:
!
! Species concentration, known at zone center [mixing ratio]
    REAL*8, INTENT(INOUT) :: const1(i1:i2, ju1:j2)
    REAL*8, INTENT(INOUT) :: const1d(i1:i2, ju1:j2)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO)
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
    INTEGER :: ik, il
    REAL*8 :: meanq
    REAL*8 :: meanqd
    REAL*8 :: sum1, sum2
    REAL*8 :: sum1d
!   -----------------------------------------------------------------
!   delp1n : pressure thickness at North Pole, the psudo-density in a
!            hydrostatic system at t1 (mb)
!   delp1s : pressure thickness at South Pole, the psudo-density in a
!            hydrostatic system at t1 (mb)
!   -----------------------------------------------------------------
    REAL*8 :: delp1n(i1:i2, j2-1:j2)
    REAL*8 :: delp1s(i1:i2, ju1:ju1+1)
    INTRINSIC SUM
    REAL*8, DIMENSION(2) :: arg1
    REAL*8, DIMENSION(2) :: arg1d
    REAL*8, DIMENSION(2) :: temp
    REAL*8 :: temp0
!   ----------------
!   Begin execution.
!   ----------------
!   =================
    IF (ju1 .EQ. ju1_gl) THEN
!   =================
      delp1s(i1:i2, ju1:ju1+1) = dap + dbk*pctm1(i1:i2, ju1:ju1+1)
      sum1 = 0.0d0
      sum2 = 0.0d0
      sum1d = 0.0_8
      DO il=i1,i2
        temp = delp1s(il, ju1:ju1+1)*rel_area(ju1:ju1+1)
        arg1d(:) = temp*const1d(il, ju1:ju1+1)
        arg1(:) = temp*const1(il, ju1:ju1+1)
        temp0 = SUM(rel_area)*i2_gl
        sum1d = sum1d + SUM(arg1d(:))/temp0
        sum1 = sum1 + SUM(arg1(:))/temp0
        arg1(:) = delp1s(il, ju1:ju1+1)*rel_area(ju1:ju1+1)
        sum2 = sum2 + SUM(arg1(:))/(SUM(rel_area)*i2_gl)
      END DO
      meanqd = sum1d/sum2
      meanq = sum1/sum2
      const1d(:, ju1:ju1+1) = meanqd
      const1(:, ju1:ju1+1) = meanq
    END IF
!   ================
    IF (j2 .EQ. j2_gl) THEN
!   ================
      delp1n(i1:i2, j2-1:j2) = dap + dbk*pctm1(i1:i2, j2-1:j2)
      sum1 = 0.0d0
      sum2 = 0.0d0
      sum1d = 0.0_8
      DO il=i1,i2
        temp = delp1n(il, j2-1:j2)*rel_area(j2-1:j2)
        arg1d(:) = temp*const1d(il, j2-1:j2)
        arg1(:) = temp*const1(il, j2-1:j2)
        temp0 = SUM(rel_area)*i2_gl
        sum1d = sum1d + SUM(arg1d(:))/temp0
        sum1 = sum1 + SUM(arg1(:))/temp0
        arg1(:) = delp1n(il, j2-1:j2)*rel_area(j2-1:j2)
        sum2 = sum2 + SUM(arg1(:))/(SUM(rel_area)*i2_gl)
      END DO
      meanqd = sum1d/sum2
      meanq = sum1/sum2
      const1d(:, j2-1:j2) = meanqd
      const1(:, j2-1:j2) = meanq
    END IF
  END SUBROUTINE AVERAGE_CONST_POLES_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Average_Const_Poles
!
! !DESCRIPTION: Subroutine Average\_Const\_Poles averages the species
!  concentrations at the Poles when the Polar cap is enlarged.  It makes the
!  last two latitudes equal.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE AVERAGE_CONST_POLES(dap, dbk, rel_area, pctm1, const1, &
&   ju1_gl, j2_gl, i2_gl, i1, i2, ju1, j2, ilo, ihi, julo, jhi)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices of the South Pole and North Pole
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Global max longitude index
    INTEGER, INTENT(IN) :: i2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Pressure difference across layer from (ai * pt) term [hPa]
    REAL*8, INTENT(IN) :: dap
! Difference in bi across layer - the dSigma term
    REAL*8, INTENT(IN) :: dbk
! Relative surface area of grid box [fraction]
    REAL*8, INTENT(IN) :: rel_area(ju1:j2)
! CTM surface pressure at t1 [hPa]
    REAL*8, INTENT(IN) :: pctm1(ilo:ihi, julo:jhi)
!
! !INPUT/OUTPUT PARAMETERS:
!
! Species concentration, known at zone center [mixing ratio]
    REAL*8, INTENT(INOUT) :: const1(i1:i2, ju1:j2)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO)
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
    INTEGER :: ik, il
    REAL*8 :: meanq
    REAL*8 :: sum1, sum2
!   -----------------------------------------------------------------
!   delp1n : pressure thickness at North Pole, the psudo-density in a
!            hydrostatic system at t1 (mb)
!   delp1s : pressure thickness at South Pole, the psudo-density in a
!            hydrostatic system at t1 (mb)
!   -----------------------------------------------------------------
    REAL*8 :: delp1n(i1:i2, j2-1:j2)
    REAL*8 :: delp1s(i1:i2, ju1:ju1+1)
    INTRINSIC SUM
    REAL*8, DIMENSION(2) :: arg1
!   ----------------
!   Begin execution.
!   ----------------
!   =================
    IF (ju1 .EQ. ju1_gl) THEN
!   =================
      delp1s(i1:i2, ju1:ju1+1) = dap + dbk*pctm1(i1:i2, ju1:ju1+1)
      sum1 = 0.0d0
      sum2 = 0.0d0
      DO il=i1,i2
        arg1(:) = const1(il, ju1:ju1+1)*delp1s(il, ju1:ju1+1)*rel_area(&
&         ju1:ju1+1)
        sum1 = sum1 + SUM(arg1(:))/(SUM(rel_area)*i2_gl)
        arg1(:) = delp1s(il, ju1:ju1+1)*rel_area(ju1:ju1+1)
        sum2 = sum2 + SUM(arg1(:))/(SUM(rel_area)*i2_gl)
      END DO
      meanq = sum1/sum2
      const1(:, ju1:ju1+1) = meanq
    END IF
!   ================
    IF (j2 .EQ. j2_gl) THEN
!   ================
      delp1n(i1:i2, j2-1:j2) = dap + dbk*pctm1(i1:i2, j2-1:j2)
      sum1 = 0.0d0
      sum2 = 0.0d0
      DO il=i1,i2
        arg1(:) = const1(il, j2-1:j2)*delp1n(il, j2-1:j2)*rel_area(j2-1:&
&         j2)
        sum1 = sum1 + SUM(arg1(:))/(SUM(rel_area)*i2_gl)
        arg1(:) = delp1n(il, j2-1:j2)*rel_area(j2-1:j2)
        sum2 = sum2 + SUM(arg1(:))/(SUM(rel_area)*i2_gl)
      END DO
      meanq = sum1/sum2
      const1(:, j2-1:j2) = meanq
    END IF
  END SUBROUTINE AVERAGE_CONST_POLES

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Set_Cross_Terms
!
! !DESCRIPTION: Subroutine Set\_Cross\_Terms sets the cross terms for
!  E-W horizontal advection.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE SET_CROSS_TERMS(crx, cry, ua, va, j1p, j2p, i1_gl, i2_gl, &
&   ju1_gl, j2_gl, ilo, ihi, julo, jhi, i1, i2, ju1, j2, cross)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Courant number in E-W direction
    REAL*8, INTENT(IN) :: crx(ilo:ihi, julo:jhi)
! Courant number in N-S direction
    REAL*8, INTENT(IN) :: cry(ilo:ihi, julo:jhi)
! Logical switch.  If CROSS=T then cross-terms will be computed.
    LOGICAL, INTENT(IN) :: cross
!
! !OUTPUT PARAMETERS:
!
! Average of Courant numbers from il and il+1
    REAL*8, INTENT(OUT) :: ua(ilo:ihi, julo:jhi)
! Average of Courant numbers from ij and ij+1
    REAL*8, INTENT(OUT) :: va(ilo:ihi, julo:jhi)
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO)
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Grid box indices for lon & lat
    INTEGER :: il, ij
!     ----------------
!     Begin execution.
!     ----------------
    IF (.NOT.cross) THEN
      ua(:, :) = 0.0d0
      va(:, :) = 0.0d0
    ELSE
! Old
!do ij = j1p, j2p
!   do il = i1, i2-1
!
!      ua(il,ij) = 0.5d0 * (crx(il,ij) + crx(il+1,ij))
!
!      va(il,ij) = 0.5d0 * (cry(il,ij) + cry(il,ij+1))
!   end do
!   ua(i2,ij) = 0.5d0 * (crx(i2,ij) + crx(1,ij))
!   va(i2,ij) = 0.5d0 * (cry(i2,ij) + cry(i2,ij+1))
!
!end do
! BUG FIX:
      DO ij=j1p,j2p
        DO il=i1,i2-1
          ua(il, ij) = 0.5d0*(crx(il, ij)+crx(il+1, ij))
        END DO
        ua(i2, ij) = 0.5d0*(crx(i2, ij)+crx(1, ij))
      END DO
      DO ij=ju1+1,j2-1
        DO il=i1,i2
          va(il, ij) = 0.5d0*(cry(il, ij)+cry(il, ij+1))
        END DO
      END DO
!      =============================
!      =============================
      CALL DO_CROSS_TERMS_POLE_I2D2(cry, va, i1_gl, i2_gl, ju1_gl, j2_gl&
&                             , j1p, ilo, ihi, julo, jhi, i1, i2, ju1, &
&                             j2)
    END IF
  END SUBROUTINE SET_CROSS_TERMS

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Calc_Vert_Mass_Flux
!
! !DESCRIPTION: Subroutine Calc\_Vert\_Mass\_Flux calculates the vertical
!  mass flux.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE CALC_VERT_MASS_FLUX(dbk, dps_ctm, dpi, wz, i1, i2, ju1, j2&
&   , k1, k2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
    INTEGER, INTENT(IN) :: k1, k2
! Difference in bi across layer - the dSigma term
    REAL*8, INTENT(IN) :: dbk(k1:k2)
! CTM surface pressure tendency; sum over vertical of dpi
! calculated from original mass fluxes [hPa]
    REAL*8, INTENT(IN) :: dps_ctm(i1:i2, ju1:j2)
! Divergence at a grid point; used to calculate vertical motion [mb]
    REAL*8, INTENT(IN) :: dpi(i1:i2, ju1:j2, k1:k2)
!
! !OUTPUT PARAMETERS:
!
! Large scale mass flux (per time step tdt) in the vertical
! direction as diagnosed from the hydrostatic relationship [hPa]
    REAL*8, INTENT(OUT) :: wz(i1:i2, ju1:j2, k1:k2)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO)
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
    INTEGER :: ik, ij, il
!   ----------------
!   Begin execution.
!   ----------------
!   --------------------------------------------------
!   Compute vertical mass flux from mass conservation.
!   --------------------------------------------------
!---------------------------------------------------------------------
! Prior to 12/5/08:
! Need to add explicit IJ and IL loops for OpenMP parallelization
! (bmy, 12/5/08)
!
!wz(:,:,k1) =  &
!     dpi(:,:,k1) -  &
!     (dbk(k1) * dps_ctm(i1:i2,ju1:j2))
!
!wz(:,:,k2) = 0.0d0
!
!
!do ik = k1 + 1, k2 - 1
!
!   wz(:,:,ik) =  &
!        wz (:,:,ik-1) +  &
!        dpi(:,:,ik)   -  &
!        (dbk(ik) * dps_ctm(i1:i2,ju1:j2))
!
!end do
!---------------------------------------------------------------------
!$OMP PARALLEL DO       &
!$OMP DEFAULT( SHARED ) &
!$OMP PRIVATE( IJ, IL )
    DO ij=ju1,j2
      DO il=i1,i2
        wz(il, ij, k1) = dpi(il, ij, k1) - dbk(k1)*dps_ctm(il, ij)
        wz(il, ij, k2) = 0.0d0
      END DO
    END DO
!$OMP END PARALLEL DO
    DO ik=k1+1,k2-1
!$OMP PARALLEL DO       &
!$OMP DEFAULT( SHARED ) &
!$OMP PRIVATE( IJ, IL )
      DO ij=ju1,j2
        DO il=i1,i2
          wz(il, ij, ik) = wz(il, ij, ik-1) + dpi(il, ij, ik) - dbk(ik)*&
&           dps_ctm(il, ij)
        END DO
      END DO
!$OMP END PARALLEL DO
    END DO
  END SUBROUTINE CALC_VERT_MASS_FLUX

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Set_Jn_Js
!
! !DESCRIPTION: Subroutine Set\_Jn\_Js determines Jn and Js, by looking
!  where Courant number is > 1.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE SET_JN_JS(jn, js, crx, ilo, ihi, julo, jhi, ju1_gl, j2_gl, &
&   j1p, j2p, i1, i2, ju1, j2, k1, k2)
    IMPLICIT NONE
!               =============
!               =============
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
    INTEGER, INTENT(IN) :: k1, k2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Courant number in E-W direction
    REAL*8, INTENT(IN) :: crx(ilo:ihi, julo:jhi, k1:k2)
!
! !OUTPUT PARAMETERS:
!
! Northward of latitude index = jn; Courant numbers could be > 1,
! so use the flux-form semi-Lagrangian scheme
    INTEGER, INTENT(OUT) :: jn(k1:k2)
! Southward of latitude index = js; Courant numbers could be > 1,
! so use the flux-form semi-Lagrangian scheme
    INTEGER, INTENT(OUT) :: js(k1:k2)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO)
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REMARKS:
!   We cannot parallelize this subroutine because there is a CYCLE statement
!   within the outer loop.
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
    INTEGER :: il, ij, ik
    INTEGER :: jn0, js0
    INTEGER :: jst, jend
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    REAL*8 :: abs0
    REAL*8 :: abs1
!     ----------------
!     Begin execution.
!     ----------------
    js0 = (j2_gl+1)/2
    jn0 = j2_gl - js0 + 1
    IF (ju1 .LT. j1p) THEN
      jst = j1p
    ELSE
      jst = ju1
    END IF
    IF (j2 .GT. js0) THEN
      jend = js0
    ELSE
      jend = j2
    END IF
    DO 100 ik=k1,k2
      js(ik) = j1p
      DO ij=jend,jst,-1
        DO il=i1,i2
          IF (crx(il, ij, ik) .GE. 0.) THEN
            abs0 = crx(il, ij, ik)
          ELSE
            abs0 = -crx(il, ij, ik)
          END IF
          IF (abs0 .GT. 1.0d0) THEN
            js(ik) = ij
            GOTO 100
          END IF
        END DO
      END DO
 100 CONTINUE
    IF (ju1 .LT. jn0) THEN
      jst = jn0
    ELSE
      jst = ju1
    END IF
    IF (j2 .GT. j2p) THEN
      jend = j2p
    ELSE
      jend = j2
    END IF
    DO 110 ik=k1,k2
      jn(ik) = j2p
      DO ij=jst,jend
        DO il=i1,i2
          IF (crx(il, ij, ik) .GE. 0.) THEN
            abs1 = crx(il, ij, ik)
          ELSE
            abs1 = -crx(il, ij, ik)
          END IF
          IF (abs1 .GT. 1.0d0) THEN
            jn(ik) = ij
            GOTO 110
          END IF
        END DO
      END DO
 110 CONTINUE
  END SUBROUTINE SET_JN_JS

!  Differentiation of calc_advec_cross_terms in forward (tangent) mode:
!   variations   of useful results: qqu qqv
!   with respect to varying inputs: qq1
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Calc_Advec_Cross_Terms
!
! !DESCRIPTION: Subroutine Calc\_Advec\_Cross\_Terms calculates the advective
!  cross terms.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE CALC_ADVEC_CROSS_TERMS_D(jn, js, qq1, qq1d, qqu, qqud, qqv&
&   , qqvd, ua, va, j1p, j2p, i2_gl, ju1_gl, j2_gl, ilo, ihi, julo, jhi&
&   , i1, i2, ju1, j2, cross)
    IMPLICIT NONE
!   ======
!   ======
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Northward of latitude index = jn, Courant numbers could be > 1,
! so use the flux-form semi-Lagrangian scheme
    INTEGER, INTENT(IN) :: jn
! Southward of latitude index = js, Courant numbers could be > 1,
! so use the flux-form semi-Lagrangian scheme
    INTEGER, INTENT(IN) :: js
! Species concentration (mixing ratio)
    REAL*8, INTENT(IN) :: qq1(ilo:ihi, julo:jhi)
    REAL*8, INTENT(IN) :: qq1d(ilo:ihi, julo:jhi)
! Average of Courant numbers from il and il+1
    REAL*8, INTENT(IN) :: ua(ilo:ihi, julo:jhi)
! Average of Courant numbers from ij and ij+1
    REAL*8, INTENT(IN) :: va(ilo:ihi, julo:jhi)
! Logical switch: If CROSS=T then cross-terms are being computed
    LOGICAL, INTENT(IN) :: cross
!
! !OUTPUT PARAMETERS:
!
! Concentration contribution from E-W advection [mixing ratio]
    REAL*8, INTENT(OUT) :: qqu(ilo:ihi, julo:jhi)
    REAL*8, INTENT(OUT) :: qqud(ilo:ihi, julo:jhi)
! concentration contribution from N-S advection [mixing ratio]
    REAL*8, INTENT(OUT) :: qqv(ilo:ihi, julo:jhi)
    REAL*8, INTENT(OUT) :: qqvd(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO)
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel do loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
    INTEGER :: i, imp, il, ij, iu
    INTEGER :: jv, iuw, iue
    REAL*8 :: ril, rij, riu
    REAL*8 :: ru
    REAL*8 :: qtmp(-(i2/3):i2+i2/3, julo:jhi)
    REAL*8 :: qtmpd(-(i2/3):i2+i2/3, julo:jhi)
    qtmpd = 0.0_8
!     ----------------
!     Begin execution.
!     ----------------
!----------------------------------------------------------------
! Prior to 12/5/08
! Now add explicit IJ and IK loops for OpenMP parallelization
! (bmy, 12/5/08)
!do i = 1, i2
!   qtmp(i,:,:) = qq1(i,:,:)
!enddo
!
!do il = -i2/3, 0
!   qtmp(il,:,:) = qq1(i2+il,:,:)
!enddo
!
!do il = i2+1,i2+i2/3
!   qtmp(il,:,:) = qq1(il-i2,:,:)
!enddo
! IK loop was removed. (ccc, 4/1/09)
!----------------------------------------------------------------
    DO ij=julo,jhi
      DO i=1,i2
        qtmpd(i, ij) = qq1d(i, ij)
        qtmp(i, ij) = qq1(i, ij)
      END DO
      DO il=-(i2/3),0
        qtmpd(il, ij) = qq1d(i2+il, ij)
        qtmp(il, ij) = qq1(i2+il, ij)
      END DO
      DO il=i2+1,i2+i2/3
        qtmpd(il, ij) = qq1d(il-i2, ij)
        qtmp(il, ij) = qq1(il-i2, ij)
      END DO
    END DO
!   ================
    IF (.NOT.cross) THEN
!   ================
      qqud(:, :) = qq1d(:, :)
      qqu(:, :) = qq1(:, :)
      qqvd(:, :) = qq1d(:, :)
      qqv(:, :) = qq1(:, :)
!   ====
    ELSE
!   ====
      qqu(:, :) = 0.0d0
      qqv(:, :) = 0.0d0
      qqud = 0.0_8
      qqvd = 0.0_8
      DO ij=j1p,j2p
        IF (ij .LE. js .OR. ij .GE. jn) THEN
!          ----------------------------------------------------------
!          In Polar area, so need to deal with large courant numbers.
!          ----------------------------------------------------------
          DO il=i1,i2
!c?
            iu = ua(il, ij)
            riu = iu
            ru = ua(il, ij) - riu
            iu = il - iu
            IF (ua(il, ij) .GE. 0.0d0) THEN
              qqud(il, ij) = qtmpd(iu, ij) + ru*(qtmpd(iu-1, ij)-qtmpd(&
&               iu, ij))
              qqu(il, ij) = qtmp(iu, ij) + ru*(qtmp(iu-1, ij)-qtmp(iu, &
&               ij))
            ELSE
              qqud(il, ij) = qtmpd(iu, ij) + ru*(qtmpd(iu, ij)-qtmpd(iu+&
&               1, ij))
              qqu(il, ij) = qtmp(iu, ij) + ru*(qtmp(iu, ij)-qtmp(iu+1, &
&               ij))
            END IF
            qqud(il, ij) = qqud(il, ij) - qtmpd(il, ij)
            qqu(il, ij) = qqu(il, ij) - qtmp(il, ij)
          END DO
        ELSE
! js < ij < jn
!             ---------------------------
!             Do interior area (use PPM).
!             ---------------------------
          DO il=i1,i2
            ril = il
            iu = ril - ua(il, ij)
            qqud(il, ij) = ua(il, ij)*(qtmpd(iu, ij)-qtmpd(iu+1, ij))
            qqu(il, ij) = ua(il, ij)*(qtmp(iu, ij)-qtmp(iu+1, ij))
          END DO
        END IF
        DO il=i1,i2
!c?
          rij = ij
          jv = rij - va(il, ij)
          qqvd(il, ij) = va(il, ij)*(qtmpd(il, jv)-qtmpd(il, jv+1))
          qqv(il, ij) = va(il, ij)*(qtmp(il, jv)-qtmp(il, jv+1))
        END DO
      END DO
!----------------------------------------------------------------
! Prior to 12/5/08
! Now add explicit IJ and IK loops for OpenMP parallelization
! (bmy, 12/5/08)
!qqu(i1:i2,ju1:j2,:) =  &
!     qtmp(i1:i2,ju1:j2,:) + (0.5d0 * qqu(i1:i2,ju1:j2,:))
!
!qqv(i1:i2,ju1:j2,:) =  &
!     qtmp(i1:i2,ju1:j2,:) + (0.5d0 * qqv(i1:i2,ju1:j2,:))
! IK loop was removed. (ccc, 4/1/09)
!----------------------------------------------------------------
      DO ij=ju1,j2
        DO il=i1,i2
          qqud(il, ij) = qtmpd(il, ij) + 0.5d0*qqud(il, ij)
          qqu(il, ij) = qtmp(il, ij) + 0.5d0*qqu(il, ij)
          qqvd(il, ij) = qtmpd(il, ij) + 0.5d0*qqvd(il, ij)
          qqv(il, ij) = qtmp(il, ij) + 0.5d0*qqv(il, ij)
        END DO
      END DO
    END IF
  END SUBROUTINE CALC_ADVEC_CROSS_TERMS_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Calc_Advec_Cross_Terms
!
! !DESCRIPTION: Subroutine Calc\_Advec\_Cross\_Terms calculates the advective
!  cross terms.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE CALC_ADVEC_CROSS_TERMS(jn, js, qq1, qqu, qqv, ua, va, j1p, &
&   j2p, i2_gl, ju1_gl, j2_gl, ilo, ihi, julo, jhi, i1, i2, ju1, j2, &
&   cross)
    IMPLICIT NONE
!   ======
!   ======
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Northward of latitude index = jn, Courant numbers could be > 1,
! so use the flux-form semi-Lagrangian scheme
    INTEGER, INTENT(IN) :: jn
! Southward of latitude index = js, Courant numbers could be > 1,
! so use the flux-form semi-Lagrangian scheme
    INTEGER, INTENT(IN) :: js
! Species concentration (mixing ratio)
    REAL*8, INTENT(IN) :: qq1(ilo:ihi, julo:jhi)
! Average of Courant numbers from il and il+1
    REAL*8, INTENT(IN) :: ua(ilo:ihi, julo:jhi)
! Average of Courant numbers from ij and ij+1
    REAL*8, INTENT(IN) :: va(ilo:ihi, julo:jhi)
! Logical switch: If CROSS=T then cross-terms are being computed
    LOGICAL, INTENT(IN) :: cross
!
! !OUTPUT PARAMETERS:
!
! Concentration contribution from E-W advection [mixing ratio]
    REAL*8, INTENT(OUT) :: qqu(ilo:ihi, julo:jhi)
! concentration contribution from N-S advection [mixing ratio]
    REAL*8, INTENT(OUT) :: qqv(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO)
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel do loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
    INTEGER :: i, imp, il, ij, iu
    INTEGER :: jv, iuw, iue
    REAL*8 :: ril, rij, riu
    REAL*8 :: ru
    REAL*8 :: qtmp(-(i2/3):i2+i2/3, julo:jhi)
!     ----------------
!     Begin execution.
!     ----------------
!----------------------------------------------------------------
! Prior to 12/5/08
! Now add explicit IJ and IK loops for OpenMP parallelization
! (bmy, 12/5/08)
!do i = 1, i2
!   qtmp(i,:,:) = qq1(i,:,:)
!enddo
!
!do il = -i2/3, 0
!   qtmp(il,:,:) = qq1(i2+il,:,:)
!enddo
!
!do il = i2+1,i2+i2/3
!   qtmp(il,:,:) = qq1(il-i2,:,:)
!enddo
! IK loop was removed. (ccc, 4/1/09)
!----------------------------------------------------------------
    DO ij=julo,jhi
      DO i=1,i2
        qtmp(i, ij) = qq1(i, ij)
      END DO
      DO il=-(i2/3),0
        qtmp(il, ij) = qq1(i2+il, ij)
      END DO
      DO il=i2+1,i2+i2/3
        qtmp(il, ij) = qq1(il-i2, ij)
      END DO
    END DO
!   ================
    IF (.NOT.cross) THEN
!   ================
      qqu(:, :) = qq1(:, :)
      qqv(:, :) = qq1(:, :)
!   ====
    ELSE
!   ====
      qqu(:, :) = 0.0d0
      qqv(:, :) = 0.0d0
      DO ij=j1p,j2p
        IF (ij .LE. js .OR. ij .GE. jn) THEN
!          ----------------------------------------------------------
!          In Polar area, so need to deal with large courant numbers.
!          ----------------------------------------------------------
          DO il=i1,i2
!c?
            iu = ua(il, ij)
            riu = iu
            ru = ua(il, ij) - riu
            iu = il - iu
            IF (ua(il, ij) .GE. 0.0d0) THEN
              qqu(il, ij) = qtmp(iu, ij) + ru*(qtmp(iu-1, ij)-qtmp(iu, &
&               ij))
            ELSE
              qqu(il, ij) = qtmp(iu, ij) + ru*(qtmp(iu, ij)-qtmp(iu+1, &
&               ij))
            END IF
            qqu(il, ij) = qqu(il, ij) - qtmp(il, ij)
          END DO
        ELSE
! js < ij < jn
!             ---------------------------
!             Do interior area (use PPM).
!             ---------------------------
          DO il=i1,i2
            ril = il
            iu = ril - ua(il, ij)
            qqu(il, ij) = ua(il, ij)*(qtmp(iu, ij)-qtmp(iu+1, ij))
          END DO
        END IF
        DO il=i1,i2
!c?
          rij = ij
          jv = rij - va(il, ij)
          qqv(il, ij) = va(il, ij)*(qtmp(il, jv)-qtmp(il, jv+1))
        END DO
      END DO
!----------------------------------------------------------------
! Prior to 12/5/08
! Now add explicit IJ and IK loops for OpenMP parallelization
! (bmy, 12/5/08)
!qqu(i1:i2,ju1:j2,:) =  &
!     qtmp(i1:i2,ju1:j2,:) + (0.5d0 * qqu(i1:i2,ju1:j2,:))
!
!qqv(i1:i2,ju1:j2,:) =  &
!     qtmp(i1:i2,ju1:j2,:) + (0.5d0 * qqv(i1:i2,ju1:j2,:))
! IK loop was removed. (ccc, 4/1/09)
!----------------------------------------------------------------
      DO ij=ju1,j2
        DO il=i1,i2
          qqu(il, ij) = qtmp(il, ij) + 0.5d0*qqu(il, ij)
          qqv(il, ij) = qtmp(il, ij) + 0.5d0*qqv(il, ij)
        END DO
      END DO
    END IF
  END SUBROUTINE CALC_ADVEC_CROSS_TERMS

!  Differentiation of qckxyz in forward (tangent) mode:
!   variations   of useful results: dq1
!   with respect to varying inputs: dq1
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Qckxyz
!
! !DESCRIPTION: Subroutine Qckxyz routine checks for "filling".
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE QCKXYZ_D(dq1, dq1d, j1p, j2p, ju1_gl, j2_gl, ilo, ihi, julo&
&   , jhi, i1, i2, ju1, j2, k1, k2)
    IMPLICIT NONE
! We don't want to replace zero values by 1e-30. (ccc, 11/20/08)
!!     =======================================
!    where ((dq1(i1:i2,j1p:j2p,:) < 1.0d-30))  &
!         dq1(i1:i2,j1p:j2p,:) = 1.0d-30
!!     =======================================
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max latitude (J) indices
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
    INTEGER, INTENT(IN) :: k1, k2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
!
! !INPUT/OUTPUT PARAMETERS:
!
! Species density [hPa]
    REAL*8, INTENT(INOUT) :: dq1(ilo:ihi, julo:jhi, k1:k2)
    REAL*8, INTENT(INOUT) :: dq1d(ilo:ihi, julo:jhi, k1:k2)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO)
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !DEFINED PARAMETERS:
!
    LOGICAL, PARAMETER :: fill_diag=.false.
!
! LOCAL VARIABLES:
!
    INTEGER :: il, ij, ik
    INTEGER :: ip
    INTEGER :: k1p1, k2m1
    REAL*8 :: dup, qup
    REAL*8 :: dupd, qupd
    REAL*8 :: qly
    REAL*8 :: qlyd
    REAL*8 :: sum
    INTRINSIC MIN
!     ----------------
!     Begin execution.
!     ----------------
    ip = 0
!     ----------
!     Top layer.
!     ----------
    k1p1 = k1 + 1
!$OMP PARALLEL DO          &
!$OMP DEFAULT( SHARED )    &
!$OMP PRIVATE( IJ, IL, IP )
    DO ij=j1p,j2p
      DO il=i1,i2
        IF (dq1(il, ij, k1) .LT. 0.0d0) THEN
          ip = ip + 1
          dq1d(il, ij, k1p1) = dq1d(il, ij, k1p1) + dq1d(il, ij, k1)
          dq1(il, ij, k1p1) = dq1(il, ij, k1p1) + dq1(il, ij, k1)
          dq1d(il, ij, k1) = 0.0_8
          dq1(il, ij, k1) = 0.0d0
        END IF
      END DO
    END DO
!$OMP END PARALLEL DO
    DO ik=k1+1,k2-1
!$OMP PARALLEL DO                         &
!$OMP DEFAULT( SHARED )                   &
!$OMP PRIVATE( IJ, IL, IP, QUP, QLY, DUP )
      DO ij=j1p,j2p
        DO il=i1,i2
          IF (dq1(il, ij, ik) .LT. 0.0d0) THEN
            ip = ip + 1
!             -----------
!             From above.
!             -----------
            qupd = dq1d(il, ij, ik-1)
            qup = dq1(il, ij, ik-1)
            qlyd = -dq1d(il, ij, ik)
            qly = -dq1(il, ij, ik)
            IF (qly .GT. qup) THEN
              dupd = qupd
              dup = qup
            ELSE
              dupd = qlyd
              dup = qly
            END IF
            dq1d(il, ij, ik-1) = qupd - dupd
            dq1(il, ij, ik-1) = qup - dup
            dq1d(il, ij, ik) = dupd - qlyd
            dq1(il, ij, ik) = dup - qly
!             -----------
!             From below.
!             -----------
            dq1d(il, ij, ik+1) = dq1d(il, ij, ik+1) + dq1d(il, ij, ik)
            dq1(il, ij, ik+1) = dq1(il, ij, ik+1) + dq1(il, ij, ik)
            dq1d(il, ij, ik) = 0.0_8
            dq1(il, ij, ik) = 0.0d0
          END IF
        END DO
      END DO
!$OMP END PARALLEL DO
    END DO
!     -------------
!     Bottom layer.
!     -------------
    sum = 0.0d0
    k2m1 = k2 - 1
! NOTE: Sum seems to be not used in the loop below!
!$OMP PARALLEL DO                          &
!$OMP DEFAULT( SHARED )                    &
!$OMP PRIVATE( IJ, IL, IP, QUP, QLY, DUP ) &
!$OMP REDUCTION( +:SUM )
    DO ij=j1p,j2p
      DO il=i1,i2
        IF (dq1(il, ij, k2) .LT. 0.0d0) THEN
          ip = ip + 1
!           -----------
!           From above.
!           -----------
          qupd = dq1d(il, ij, k2m1)
          qup = dq1(il, ij, k2m1)
          qlyd = -dq1d(il, ij, k2)
          qly = -dq1(il, ij, k2)
          IF (qly .GT. qup) THEN
            dupd = qupd
            dup = qup
          ELSE
            dupd = qlyd
            dup = qly
          END IF
          dq1d(il, ij, k2m1) = qupd - dupd
          dq1(il, ij, k2m1) = qup - dup
!           -------------------------
!           From "below" the surface.
!           -------------------------
          sum = sum + qly - dup
          dq1d(il, ij, k2) = 0.0_8
          dq1(il, ij, k2) = 0.0d0
        END IF
      END DO
    END DO
!$OMP END PARALLEL DO
  END SUBROUTINE QCKXYZ_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Qckxyz
!
! !DESCRIPTION: Subroutine Qckxyz routine checks for "filling".
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE QCKXYZ(dq1, j1p, j2p, ju1_gl, j2_gl, ilo, ihi, julo, jhi, &
&   i1, i2, ju1, j2, k1, k2)
    IMPLICIT NONE
! We don't want to replace zero values by 1e-30. (ccc, 11/20/08)
!!     =======================================
!    where ((dq1(i1:i2,j1p:j2p,:) < 1.0d-30))  &
!         dq1(i1:i2,j1p:j2p,:) = 1.0d-30
!!     =======================================
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max latitude (J) indices
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
    INTEGER, INTENT(IN) :: k1, k2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
!
! !INPUT/OUTPUT PARAMETERS:
!
! Species density [hPa]
    REAL*8, INTENT(INOUT) :: dq1(ilo:ihi, julo:jhi, k1:k2)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO)
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !DEFINED PARAMETERS:
!
    LOGICAL, PARAMETER :: fill_diag=.false.
!
! LOCAL VARIABLES:
!
    INTEGER :: il, ij, ik
    INTEGER :: ip
    INTEGER :: k1p1, k2m1
    REAL*8 :: dup, qup
    REAL*8 :: qly
    REAL*8 :: sum
    INTRINSIC MIN
!     ----------------
!     Begin execution.
!     ----------------
    ip = 0
!     ----------
!     Top layer.
!     ----------
    k1p1 = k1 + 1
!$OMP PARALLEL DO          &
!$OMP DEFAULT( SHARED )    &
!$OMP PRIVATE( IJ, IL, IP )
    DO ij=j1p,j2p
      DO il=i1,i2
        IF (dq1(il, ij, k1) .LT. 0.0d0) THEN
          ip = ip + 1
          dq1(il, ij, k1p1) = dq1(il, ij, k1p1) + dq1(il, ij, k1)
          dq1(il, ij, k1) = 0.0d0
        END IF
      END DO
    END DO
!$OMP END PARALLEL DO
    DO ik=k1+1,k2-1
!$OMP PARALLEL DO                         &
!$OMP DEFAULT( SHARED )                   &
!$OMP PRIVATE( IJ, IL, IP, QUP, QLY, DUP )
      DO ij=j1p,j2p
        DO il=i1,i2
          IF (dq1(il, ij, ik) .LT. 0.0d0) THEN
            ip = ip + 1
!             -----------
!             From above.
!             -----------
            qup = dq1(il, ij, ik-1)
            qly = -dq1(il, ij, ik)
            IF (qly .GT. qup) THEN
              dup = qup
            ELSE
              dup = qly
            END IF
            dq1(il, ij, ik-1) = qup - dup
            dq1(il, ij, ik) = dup - qly
!             -----------
!             From below.
!             -----------
            dq1(il, ij, ik+1) = dq1(il, ij, ik+1) + dq1(il, ij, ik)
            dq1(il, ij, ik) = 0.0d0
          END IF
        END DO
      END DO
!$OMP END PARALLEL DO
    END DO
!     -------------
!     Bottom layer.
!     -------------
    sum = 0.0d0
    k2m1 = k2 - 1
! NOTE: Sum seems to be not used in the loop below!
!$OMP PARALLEL DO                          &
!$OMP DEFAULT( SHARED )                    &
!$OMP PRIVATE( IJ, IL, IP, QUP, QLY, DUP ) &
!$OMP REDUCTION( +:SUM )
    DO ij=j1p,j2p
      DO il=i1,i2
        IF (dq1(il, ij, k2) .LT. 0.0d0) THEN
          ip = ip + 1
!           -----------
!           From above.
!           -----------
          qup = dq1(il, ij, k2m1)
          qly = -dq1(il, ij, k2)
          IF (qly .GT. qup) THEN
            dup = qup
          ELSE
            dup = qly
          END IF
          dq1(il, ij, k2m1) = qup - dup
!           -------------------------
!           From "below" the surface.
!           -------------------------
          sum = sum + qly - dup
          dq1(il, ij, k2) = 0.0d0
        END IF
      END DO
    END DO
!$OMP END PARALLEL DO
  END SUBROUTINE QCKXYZ

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Set_Lmts
!
! !DESCRIPTION: Subroutine Set\_Lmts sets ILMT, JLMT, KLMT.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE SET_LMTS(ilmt, jlmt, klmt, i2_gl, j2_gl, iord, jord, kord)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global maximum longitude (I) and longitude (J) indices
    INTEGER, INTENT(IN) :: i2_gl, j2_gl
! Flags to denote E-W, N-S, and vertical transport schemes
! (See REMARKS section of routine Tpcore_FvDas for more info)
    INTEGER, INTENT(IN) :: iord, jord, kord
!
! !OUTPUT PARAMETERS:
!
! Controls various options in E-W advection
    INTEGER, INTENT(OUT) :: ilmt
! Controls various options in N-S advection
    INTEGER, INTENT(OUT) :: jlmt
! Controls various options in vertical advection
    INTEGER, INTENT(OUT) :: klmt
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO)
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
    INTEGER :: j2_glm1
    INTRINSIC MAX
!     ----------------
!     Begin execution.
!     ----------------
    j2_glm1 = j2_gl - 1
!c?
    IF (iord .LE. 0) THEN
      IF (i2_gl .GE. 144) THEN
        ilmt = 0
      ELSE IF (i2_gl .GE. 72) THEN
        ilmt = 1
      ELSE
        ilmt = 2
      END IF
    ELSE
      ilmt = iord - 3
    END IF
!c?
    IF (jord .LE. 0) THEN
      IF (j2_glm1 .GE. 90) THEN
        jlmt = 0
      ELSE IF (j2_glm1 .GE. 45) THEN
        jlmt = 1
      ELSE
        jlmt = 2
      END IF
    ELSE
      jlmt = jord - 3
    END IF
    IF (kord - 3 .LT. 0) THEN
      klmt = 0
    ELSE
      klmt = kord - 3
    END IF
  END SUBROUTINE SET_LMTS

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Set_Press_Terms
!
! !DESCRIPTION: Subroutine Set\_Press\_Terms sets the pressure terms:
!  DELP1, DELPM, PU.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE SET_PRESS_TERMS(dap, dbk, pres1, pres2, delp1, delpm, pu, &
&   ju1_gl, j2_gl, ilo, ihi, julo, jhi, j1p, j2p, i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max latitude (J) indices
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Pressure difference across layer from (ai * pt) term [hPa]
    REAL*8, INTENT(IN) :: dap
! Difference in bi across layer - the dSigma term
    REAL*8, INTENT(IN) :: dbk
! Surface pressure at t1 [hPa]
    REAL*8, INTENT(IN) :: pres1(ilo:ihi, julo:jhi)
! Surface pressure at t1+tdt [hPa]
    REAL*8, INTENT(IN) :: pres2(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Pressure thickness, the pseudo-density in a
! hydrostatic system at t1 [hPa]
    REAL*8, INTENT(OUT) :: delp1(ilo:ihi, julo:jhi)
! Pressure thickness, the pseudo-density in a
! hydrostatic system at t1+tdt/2 (approximate) [hPa]
    REAL*8, INTENT(OUT) :: delpm(ilo:ihi, julo:jhi)
! Pressure at edges in "u" [hPa]
    REAL*8, INTENT(OUT) :: pu(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO)
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
    INTEGER :: il, ij
!   ----------------
!   Begin execution.
!   ----------------
    delp1(:, :) = dap + dbk*pres1(:, :)
    delpm(:, :) = dap + dbk*0.5d0*(pres1(:, :)+pres2(:, :))
    DO ij=j1p,j2p
      pu(1, ij) = 0.5d0*(delpm(1, ij)+delpm(i2, ij))
      DO il=i1+1,i2
        pu(il, ij) = 0.5d0*(delpm(il, ij)+delpm(il-1, ij))
      END DO
    END DO
  END SUBROUTINE SET_PRESS_TERMS

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Calc_Courant
!
! !DESCRIPTION: Subroutine Calc\_Courant calculates courant numbers from
!  the horizontal mass fluxes.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE CALC_COURANT(cose, delpm, pu, xmass, ymass, crx, cry, j1p, &
&   j2p, ju1_gl, j2_gl, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max latitude (J) indices
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Cosine of grid box edges
    REAL*8, INTENT(IN) :: cose(ju1_gl:j2_gl)
! Pressure thickness, the pseudo-density in a hydrostatic system
! at t1+tdt/2 (approximate) (mb)
    REAL*8, INTENT(IN) :: delpm(ilo:ihi, julo:jhi)
! pressure at edges in "u"  (mb)
    REAL*8, INTENT(IN) :: pu(ilo:ihi, julo:jhi)
! horizontal mass flux in E-W and N-S directions [hPa]
    REAL*8, INTENT(IN) :: xmass(ilo:ihi, julo:jhi)
    REAL*8, INTENT(IN) :: ymass(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Courant numbers in E-W and N-S directions
    REAL*8, INTENT(OUT) :: crx(ilo:ihi, julo:jhi)
    REAL*8, INTENT(OUT) :: cry(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO)
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
    INTEGER :: ij
!   ----------------
!   Begin execution.
!   ----------------
    crx(:, :) = 0.0d0
    cry(:, :) = 0.0d0
!-----------------------------------------------------------------------------
! Prior to 12/4/08:
! We need to add an outer IK loop for OpenMP parallelization.
! Preserve original code here! (bmy, 12/4/08)
!!   -----------------------------------
!!   Calculate E-W horizontal mass flux.
!!   -----------------------------------
!
!    do ij = j1p, j2p
!
!       crx(:,ij,:) =  &
!            xmass(:,ij,:) / pu(:,ij,:)
!
!    end do
!
!
!!   -----------------------------------
!!   Calculate N-S horizontal mass flux.
!!   -----------------------------------
!
!    do ij = j1p, j2p+1
!
!       cry(:,ij,:) =  &
!            ymass(:,ij,:) /  &
!            ((0.5d0 * cose(ij)) *  &
!            (delpm(:,ij,:) + delpm(:,ij-1,:)))
!
!    end do
! The IK loop was moved outside the subroutine. (ccc, 4/1/09)
!-----------------------------------------------------------------------------
!      ---------------------------------------------
!      Calculate E-W and N-S horizontal mass fluxes.
!      ---------------------------------------------
    DO ij=j1p,j2p
      crx(:, ij) = xmass(:, ij)/pu(:, ij)
      cry(:, ij) = ymass(:, ij)/(0.5d0*cose(ij)*(delpm(:, ij)+delpm(:, &
&       ij-1)))
    END DO
    cry(:, j2p+1) = ymass(:, j2p+1)/(0.5d0*cose(j2p+1)*(delpm(:, j2p+1)+&
&     delpm(:, j2p)))
  END SUBROUTINE CALC_COURANT

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Calc_Divergence
!
! !DESCRIPTION: Subroutine Calc\_Divergence calculates the divergence.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE CALC_DIVERGENCE(do_reduction, geofac_pc, geofac, dpi, xmass&
&   , ymass, j1p, j2p, i1_gl, i2_gl, ju1_gl, j2_gl, ilo, ihi, julo, jhi&
&   , i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Set to F if called on Master or T if called by Slaves
! (NOTE: This is only for MPI parallelization, for OPENMP it should be F)
    LOGICAL, INTENT(IN) :: do_reduction
! Special geometrical factor (geofac) for Polar cap
    REAL*8, INTENT(IN) :: geofac_pc
! Geometrical factor for meridional advection; geofac uses correct
! spherical geometry, and replaces acosp as the meridional geometrical
! factor in TPCORE
    REAL*8, INTENT(IN) :: geofac(ju1_gl:j2_gl)
! Horizontal mass flux in E/W and N/S directions [hPa]
    REAL*8, INTENT(IN) :: xmass(ilo:ihi, julo:jhi)
    REAL*8, INTENT(IN) :: ymass(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Divergence at a grid point; used to calculate vertical motion [hPa]
    REAL*8, INTENT(OUT) :: dpi(i1:i2, ju1:j2)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
    INTEGER :: il, ij
!   ----------------
!   Begin execution.
!   ----------------
!------------------------------------------------------------------------------
! Prior to 12/4/08:
! We need to add an outer IK loop for OpenMP parallelization.
! Preserve original code here! (bmy, 12/4/08)
!   -------------------------
!   Calculate N-S divergence.
!!   -------------------------
!
!    do ij = j1p, j2p
!
!       dpi(:,ij,:) =  &
!            (ymass(:,ij,:) - ymass(:,ij+1,:)) *  &
!            geofac(ij)
!
!    end do
!
!
!!     -------------------------
!!     Calculate E-W divergence.
!!     -------------------------
!
!    do ij = j1p, j2p
!       do il = i1, i2-1
!
!          dpi(il,ij,:) =  &
!               dpi(il,ij,:) +  &
!               xmass(il,ij,:) - xmass(il+1,ij,:)
!
!       end do
!       dpi(i2,ij,:) =  &
!            dpi(i2,ij,:) +  &
!            xmass(i2,ij,:) - xmass(1,ij,:)
!    end do
! IK loop was moved outside the subroutine (ccc, 4/1/09)
!------------------------------------------------------------------------------
!      -------------------------
!      Calculate N-S divergence.
!      -------------------------
    DO ij=j1p,j2p
      dpi(:, ij) = (ymass(:, ij)-ymass(:, ij+1))*geofac(ij)
!      -------------------------
!      Calculate E-W divergence.
!      -------------------------
      DO il=i1,i2-1
        dpi(il, ij) = dpi(il, ij) + xmass(il, ij) - xmass(il+1, ij)
      END DO
      dpi(i2, ij) = dpi(i2, ij) + xmass(i2, ij) - xmass(1, ij)
    END DO
!   ===========================
!   ===========================
    CALL DO_DIVERGENCE_POLE_SUM(do_reduction, geofac_pc, dpi, ymass, &
&                         i1_gl, i2_gl, j1p, j2p, ju1_gl, j2_gl, ilo, &
&                         ihi, julo, jhi, i1, i2, ju1, j2)
    IF (j1p .NE. ju1_gl + 1) THEN
!       --------------------------------------------
!       Polar cap enlarged:  copy dpi to polar ring.
!       --------------------------------------------
!--------------------------------------------------------------
! Prior to 12/4/08:
! We need to add an outer IK loop for OpenMP parallelization
! Preserve original code here! (bmy, 12/4/08)
!dpi(:,ju1+1,:) = dpi(:,ju1,:)
!dpi(:,j2-1,:)  = dpi(:,j2,:)
! IK loop was moved outside the subroutine (ccc, 4/1/09)
!--------------------------------------------------------------
      dpi(:, ju1+1) = dpi(:, ju1)
      dpi(:, j2-1) = dpi(:, j2)
    END IF
  END SUBROUTINE CALC_DIVERGENCE

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Do_Divergence_Pole_Sum
!
! !DESCRIPTION: Subroutine Do\_Divergence\_Pole\_Sum sets the divergence
!  at the Poles.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE DO_DIVERGENCE_POLE_SUM(do_reduction, geofac_pc, dpi, ymass&
&   , i1_gl, i2_gl, j1p, j2p, ju1_gl, j2_gl, ilo, ihi, julo, jhi, i1, i2&
&   , ju1, j2)
    IMPLICIT NONE
!   ======
!   ======
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Set to T if called on Master or F if called by slaves
! NOTE: This seems not to be used here....)
    LOGICAL, INTENT(IN) :: do_reduction
! Special geometrical factor (geofac) for Polar cap
    REAL*8, INTENT(IN) :: geofac_pc
! Horizontal mass flux in N-S direction [hPa]
    REAL*8, INTENT(IN) :: ymass(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Divergence at a grid point; used to calculate vertical motion [hPa]
    REAL*8, INTENT(OUT) :: dpi(i1:i2, ju1:j2)
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent. Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
    INTEGER :: il
    REAL*8 :: ri2
    REAL*8 :: mean_np
    REAL*8 :: mean_sp
    REAL*8 :: sumnp
    REAL*8 :: sumsp
!   ----------------
!   Begin execution.
!   ----------------
    ri2 = i2_gl
!   ==================
    IF (ju1 .EQ. ju1_gl) THEN
!   ==================
      sumsp = 0.0d0
      DO il=i1,i2
        sumsp = sumsp + ymass(il, j1p)
      END DO
      mean_sp = -(sumsp/ri2*geofac_pc)
      DO il=i1,i2
        dpi(il, ju1) = mean_sp
      END DO
    END IF
!   ======
!   ======
!   ================
    IF (j2 .EQ. j2_gl) THEN
!   ================
      sumnp = 0.0d0
      DO il=i1,i2
        sumnp = sumnp + ymass(il, j2p+1)
      END DO
      mean_np = sumnp/ri2*geofac_pc
      DO il=i1,i2
        dpi(il, j2) = mean_np
      END DO
    END IF
  END SUBROUTINE DO_DIVERGENCE_POLE_SUM

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Do_Cross_Terms_Pole_I2d2
!
! !DESCRIPTION: Subroutine Do\_Cross\_Terms\_Pole\_I2d2 sets "va" at the Poles.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE DO_CROSS_TERMS_POLE_I2D2(cry, va, i1_gl, i2_gl, ju1_gl, &
&   j2_gl, j1p, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!      ======
!      ======
!   ======
!   ======
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edge of the South polar cap
! J1P=JU1_GL+1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Courant number in N-S direction
    REAL*8, INTENT(IN) :: cry(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Average of Courant numbers from ij and ij+1
    REAL*8, INTENT(OUT) :: va(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
    INTEGER :: i2d2
    INTEGER :: il
!   ----------------
!   Begin execution.
!   ----------------
    i2d2 = i2_gl/2
!   ====================
    IF (j1p .EQ. ju1_gl + 1) THEN
!   ====================
!------------------------------------------------------------------------------
! Prior to 12/4/08:
! We need to add outer IK loops OpenMP parallelization.
! Preserve original code here! (bmy, 12/4/08)
!!       ---------------------------------------------
!!       Polar Cap NOT Enlarged:
!!       Get cross terms for N-S horizontal advection.
!!       ---------------------------------------------
!
!!      ==================
!       if (ju1 == ju1_gl) then
!!      ==================
!
!          do il = i1, i2d2
!
!             va(il,ju1,:) =  &
!                  0.5d0 * (cry(il,ju1+1,:) - cry(il+i2d2,ju1+1,:))
!
!             va(il+i2d2,ju1,:) = -va(il,ju1,:)
!
!          end do
!
!!      ======
!       end if
!!      ======
!
!
!!      ================
!       if (j2 == j2_gl) then
!!      ================
!
!          do il = i1, i2d2
!
!             va(il,j2,:) =  &
!                  0.5d0 * (cry(il,j2,:) - cry(il+i2d2,j2-1,:))
!
!             va(il+i2d2,j2,:) = -va(il,j2,:)
!
!          end do
!
!!      ======
!       end if
!!      ======
!
!!   ======
!    end if
!!   ======
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!------------------------------------------------------------------------------
!      ---------------------------------------------
!      Polar Cap NOT Enlarged:
!      Get cross terms for N-S horizontal advection.
!      ---------------------------------------------
!      ==================
      IF (ju1 .EQ. ju1_gl) THEN
!      ==================
        DO il=i1,i2d2
          va(il, ju1) = 0.5d0*(cry(il, ju1+1)-cry(il+i2d2, ju1+1))
          va(il+i2d2, ju1) = -va(il, ju1)
        END DO
      END IF
!      ======
!      ======
!      ================
      IF (j2 .EQ. j2_gl) THEN
!      ================
        DO il=i1,i2d2
          va(il, j2) = 0.5d0*(cry(il, j2)-cry(il+i2d2, j2-1))
          va(il+i2d2, j2) = -va(il, j2)
        END DO
      END IF
    END IF
  END SUBROUTINE DO_CROSS_TERMS_POLE_I2D2

!  Differentiation of xadv_dao2 in forward (tangent) mode:
!   variations   of useful results: adx
!   with respect to varying inputs: qqv
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Xadv_Dao2
!
! !DESCRIPTION: Subroutine Xadv\_Dao2 is the advective form E-W operator for
!  computing the adx (E-W) cross term.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE XADV_DAO2_D(iad, jn, js, adx, adxd, qqv, qqvd, ua, ilo, ihi&
&   , julo, jhi, ju1_gl, j2_gl, j1p, j2p, i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max latitude (J) indices
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! if iad = 1, use 1st order accurate scheme;
! if iad = 2, use 2nd order accurate scheme
    INTEGER, INTENT(IN) :: iad
! Northward of latitude index = jn, Courant numbers could be > 1,
! so use the flux-form semi-Lagrangian scheme
    INTEGER, INTENT(IN) :: jn
! southward of latitude index = js, Courant numbers could be > 1,
! so use the flux-form semi-Lagrangian scheme
    INTEGER, INTENT(IN) :: js
! Concentration contribution from N-S advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqv(ilo:ihi, julo:jhi)
    REAL*8, INTENT(IN) :: qqvd(ilo:ihi, julo:jhi)
! Average of Courant numbers from il and il+1
    REAL*8, INTENT(IN) :: ua(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Cross term due to E-W advection [mixing ratio]
    REAL*8, INTENT(OUT) :: adx(ilo:ihi, julo:jhi)
    REAL*8, INTENT(OUT) :: adxd(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il, ij, iu
    INTEGER :: imp, iue, iuw
    REAL*8 :: a1, b1, c1
    REAL*8 :: a1d, b1d, c1d
    REAL*8 :: rdiff
    REAL*8 :: rdiffd
    REAL*8 :: ril, riu
    REAL*8 :: ru
! Arrays
    REAL*8 :: qtmp(-(i2/3):i2+i2/3, julo:jhi)
    REAL*8 :: qtmpd(-(i2/3):i2+i2/3, julo:jhi)
    INTRINSIC NINT
!     ----------------
!     Begin execution.
!     ----------------
! Zero output array
    adx = 0d0
    qtmpd = 0.0_8
!-----------------------------------------------------------------------
! Prior to 12/5/08:
! We need to add outer IJ and IK loops for OpenMP parallelization.
! Preserve original code here. (bmy, 12/5/08)
!do il=1,i2
!   qtmp(il,:,:) = qqv(il,:,:)
!enddo
!
!do il=-i2/3,0
!   qtmp(il,:,:) = qqv(i2+il,:,:)
!enddo
!
!do il=i2+1,i2+i2/3
!   qtmp(il,:,:) = qqv(il-i2,:,:)
!enddo
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!-----------------------------------------------------------------------
    DO ij=julo,jhi
      DO il=1,i2
        qtmpd(il, ij) = qqvd(il, ij)
        qtmp(il, ij) = qqv(il, ij)
      END DO
      DO il=-(i2/3),0
        qtmpd(il, ij) = qqvd(i2+il, ij)
        qtmp(il, ij) = qqv(i2+il, ij)
      END DO
      DO il=i2+1,i2+i2/3
        qtmpd(il, ij) = qqvd(il-i2, ij)
        qtmp(il, ij) = qqv(il-i2, ij)
      END DO
    END DO
!   =============
    IF (iad .EQ. 1) THEN
      adxd = 0.0_8
!   =============
!       ----------
!       1st order.
!       ----------
      DO ij=j1p,j2p
        IF (ij .LE. js .OR. ij .GE. jn) THEN
!             --------------
!             In Polar area.
!             --------------
          DO il=i1,i2
            iu = ua(il, ij)
            riu = iu
            ru = ua(il, ij) - riu
            iu = il - iu
            IF (ua(il, ij) .GE. 0.0d0) THEN
              rdiffd = qtmpd(iu-1, ij) - qtmpd(iu, ij)
              rdiff = qtmp(iu-1, ij) - qtmp(iu, ij)
            ELSE
              rdiffd = qtmpd(iu, ij) - qtmpd(iu+1, ij)
              rdiff = qtmp(iu, ij) - qtmp(iu+1, ij)
            END IF
            adxd(il, ij) = qtmpd(iu, ij) - qtmpd(il, ij) + ru*rdiffd
            adx(il, ij) = qtmp(iu, ij) - qtmp(il, ij) + ru*rdiff
          END DO
        ELSE
! js < ij < jn
!             ----------------
!             Eulerian upwind.
!             ----------------
          DO il=i1,i2
            ril = il
            iu = ril - ua(il, ij)
            adxd(il, ij) = ua(il, ij)*(qtmpd(iu, ij)-qtmpd(iu+1, ij))
            adx(il, ij) = ua(il, ij)*(qtmp(iu, ij)-qtmp(iu+1, ij))
          END DO
        END IF
      END DO
    ELSE IF (iad .EQ. 2) THEN
!   ==================
      adxd = 0.0_8
!   ==================
      DO ij=j1p,j2p
        IF (ij .LE. js .OR. ij .GE. jn) THEN
!             --------------
!             In Polar area.
!             --------------
          DO il=i1,i2
            iu = NINT(ua(il, ij))
            riu = iu
            ru = riu - ua(il, ij)
            iu = il - iu
            a1d = 0.5d0*(qtmpd(iu+1, ij)+qtmpd(iu-1, ij)) - qtmpd(iu, ij&
&             )
            a1 = 0.5d0*(qtmp(iu+1, ij)+qtmp(iu-1, ij)) - qtmp(iu, ij)
            b1d = 0.5d0*(qtmpd(iu+1, ij)-qtmpd(iu-1, ij))
            b1 = 0.5d0*(qtmp(iu+1, ij)-qtmp(iu-1, ij))
            c1d = qtmpd(iu, ij) - qtmpd(il, ij)
            c1 = qtmp(iu, ij) - qtmp(il, ij)
            adxd(il, ij) = ru*(ru*a1d+b1d) + c1d
            adx(il, ij) = ru*(a1*ru+b1) + c1
          END DO
        ELSE
! js < ij < jn
!             ----------------
!             Eulerian upwind.
!             ----------------
          DO il=i1,i2
            iu = NINT(ua(il, ij))
            riu = iu
            ru = riu - ua(il, ij)
            iu = il - iu
            a1d = 0.5d0*(qtmpd(iu+1, ij)+qtmpd(iu-1, ij)) - qtmpd(iu, ij&
&             )
            a1 = 0.5d0*(qtmp(iu+1, ij)+qtmp(iu-1, ij)) - qtmp(iu, ij)
            b1d = 0.5d0*(qtmpd(iu+1, ij)-qtmpd(iu-1, ij))
            b1 = 0.5d0*(qtmp(iu+1, ij)-qtmp(iu-1, ij))
            c1d = qtmpd(iu, ij) - qtmpd(il, ij)
            c1 = qtmp(iu, ij) - qtmp(il, ij)
            adxd(il, ij) = ru*(ru*a1d+b1d) + c1d
            adx(il, ij) = ru*(a1*ru+b1) + c1
          END DO
        END IF
      END DO
    ELSE
      adxd = 0.0_8
    END IF
!   ======
!   ======
    IF (ju1 .EQ. ju1_gl) THEN
!---------------------------------------------------------------
! Prior to 12/4/08:
! We need to rewrite the DO loop below for OpenMP.
! Preserve original code here! (bmy, 12/4/08)
!adx(i1:i2,ju1,:) = 0.0d0
!
!if (j1p /= ju1_gl+1) then
!
!   adx(i1:i2,ju1+1,:) = 0.0d0
!
!end if
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!---------------------------------------------------------------
      adxd(i1:i2, ju1) = 0.0_8
      adx(i1:i2, ju1) = 0.0d0
      IF (j1p .NE. ju1_gl + 1) THEN
        adxd(i1:i2, ju1+1) = 0.0_8
        adx(i1:i2, ju1+1) = 0.0d0
      END IF
    END IF
    IF (j2 .EQ. j2_gl) THEN
!---------------------------------------------------------------
! Prior to 12/4/08:
! We need to rewrite the DO loop below for OpenMP.
! Preserve original code here! (bmy, 12/4/08)
!adx(i1:i2,j2,:) = 0.0d0
!
!if (j1p /= ju1_gl+1) then
!
!   adx(i1:i2,j2-1,:) = 0.0d0
!
!end if
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!---------------------------------------------------------------
      adxd(i1:i2, j2) = 0.0_8
      adx(i1:i2, j2) = 0.0d0
      IF (j1p .NE. ju1_gl + 1) THEN
        adxd(i1:i2, j2-1) = 0.0_8
        adx(i1:i2, j2-1) = 0.0d0
      END IF
    END IF
  END SUBROUTINE XADV_DAO2_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Xadv_Dao2
!
! !DESCRIPTION: Subroutine Xadv\_Dao2 is the advective form E-W operator for
!  computing the adx (E-W) cross term.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE XADV_DAO2(iad, jn, js, adx, qqv, ua, ilo, ihi, julo, jhi, &
&   ju1_gl, j2_gl, j1p, j2p, i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max latitude (J) indices
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! if iad = 1, use 1st order accurate scheme;
! if iad = 2, use 2nd order accurate scheme
    INTEGER, INTENT(IN) :: iad
! Northward of latitude index = jn, Courant numbers could be > 1,
! so use the flux-form semi-Lagrangian scheme
    INTEGER, INTENT(IN) :: jn
! southward of latitude index = js, Courant numbers could be > 1,
! so use the flux-form semi-Lagrangian scheme
    INTEGER, INTENT(IN) :: js
! Concentration contribution from N-S advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqv(ilo:ihi, julo:jhi)
! Average of Courant numbers from il and il+1
    REAL*8, INTENT(IN) :: ua(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Cross term due to E-W advection [mixing ratio]
    REAL*8, INTENT(OUT) :: adx(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il, ij, iu
    INTEGER :: imp, iue, iuw
    REAL*8 :: a1, b1, c1
    REAL*8 :: rdiff
    REAL*8 :: ril, riu
    REAL*8 :: ru
! Arrays
    REAL*8 :: qtmp(-(i2/3):i2+i2/3, julo:jhi)
    INTRINSIC NINT
!     ----------------
!     Begin execution.
!     ----------------
! Zero output array
    adx = 0d0
!-----------------------------------------------------------------------
! Prior to 12/5/08:
! We need to add outer IJ and IK loops for OpenMP parallelization.
! Preserve original code here. (bmy, 12/5/08)
!do il=1,i2
!   qtmp(il,:,:) = qqv(il,:,:)
!enddo
!
!do il=-i2/3,0
!   qtmp(il,:,:) = qqv(i2+il,:,:)
!enddo
!
!do il=i2+1,i2+i2/3
!   qtmp(il,:,:) = qqv(il-i2,:,:)
!enddo
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!-----------------------------------------------------------------------
    DO ij=julo,jhi
      DO il=1,i2
        qtmp(il, ij) = qqv(il, ij)
      END DO
      DO il=-(i2/3),0
        qtmp(il, ij) = qqv(i2+il, ij)
      END DO
      DO il=i2+1,i2+i2/3
        qtmp(il, ij) = qqv(il-i2, ij)
      END DO
    END DO
!   =============
    IF (iad .EQ. 1) THEN
!   =============
!       ----------
!       1st order.
!       ----------
      DO ij=j1p,j2p
        IF (ij .LE. js .OR. ij .GE. jn) THEN
!             --------------
!             In Polar area.
!             --------------
          DO il=i1,i2
            iu = ua(il, ij)
            riu = iu
            ru = ua(il, ij) - riu
            iu = il - iu
            IF (ua(il, ij) .GE. 0.0d0) THEN
              rdiff = qtmp(iu-1, ij) - qtmp(iu, ij)
            ELSE
              rdiff = qtmp(iu, ij) - qtmp(iu+1, ij)
            END IF
            adx(il, ij) = qtmp(iu, ij) - qtmp(il, ij) + ru*rdiff
          END DO
        ELSE
! js < ij < jn
!             ----------------
!             Eulerian upwind.
!             ----------------
          DO il=i1,i2
            ril = il
            iu = ril - ua(il, ij)
            adx(il, ij) = ua(il, ij)*(qtmp(iu, ij)-qtmp(iu+1, ij))
          END DO
        END IF
      END DO
    ELSE IF (iad .EQ. 2) THEN
!   ==================
!   ==================
      DO ij=j1p,j2p
        IF (ij .LE. js .OR. ij .GE. jn) THEN
!             --------------
!             In Polar area.
!             --------------
          DO il=i1,i2
            iu = NINT(ua(il, ij))
            riu = iu
            ru = riu - ua(il, ij)
            iu = il - iu
            a1 = 0.5d0*(qtmp(iu+1, ij)+qtmp(iu-1, ij)) - qtmp(iu, ij)
            b1 = 0.5d0*(qtmp(iu+1, ij)-qtmp(iu-1, ij))
            c1 = qtmp(iu, ij) - qtmp(il, ij)
            adx(il, ij) = ru*(a1*ru+b1) + c1
          END DO
        ELSE
! js < ij < jn
!             ----------------
!             Eulerian upwind.
!             ----------------
          DO il=i1,i2
            iu = NINT(ua(il, ij))
            riu = iu
            ru = riu - ua(il, ij)
            iu = il - iu
            a1 = 0.5d0*(qtmp(iu+1, ij)+qtmp(iu-1, ij)) - qtmp(iu, ij)
            b1 = 0.5d0*(qtmp(iu+1, ij)-qtmp(iu-1, ij))
            c1 = qtmp(iu, ij) - qtmp(il, ij)
            adx(il, ij) = ru*(a1*ru+b1) + c1
          END DO
        END IF
      END DO
    END IF
!   ======
!   ======
    IF (ju1 .EQ. ju1_gl) THEN
!---------------------------------------------------------------
! Prior to 12/4/08:
! We need to rewrite the DO loop below for OpenMP.
! Preserve original code here! (bmy, 12/4/08)
!adx(i1:i2,ju1,:) = 0.0d0
!
!if (j1p /= ju1_gl+1) then
!
!   adx(i1:i2,ju1+1,:) = 0.0d0
!
!end if
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!---------------------------------------------------------------
      adx(i1:i2, ju1) = 0.0d0
      IF (j1p .NE. ju1_gl + 1) adx(i1:i2, ju1+1) = 0.0d0
    END IF
    IF (j2 .EQ. j2_gl) THEN
!---------------------------------------------------------------
! Prior to 12/4/08:
! We need to rewrite the DO loop below for OpenMP.
! Preserve original code here! (bmy, 12/4/08)
!adx(i1:i2,j2,:) = 0.0d0
!
!if (j1p /= ju1_gl+1) then
!
!   adx(i1:i2,j2-1,:) = 0.0d0
!
!end if
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!---------------------------------------------------------------
      adx(i1:i2, j2) = 0.0d0
      IF (j1p .NE. ju1_gl + 1) adx(i1:i2, j2-1) = 0.0d0
    END IF
  END SUBROUTINE XADV_DAO2

!  Differentiation of yadv_dao2 in forward (tangent) mode:
!   variations   of useful results: ady
!   with respect to varying inputs: qqu
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Yadv_Dao2
!
! !DESCRIPTION: Subroutine Yadv\_Dao2 is the advective form N-S operator
!  for computing the ady (N-S) cross term.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE YADV_DAO2_D(iad, ady, adyd, qqu, qqud, va, i1_gl, i2_gl, &
&   ju1_gl, j2_gl, j1p, j2p, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! If iad = 1, use 1st order accurate scheme;
! If iad = 2, use 2nd order accurate scheme
    INTEGER, INTENT(IN) :: iad
! Concentration contribution from E-W advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqu(ilo:ihi, julo:jhi)
    REAL*8, INTENT(IN) :: qqud(ilo:ihi, julo:jhi)
! Average of Courant numbers from ij and ij+1
    REAL*8, INTENT(IN) :: va(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Cross term due to N-S advection (mixing ratio)
    REAL*8, INTENT(OUT) :: ady(ilo:ihi, julo:jhi)
    REAL*8, INTENT(OUT) :: adyd(ilo:ihi, julo:jhi)
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il, ij
    INTEGER :: jv
    REAL*8 :: a1, b1, c1
    REAL*8 :: a1d, b1d, c1d
    REAL*8 :: rij, rjv
    REAL*8 :: rv
! Arrays
! We may need a small ghost zone depending
! on the polar cap used
    REAL*8 :: qquwk(ilo:ihi, julo-2:jhi+2)
    REAL*8 :: qquwkd(ilo:ihi, julo-2:jhi+2)
    INTRINSIC NINT
!     ----------------
!     Begin execution.
!     ----------------
! Zero output array
    ady = 0d0
    qquwkd = 0.0_8
! Make work array
    DO ij=julo,jhi
      qquwkd(:, ij) = qqud(:, ij)
      qquwk(:, ij) = qqu(:, ij)
    END DO
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! This routine creates a ghost zone in latitude in case of
! not enlarged polar cap
! (ccc, 11/20/08)
!   ======================
!   ======================
    CALL DO_YADV_POLE_I2D2_D(qqu, qqud, qquwk, qquwkd, i1_gl, i2_gl, &
&                      ju1_gl, j2_gl, j1p, ilo, ihi, julo, jhi, i1, i2, &
&                      ju1, j2)
!   =============
    IF (iad .EQ. 1) THEN
      adyd = 0.0_8
!   =============
!       ----------
!       1st order.
!       ----------
      DO ij=j1p-1,j2p+1
        DO il=i1,i2
!c?
          rij = ij
          jv = rij - va(il, ij)
          adyd(il, ij) = va(il, ij)*(qquwkd(il, jv)-qquwkd(il, jv+1))
          ady(il, ij) = va(il, ij)*(qquwk(il, jv)-qquwk(il, jv+1))
        END DO
      END DO
    ELSE IF (iad .EQ. 2) THEN
!   ==================
      adyd = 0.0_8
!   ==================
      DO ij=j1p-1,j2p+1
        DO il=i1,i2
!c?
          jv = NINT(va(il, ij))
          rjv = jv
          rv = rjv - va(il, ij)
          jv = ij - jv
          a1d = 0.5d0*(qquwkd(il, jv+1)+qquwkd(il, jv-1)) - qquwkd(il, &
&           jv)
          a1 = 0.5d0*(qquwk(il, jv+1)+qquwk(il, jv-1)) - qquwk(il, jv)
          b1d = 0.5d0*(qquwkd(il, jv+1)-qquwkd(il, jv-1))
          b1 = 0.5d0*(qquwk(il, jv+1)-qquwk(il, jv-1))
          c1d = qquwkd(il, jv) - qquwkd(il, ij)
          c1 = qquwk(il, jv) - qquwk(il, ij)
          adyd(il, ij) = rv*(rv*a1d+b1d) + c1d
          ady(il, ij) = rv*(a1*rv+b1) + c1
        END DO
      END DO
    ELSE
      adyd = 0.0_8
    END IF
!   =====================
!   =====================
    CALL DO_YADV_POLE_SUM_D(ady, adyd, i1_gl, i2_gl, ju1_gl, j2_gl, j1p&
&                     , ilo, ihi, julo, jhi, i1, i2, ju1, j2)
  END SUBROUTINE YADV_DAO2_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Yadv_Dao2
!
! !DESCRIPTION: Subroutine Yadv\_Dao2 is the advective form N-S operator
!  for computing the ady (N-S) cross term.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE YADV_DAO2(iad, ady, qqu, va, i1_gl, i2_gl, ju1_gl, j2_gl, &
&   j1p, j2p, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! If iad = 1, use 1st order accurate scheme;
! If iad = 2, use 2nd order accurate scheme
    INTEGER, INTENT(IN) :: iad
! Concentration contribution from E-W advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqu(ilo:ihi, julo:jhi)
! Average of Courant numbers from ij and ij+1
    REAL*8, INTENT(IN) :: va(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Cross term due to N-S advection (mixing ratio)
    REAL*8, INTENT(OUT) :: ady(ilo:ihi, julo:jhi)
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il, ij
    INTEGER :: jv
    REAL*8 :: a1, b1, c1
    REAL*8 :: rij, rjv
    REAL*8 :: rv
! Arrays
! We may need a small ghost zone depending
! on the polar cap used
    REAL*8 :: qquwk(ilo:ihi, julo-2:jhi+2)
    INTRINSIC NINT
!     ----------------
!     Begin execution.
!     ----------------
! Zero output array
    ady = 0d0
! Make work array
    DO ij=julo,jhi
      qquwk(:, ij) = qqu(:, ij)
    END DO
!%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! This routine creates a ghost zone in latitude in case of
! not enlarged polar cap
! (ccc, 11/20/08)
!   ======================
!   ======================
    CALL DO_YADV_POLE_I2D2(qqu, qquwk, i1_gl, i2_gl, ju1_gl, j2_gl, j1p&
&                    , ilo, ihi, julo, jhi, i1, i2, ju1, j2)
!   =============
    IF (iad .EQ. 1) THEN
!   =============
!       ----------
!       1st order.
!       ----------
      DO ij=j1p-1,j2p+1
        DO il=i1,i2
!c?
          rij = ij
          jv = rij - va(il, ij)
          ady(il, ij) = va(il, ij)*(qquwk(il, jv)-qquwk(il, jv+1))
        END DO
      END DO
    ELSE IF (iad .EQ. 2) THEN
!   ==================
!   ==================
      DO ij=j1p-1,j2p+1
        DO il=i1,i2
!c?
          jv = NINT(va(il, ij))
          rjv = jv
          rv = rjv - va(il, ij)
          jv = ij - jv
          a1 = 0.5d0*(qquwk(il, jv+1)+qquwk(il, jv-1)) - qquwk(il, jv)
          b1 = 0.5d0*(qquwk(il, jv+1)-qquwk(il, jv-1))
          c1 = qquwk(il, jv) - qquwk(il, ij)
          ady(il, ij) = rv*(a1*rv+b1) + c1
        END DO
      END DO
    END IF
!   =====================
!   =====================
    CALL DO_YADV_POLE_SUM(ady, i1_gl, i2_gl, ju1_gl, j2_gl, j1p, ilo, &
&                   ihi, julo, jhi, i1, i2, ju1, j2)
  END SUBROUTINE YADV_DAO2

!  Differentiation of do_yadv_pole_i2d2 in forward (tangent) mode:
!   variations   of useful results: qquwk
!   with respect to varying inputs: qqu qquwk
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Do_Yadv_Pole_I2d2
!
! !DESCRIPTION: Subroutine Do\_Yadv\_Pole\_I2d2 sets "qquwk" at the Poles.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE DO_YADV_POLE_I2D2_D(qqu, qqud, qquwk, qquwkd, i1_gl, i2_gl&
&   , ju1_gl, j2_gl, j1p, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!      ======
!      ======
!   ======
!   ======
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the South polar cap
! J1P=JU1_GL+1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! concentration contribution from E-W advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqu(ilo:ihi, julo:jhi)
    REAL*8, INTENT(IN) :: qqud(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! qqu working array [mixing ratio]
    REAL*8, INTENT(OUT) :: qquwk(ilo:ihi, julo-2:jhi+2)
    REAL*8, INTENT(OUT) :: qquwkd(ilo:ihi, julo-2:jhi+2)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: i2d2
    INTEGER :: il, ij
    INTEGER :: inb
!   ----------------
!   Begin execution.
!   ----------------
    i2d2 = i2_gl/2
!   ====================
    IF (j1p .EQ. ju1_gl + 1) THEN
!   ====================
!      -----------------------
!      Polar Cap NOT Enlarged.
!      -----------------------
!      ==================
      IF (ju1 .EQ. ju1_gl) THEN
!      ==================
!-----------------------------------------------------------------
! Prior to 12/4/08:
! We need to add an outer IK loop for OpenMP parallelization
! Preserve original code here (bmy, 12/4/08)
!do il = i1, i2d2
!   do inb = 1, 2
!
!      qquwk(il,     ju1-inb,:) = qqu(il+i2d2,ju1+inb,:)
!      qquwk(il+i2d2,ju1-inb,:) = qqu(il,     ju1+inb,:)
!
!   end do
!end do
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!-----------------------------------------------------------------
        DO il=i1,i2d2
          DO inb=1,2
            qquwkd(il, ju1-inb) = qqud(il+i2d2, ju1+inb)
            qquwk(il, ju1-inb) = qqu(il+i2d2, ju1+inb)
            qquwkd(il+i2d2, ju1-inb) = qqud(il, ju1+inb)
            qquwk(il+i2d2, ju1-inb) = qqu(il, ju1+inb)
          END DO
        END DO
      END IF
!      ======
!      ======
!      ================
      IF (j2 .EQ. j2_gl) THEN
!      ================
!-----------------------------------------------------------------
! Prior to 12/4/08:
! We need to add an outer IK loop for OpenMP parallelization
! Preserve original code here (bmy, 12/4/08)
!do il = i1, i2d2
!   do inb = 1, 2
!
!      qquwk(il,     j2+inb,:) = qqu(il+i2d2,j2-inb,:)
!      qquwk(il+i2d2,j2+inb,:) = qqu(il,     j2-inb,:)
!
!   end do
!end do
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!-----------------------------------------------------------------
        DO il=i1,i2d2
          DO inb=1,2
            qquwkd(il, j2+inb) = qqud(il+i2d2, j2-inb)
            qquwk(il, j2+inb) = qqu(il+i2d2, j2-inb)
            qquwkd(il+i2d2, j2+inb) = qqud(il, j2-inb)
            qquwk(il+i2d2, j2+inb) = qqu(il, j2-inb)
          END DO
        END DO
      END IF
    END IF
  END SUBROUTINE DO_YADV_POLE_I2D2_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Do_Yadv_Pole_I2d2
!
! !DESCRIPTION: Subroutine Do\_Yadv\_Pole\_I2d2 sets "qquwk" at the Poles.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE DO_YADV_POLE_I2D2(qqu, qquwk, i1_gl, i2_gl, ju1_gl, j2_gl, &
&   j1p, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!      ======
!      ======
!   ======
!   ======
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the South polar cap
! J1P=JU1_GL+1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! concentration contribution from E-W advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqu(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! qqu working array [mixing ratio]
    REAL*8, INTENT(OUT) :: qquwk(ilo:ihi, julo-2:jhi+2)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: i2d2
    INTEGER :: il, ij
    INTEGER :: inb
!   ----------------
!   Begin execution.
!   ----------------
    i2d2 = i2_gl/2
!   ====================
    IF (j1p .EQ. ju1_gl + 1) THEN
!   ====================
!      -----------------------
!      Polar Cap NOT Enlarged.
!      -----------------------
!      ==================
      IF (ju1 .EQ. ju1_gl) THEN
!      ==================
!-----------------------------------------------------------------
! Prior to 12/4/08:
! We need to add an outer IK loop for OpenMP parallelization
! Preserve original code here (bmy, 12/4/08)
!do il = i1, i2d2
!   do inb = 1, 2
!
!      qquwk(il,     ju1-inb,:) = qqu(il+i2d2,ju1+inb,:)
!      qquwk(il+i2d2,ju1-inb,:) = qqu(il,     ju1+inb,:)
!
!   end do
!end do
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!-----------------------------------------------------------------
        DO il=i1,i2d2
          DO inb=1,2
            qquwk(il, ju1-inb) = qqu(il+i2d2, ju1+inb)
            qquwk(il+i2d2, ju1-inb) = qqu(il, ju1+inb)
          END DO
        END DO
      END IF
!      ======
!      ======
!      ================
      IF (j2 .EQ. j2_gl) THEN
!      ================
!-----------------------------------------------------------------
! Prior to 12/4/08:
! We need to add an outer IK loop for OpenMP parallelization
! Preserve original code here (bmy, 12/4/08)
!do il = i1, i2d2
!   do inb = 1, 2
!
!      qquwk(il,     j2+inb,:) = qqu(il+i2d2,j2-inb,:)
!      qquwk(il+i2d2,j2+inb,:) = qqu(il,     j2-inb,:)
!
!   end do
!end do
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!-----------------------------------------------------------------
        DO il=i1,i2d2
          DO inb=1,2
            qquwk(il, j2+inb) = qqu(il+i2d2, j2-inb)
            qquwk(il+i2d2, j2+inb) = qqu(il, j2-inb)
          END DO
        END DO
      END IF
    END IF
  END SUBROUTINE DO_YADV_POLE_I2D2

!  Differentiation of do_yadv_pole_sum in forward (tangent) mode:
!   variations   of useful results: ady
!   with respect to varying inputs: ady
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Do_Yadv_Pole_Sum
!
! !DESCRIPTION: Subroutine Do\_Yadv\_Pole\_Sum sets the cross term due to
!  N-S advection at the Poles.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE DO_YADV_POLE_SUM_D(ady, adyd, i1_gl, i2_gl, ju1_gl, j2_gl, &
&   j1p, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude index at the edge of the South polar cap
! J1P=JU1_GL+1; for a polar cap of 1 latitude band
! J1P=JU1_GL+2; for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
!
! !OUTPUT PARAMETERS:
!
! Cross term due to N-S advection (mixing ratio)
    REAL*8, INTENT(INOUT) :: ady(ilo:ihi, julo:jhi)
    REAL*8, INTENT(INOUT) :: adyd(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.  Also make a logical
!                               to test if we are using an extended polar cap.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il
! Arrays
    REAL*8 :: sumnp
    REAL*8 :: sumnpd
    REAL*8 :: sumsp
    REAL*8 :: sumspd
! Add
    LOGICAL :: is_ext_polar_cap
! ----------------
! Begin execution.
! ----------------
! Test if we are using extended polar caps (i.e. the S pole and next N
! latitude and N. Pole and next S latitude).  Do this outside the loops.
! (bmy, 12/11/08)
    is_ext_polar_cap = j1p .EQ. ju1_gl + 2
! ------------
!  South Pole
! ------------
    sumsp = 0.0d0
    sumnp = 0.0d0
!------------------------------
! Prior to 12/11/08:
!if (j1p /= ju1_gl+1) then
!------------------------------
    IF (is_ext_polar_cap) THEN
      sumnpd = 0.0_8
      sumspd = 0.0_8
! For a 2-latitude polar cap (S. Pole + next Northward latitude)
      DO il=i1,i2
        sumspd = sumspd + adyd(il, ju1+1)
        sumsp = sumsp + ady(il, ju1+1)
        sumnpd = sumnpd + adyd(il, j2-1)
        sumnp = sumnp + ady(il, j2-1)
      END DO
    ELSE
      sumnpd = 0.0_8
      sumspd = 0.0_8
! For a 1-latitude polar cap (S. Pole only)
      DO il=i1,i2
        sumspd = sumspd + adyd(il, ju1)
        sumsp = sumsp + ady(il, ju1)
        sumnpd = sumnpd + adyd(il, j2)
        sumnp = sumnp + ady(il, j2)
      END DO
    END IF
    sumspd = sumspd/i2_gl
    sumsp = sumsp/i2_gl
    sumnpd = sumnpd/i2_gl
    sumnp = sumnp/i2_gl
!------------------------------
! Prior to 12/11/08:
!if (j1p /= ju1_gl+1) then
!------------------------------
    IF (is_ext_polar_cap) THEN
! For a 2-latitude polar cap (S. Pole + next Northward latitude)
      DO il=i1,i2
        adyd(il, ju1+1) = sumspd
        ady(il, ju1+1) = sumsp
        adyd(il, ju1) = sumspd
        ady(il, ju1) = sumsp
        adyd(il, j2-1) = sumnpd
        ady(il, j2-1) = sumnp
        adyd(il, j2) = sumnpd
        ady(il, j2) = sumnp
      END DO
    ELSE
! For a 1-latitude polar cap (S. Pole only)
      DO il=i1,i2
        adyd(il, ju1) = sumspd
        ady(il, ju1) = sumsp
        adyd(il, j2) = sumnpd
        ady(il, j2) = sumnp
      END DO
    END IF
  END SUBROUTINE DO_YADV_POLE_SUM_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Do_Yadv_Pole_Sum
!
! !DESCRIPTION: Subroutine Do\_Yadv\_Pole\_Sum sets the cross term due to
!  N-S advection at the Poles.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE DO_YADV_POLE_SUM(ady, i1_gl, i2_gl, ju1_gl, j2_gl, j1p, ilo&
&   , ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude index at the edge of the South polar cap
! J1P=JU1_GL+1; for a polar cap of 1 latitude band
! J1P=JU1_GL+2; for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
!
! !OUTPUT PARAMETERS:
!
! Cross term due to N-S advection (mixing ratio)
    REAL*8, INTENT(INOUT) :: ady(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.  Also make a logical
!                               to test if we are using an extended polar cap.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il
! Arrays
    REAL*8 :: sumnp
    REAL*8 :: sumsp
! Add
    LOGICAL :: is_ext_polar_cap
! ----------------
! Begin execution.
! ----------------
! Test if we are using extended polar caps (i.e. the S pole and next N
! latitude and N. Pole and next S latitude).  Do this outside the loops.
! (bmy, 12/11/08)
    is_ext_polar_cap = j1p .EQ. ju1_gl + 2
! ------------
!  South Pole
! ------------
    sumsp = 0.0d0
    sumnp = 0.0d0
!------------------------------
! Prior to 12/11/08:
!if (j1p /= ju1_gl+1) then
!------------------------------
    IF (is_ext_polar_cap) THEN
! For a 2-latitude polar cap (S. Pole + next Northward latitude)
      DO il=i1,i2
        sumsp = sumsp + ady(il, ju1+1)
        sumnp = sumnp + ady(il, j2-1)
      END DO
    ELSE
! For a 1-latitude polar cap (S. Pole only)
      DO il=i1,i2
        sumsp = sumsp + ady(il, ju1)
        sumnp = sumnp + ady(il, j2)
      END DO
    END IF
    sumsp = sumsp/i2_gl
    sumnp = sumnp/i2_gl
!------------------------------
! Prior to 12/11/08:
!if (j1p /= ju1_gl+1) then
!------------------------------
    IF (is_ext_polar_cap) THEN
! For a 2-latitude polar cap (S. Pole + next Northward latitude)
      DO il=i1,i2
        ady(il, ju1+1) = sumsp
        ady(il, ju1) = sumsp
        ady(il, j2-1) = sumnp
        ady(il, j2) = sumnp
      END DO
    ELSE
! For a 1-latitude polar cap (S. Pole only)
      DO il=i1,i2
        ady(il, ju1) = sumsp
        ady(il, j2) = sumnp
      END DO
    END IF
  END SUBROUTINE DO_YADV_POLE_SUM

!  Differentiation of xtp in forward (tangent) mode:
!   variations   of useful results: dq1
!   with respect to varying inputs: qqv dq1
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Xtp
!
! !DESCRIPTION: Subroutine Xtp does horizontal advection in the E-W direction.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE XTP_D(ilmt, jn, js, pu, crx, dq1, dq1d, qqv, qqvd, xmass, &
&   fx, fxd, j1p, j2p, i2_gl, ju1_gl, j2_gl, ilo, ihi, julo, jhi, i1, i2&
&   , ju1, j2, iord)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Controls various options in E-W advection
    INTEGER, INTENT(IN) :: ilmt
! Northward of latitude index = jn, Courant numbers could be > 1,
! so use the flux-form semi-Lagrangian scheme
    INTEGER, INTENT(IN) :: jn
! Southward of latitude index = js, Courant numbers could be > 1,
! so use the flux-form semi-Lagrangian scheme
    INTEGER, INTENT(IN) :: js
! Option for E-W transport scheme.  See module header for more info.
    INTEGER, INTENT(IN) :: iord
! pressure at edges in "u" [hPa]
    REAL*8, INTENT(IN) :: pu(ilo:ihi, julo:jhi)
! Courant number in E-W direction
    REAL*8, INTENT(IN) :: crx(ilo:ihi, julo:jhi)
! Horizontal mass flux in E-W direction [hPa]
    REAL*8, INTENT(IN) :: xmass(ilo:ihi, julo:jhi)
!
! !INPUT/OUTPUT PARAMETERS:
!
! Species density [hPa]
    REAL*8, INTENT(INOUT) :: dq1(ilo:ihi, julo:jhi)
    REAL*8, INTENT(INOUT) :: dq1d(ilo:ihi, julo:jhi)
! Concentration contribution from N-S advection [mixing ratio]
    REAL*8, INTENT(INOUT) :: qqv(ilo:ihi, julo:jhi)
    REAL*8, INTENT(INOUT) :: qqvd(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! E-W flux [mixing ratio]
    REAL*8, INTENT(OUT) :: fx(ilo:ihi, julo:jhi)
    REAL*8, INTENT(OUT) :: fxd(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il, ij, ic
    INTEGER :: iu, ix, iuw, iue, imp
    INTEGER :: jvan
    REAL*8 :: rc
    REAL*8 :: ric, ril
! Arrays
    INTEGER :: isav(i1:i2)
    REAL*8 :: dcx(-(i2/3):i2+i2/3, julo:jhi)
    REAL*8 :: dcxd(-(i2/3):i2+i2/3, julo:jhi)
    REAL*8 :: qtmp(-(i2/3):i2+i2/3, julo:jhi)
    REAL*8 :: qtmpd(-(i2/3):i2+i2/3, julo:jhi)
    INTRINSIC MAX
    INTRINSIC SIGN
    REAL*8 :: temp
!     ----------------
!     Begin execution.
!     ----------------
    dcx(:, :) = 0.0d0
    fx(:, :) = 0.0d0
    imp = i2 + 1
    qtmpd = 0.0_8
! NOTE: these loops do not parallelize well (bmy, 12/5/08)
! Populate qtmp
    DO il=i1,i2
      qtmpd(il, :) = qqvd(il, :)
      qtmp(il, :) = qqv(il, :)
    END DO
    DO il=-(i2/3),0
      qtmpd(il, :) = qqvd(i2+il, :)
      qtmp(il, :) = qqv(i2+il, :)
    END DO
    DO il=i2+1,i2+i2/3
      qtmpd(il, :) = qqvd(il-i2, :)
      qtmp(il, :) = qqv(il-i2, :)
    END DO
    IF (iord .NE. 1) THEN
      qtmpd(i1-1, :) = qqvd(i2, :)
      qtmp(i1-1, :) = qqv(i2, :)
      qtmpd(i1-2, :) = qqvd(i2-1, :)
      qtmp(i1-2, :) = qqv(i2-1, :)
      qtmpd(i2+1, :) = qqvd(i1, :)
      qtmp(i2+1, :) = qqv(i1, :)
      qtmpd(i2+2, :) = qqvd(i1+1, :)
      qtmp(i2+2, :) = qqv(i1+1, :)
!      ==========
!      ==========
      CALL XMIST_D(dcx, dcxd, qtmp, qtmpd, j1p, j2p, i2_gl, ju1_gl, &
&            j2_gl, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    ELSE
      dcxd = 0.0_8
    END IF
    IF (1 .LT. j2_gl/18) THEN
      jvan = j2_gl/18
    ELSE
      jvan = 1
    END IF
    fxd = 0.0_8
!   ==============
    DO ij=j1p,j2p
!      =================
!         ======================================
      IF (ij .GT. js .AND. ij .LT. jn) THEN
!         ======================================
!           ------------------------------------------------------
!           Do horizontal Eulerian advection in the E-W direction.
!           ------------------------------------------------------
        IF ((iord .EQ. 1 .OR. ij .EQ. j1p) .OR. ij .EQ. j2p) THEN
          DO il=i1,i2
            ril = il
            iu = ril - crx(il, ij)
            fxd(il, ij) = qtmpd(iu, ij)
            fx(il, ij) = qtmp(iu, ij)
          END DO
        ELSE IF ((iord .EQ. 2 .OR. ij .LE. j1p + jvan) .OR. ij .GE. j2p &
&           - jvan) THEN
          DO il=i1,i2
            ril = il
            iu = ril - crx(il, ij)
            temp = SIGN(1.0d0, crx(il, ij)) - crx(il, ij)
            fxd(il, ij) = qtmpd(iu, ij) + temp*dcxd(iu, ij)
            fx(il, ij) = qtmp(iu, ij) + temp*dcx(iu, ij)
          END DO
        ELSE
!                  ==========
          CALL FXPPM_D(ij, ilmt, crx, dcx, dcxd, fx, fxd, qtmp, qtmpd, -&
&                (i2/3), i2 + i2/3, julo, jhi, i1, i2)
!  qtmp (inout) - can be updated
!                  ==========
        END IF
!---------------------------------------------------------------
! Prior to 12/5/08:
! We need to write this as an explicit loop over IL
! to facilitate OpenMP parallelization.  Preserve original
! code here. (bmy, 12/5/08)
!fx(i1:i2,ij,ik) = fx(i1:i2,ij,ik) * xmass(i1:i2,ij,ik)
!---------------------------------------------------------------
        DO il=i1,i2
          fxd(il, ij) = xmass(il, ij)*fxd(il, ij)
          fx(il, ij) = fx(il, ij)*xmass(il, ij)
        END DO
      ELSE
!         ====
!         ====
!           ------------------------------------------------------------
!           Do horizontal Conservative (flux-form) Semi-Lagrangian
!           advection in the E-W direction (van Leer at high latitudes).
!           ------------------------------------------------------------
        IF ((iord .EQ. 1 .OR. ij .EQ. j1p) .OR. ij .EQ. j2p) THEN
          DO il=i1,i2
            ic = crx(il, ij)
            isav(il) = il - ic
            ril = il
            iu = ril - crx(il, ij)
            ric = ic
            rc = crx(il, ij) - ric
            fxd(il, ij) = rc*qtmpd(iu, ij)
            fx(il, ij) = rc*qtmp(iu, ij)
          END DO
        ELSE
          DO il=i1,i2
            ic = crx(il, ij)
            isav(il) = il - ic
            ril = il
            iu = ril - crx(il, ij)
            ric = ic
            rc = crx(il, ij) - ric
            temp = SIGN(1.0d0, rc) - rc
            fxd(il, ij) = rc*(qtmpd(iu, ij)+temp*dcxd(iu, ij))
            fx(il, ij) = rc*(qtmp(iu, ij)+temp*dcx(iu, ij))
          END DO
        END IF
        DO il=i1,i2
          IF (crx(il, ij) .GT. 1.0d0) THEN
            DO ix=isav(il),il-1
              fxd(il, ij) = fxd(il, ij) + qtmpd(ix, ij)
              fx(il, ij) = fx(il, ij) + qtmp(ix, ij)
            END DO
          ELSE IF (crx(il, ij) .LT. -1.0d0) THEN
            DO ix=il,isav(il)-1
              fxd(il, ij) = fxd(il, ij) - qtmpd(ix, ij)
              fx(il, ij) = fx(il, ij) - qtmp(ix, ij)
            END DO
          END IF
        END DO
!---------------------------------------------------------------
! Prior to 12/5/08:
! We need to write this as an explicit loop over IL
! to facilitate OpenMP parallelization.  Preserve original
! code here. (bmy, 12/5/08)
!fx(i1:i2,ij,ik) = pu(i1:i2,ij,ik) * fx(i1:i2,ij,ik)
!---------------------------------------------------------------
        DO il=i1,i2
          fxd(il, ij) = pu(il, ij)*fxd(il, ij)
          fx(il, ij) = pu(il, ij)*fx(il, ij)
        END DO
      END IF
    END DO
!         ======
!         ======
!      ======
!   ======
! NOTE: This loop does not parallelize well (bmy, 12/5/08)
    DO ij=j1p,j2p
      DO il=i1,i2-1
        dq1d(il, ij) = dq1d(il, ij) + fxd(il, ij) - fxd(il+1, ij)
        dq1(il, ij) = dq1(il, ij) + (fx(il, ij)-fx(il+1, ij))
      END DO
      dq1d(i2, ij) = dq1d(i2, ij) + fxd(i2, ij) - fxd(i1, ij)
      dq1(i2, ij) = dq1(i2, ij) + (fx(i2, ij)-fx(i1, ij))
    END DO
  END SUBROUTINE XTP_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Xtp
!
! !DESCRIPTION: Subroutine Xtp does horizontal advection in the E-W direction.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE XTP(ilmt, jn, js, pu, crx, dq1, qqv, xmass, fx, j1p, j2p, &
&   i2_gl, ju1_gl, j2_gl, ilo, ihi, julo, jhi, i1, i2, ju1, j2, iord)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Controls various options in E-W advection
    INTEGER, INTENT(IN) :: ilmt
! Northward of latitude index = jn, Courant numbers could be > 1,
! so use the flux-form semi-Lagrangian scheme
    INTEGER, INTENT(IN) :: jn
! Southward of latitude index = js, Courant numbers could be > 1,
! so use the flux-form semi-Lagrangian scheme
    INTEGER, INTENT(IN) :: js
! Option for E-W transport scheme.  See module header for more info.
    INTEGER, INTENT(IN) :: iord
! pressure at edges in "u" [hPa]
    REAL*8, INTENT(IN) :: pu(ilo:ihi, julo:jhi)
! Courant number in E-W direction
    REAL*8, INTENT(IN) :: crx(ilo:ihi, julo:jhi)
! Horizontal mass flux in E-W direction [hPa]
    REAL*8, INTENT(IN) :: xmass(ilo:ihi, julo:jhi)
!
! !INPUT/OUTPUT PARAMETERS:
!
! Species density [hPa]
    REAL*8, INTENT(INOUT) :: dq1(ilo:ihi, julo:jhi)
! Concentration contribution from N-S advection [mixing ratio]
    REAL*8, INTENT(INOUT) :: qqv(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! E-W flux [mixing ratio]
    REAL*8, INTENT(OUT) :: fx(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il, ij, ic
    INTEGER :: iu, ix, iuw, iue, imp
    INTEGER :: jvan
    REAL*8 :: rc
    REAL*8 :: ric, ril
! Arrays
    INTEGER :: isav(i1:i2)
    REAL*8 :: dcx(-(i2/3):i2+i2/3, julo:jhi)
    REAL*8 :: qtmp(-(i2/3):i2+i2/3, julo:jhi)
    INTRINSIC MAX
    INTRINSIC SIGN
!     ----------------
!     Begin execution.
!     ----------------
    dcx(:, :) = 0.0d0
    fx(:, :) = 0.0d0
    imp = i2 + 1
! NOTE: these loops do not parallelize well (bmy, 12/5/08)
! Populate qtmp
    DO il=i1,i2
      qtmp(il, :) = qqv(il, :)
    END DO
    DO il=-(i2/3),0
      qtmp(il, :) = qqv(i2+il, :)
    END DO
    DO il=i2+1,i2+i2/3
      qtmp(il, :) = qqv(il-i2, :)
    END DO
    IF (iord .NE. 1) THEN
      qtmp(i1-1, :) = qqv(i2, :)
      qtmp(i1-2, :) = qqv(i2-1, :)
      qtmp(i2+1, :) = qqv(i1, :)
      qtmp(i2+2, :) = qqv(i1+1, :)
!      ==========
!      ==========
      CALL XMIST(dcx, qtmp, j1p, j2p, i2_gl, ju1_gl, j2_gl, ilo, ihi, &
&          julo, jhi, i1, i2, ju1, j2)
    END IF
    IF (1 .LT. j2_gl/18) THEN
      jvan = j2_gl/18
    ELSE
      jvan = 1
    END IF
!   ==============
    DO ij=j1p,j2p
!      =================
!         ======================================
      IF (ij .GT. js .AND. ij .LT. jn) THEN
!         ======================================
!           ------------------------------------------------------
!           Do horizontal Eulerian advection in the E-W direction.
!           ------------------------------------------------------
        IF ((iord .EQ. 1 .OR. ij .EQ. j1p) .OR. ij .EQ. j2p) THEN
          DO il=i1,i2
            ril = il
            iu = ril - crx(il, ij)
            fx(il, ij) = qtmp(iu, ij)
          END DO
        ELSE IF ((iord .EQ. 2 .OR. ij .LE. j1p + jvan) .OR. ij .GE. j2p &
&           - jvan) THEN
          DO il=i1,i2
            ril = il
            iu = ril - crx(il, ij)
            fx(il, ij) = qtmp(iu, ij) + dcx(iu, ij)*(SIGN(1.0d0, crx(il&
&             , ij))-crx(il, ij))
          END DO
        ELSE
!                  ==========
          CALL FXPPM(ij, ilmt, crx, dcx, fx, qtmp, -(i2/3), i2 + i2/3, &
&              julo, jhi, i1, i2)
!  qtmp (inout) - can be updated
!                  ==========
        END IF
!---------------------------------------------------------------
! Prior to 12/5/08:
! We need to write this as an explicit loop over IL
! to facilitate OpenMP parallelization.  Preserve original
! code here. (bmy, 12/5/08)
!fx(i1:i2,ij,ik) = fx(i1:i2,ij,ik) * xmass(i1:i2,ij,ik)
!---------------------------------------------------------------
        DO il=i1,i2
          fx(il, ij) = fx(il, ij)*xmass(il, ij)
        END DO
      ELSE
!         ====
!         ====
!           ------------------------------------------------------------
!           Do horizontal Conservative (flux-form) Semi-Lagrangian
!           advection in the E-W direction (van Leer at high latitudes).
!           ------------------------------------------------------------
        IF ((iord .EQ. 1 .OR. ij .EQ. j1p) .OR. ij .EQ. j2p) THEN
          DO il=i1,i2
            ic = crx(il, ij)
            isav(il) = il - ic
            ril = il
            iu = ril - crx(il, ij)
            ric = ic
            rc = crx(il, ij) - ric
            fx(il, ij) = rc*qtmp(iu, ij)
          END DO
        ELSE
          DO il=i1,i2
            ic = crx(il, ij)
            isav(il) = il - ic
            ril = il
            iu = ril - crx(il, ij)
            ric = ic
            rc = crx(il, ij) - ric
            fx(il, ij) = rc*(qtmp(iu, ij)+dcx(iu, ij)*(SIGN(1.0d0, rc)-&
&             rc))
          END DO
        END IF
        DO il=i1,i2
          IF (crx(il, ij) .GT. 1.0d0) THEN
            DO ix=isav(il),il-1
              fx(il, ij) = fx(il, ij) + qtmp(ix, ij)
            END DO
          ELSE IF (crx(il, ij) .LT. -1.0d0) THEN
            DO ix=il,isav(il)-1
              fx(il, ij) = fx(il, ij) - qtmp(ix, ij)
            END DO
          END IF
        END DO
!---------------------------------------------------------------
! Prior to 12/5/08:
! We need to write this as an explicit loop over IL
! to facilitate OpenMP parallelization.  Preserve original
! code here. (bmy, 12/5/08)
!fx(i1:i2,ij,ik) = pu(i1:i2,ij,ik) * fx(i1:i2,ij,ik)
!---------------------------------------------------------------
        DO il=i1,i2
          fx(il, ij) = pu(il, ij)*fx(il, ij)
        END DO
      END IF
    END DO
!         ======
!         ======
!      ======
!   ======
! NOTE: This loop does not parallelize well (bmy, 12/5/08)
    DO ij=j1p,j2p
      DO il=i1,i2-1
        dq1(il, ij) = dq1(il, ij) + (fx(il, ij)-fx(il+1, ij))
      END DO
      dq1(i2, ij) = dq1(i2, ij) + (fx(i2, ij)-fx(i1, ij))
    END DO
  END SUBROUTINE XTP

!  Differentiation of xmist in forward (tangent) mode:
!   variations   of useful results: dcx
!   with respect to varying inputs: qqv
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Xmist
!
! !DESCRIPTION: Subroutine Xmist computes the linear tracer slope in the
!  E-W direction. It uses the Lin et. al. 1994 algorithm.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE XMIST_D(dcx, dcxd, qqv, qqvd, j1p, j2p, i2_gl, ju1_gl, &
&   j2_gl, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Concentration contribution from N-S advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqv(-(i2/3):i2+i2/3, julo:jhi)
    REAL*8, INTENT(IN) :: qqvd(-(i2/3):i2+i2/3, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Slope of concentration distribution in E-W direction [mixing ratio]
    REAL*8, INTENT(OUT) :: dcx(-(i2/3):i2+i2/3, julo:jhi)
    REAL*8, INTENT(OUT) :: dcxd(-(i2/3):i2+i2/3, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il, ij
    REAL*8 :: pmax, pmin
    REAL*8 :: pmaxd, pmind
    REAL*8 :: r24
    REAL*8 :: tmp
    REAL*8 :: tmpd
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL*8 :: x1
    REAL*8 :: x1d
    REAL*8 :: max1
    REAL*8 :: max1d
    REAL*8 :: min1
    REAL*8 :: min1d
    REAL*8 :: min2
    REAL*8 :: min2d
!   ----------------
!   Begin execution.
!   ----------------
    r24 = 1.0d0/24.0d0
    dcxd = 0.0_8
    DO ij=j1p+1,j2p-1
      DO il=i1,i2
        tmpd = r24*(8.0d0*(qqvd(il+1, ij)-qqvd(il-1, ij))+qqvd(il-2, ij)&
&         -qqvd(il+2, ij))
        tmp = (8.0d0*(qqv(il+1, ij)-qqv(il-1, ij))+qqv(il-2, ij)-qqv(il+&
&         2, ij))*r24
        IF (qqv(il-1, ij) .LT. qqv(il, ij)) THEN
          IF (qqv(il, ij) .LT. qqv(il+1, ij)) THEN
            max1d = qqvd(il+1, ij)
            max1 = qqv(il+1, ij)
          ELSE
            max1d = qqvd(il, ij)
            max1 = qqv(il, ij)
          END IF
        ELSE IF (qqv(il-1, ij) .LT. qqv(il+1, ij)) THEN
          max1d = qqvd(il+1, ij)
          max1 = qqv(il+1, ij)
        ELSE
          max1d = qqvd(il-1, ij)
          max1 = qqv(il-1, ij)
        END IF
        pmaxd = max1d - qqvd(il, ij)
        pmax = max1 - qqv(il, ij)
        IF (qqv(il-1, ij) .GT. qqv(il, ij)) THEN
          IF (qqv(il, ij) .GT. qqv(il+1, ij)) THEN
            min1d = qqvd(il+1, ij)
            min1 = qqv(il+1, ij)
          ELSE
            min1d = qqvd(il, ij)
            min1 = qqv(il, ij)
          END IF
        ELSE IF (qqv(il-1, ij) .GT. qqv(il+1, ij)) THEN
          min1d = qqvd(il+1, ij)
          min1 = qqv(il+1, ij)
        ELSE
          min1d = qqvd(il-1, ij)
          min1 = qqv(il-1, ij)
        END IF
        pmind = qqvd(il, ij) - min1d
        pmin = qqv(il, ij) - min1
        IF (tmp .GE. 0.) THEN
          x1d = tmpd
          x1 = tmp
        ELSE
          x1d = -tmpd
          x1 = -tmp
        END IF
        IF (x1 .GT. pmax) THEN
          IF (pmax .GT. pmin) THEN
            min2d = pmind
            min2 = pmin
          ELSE
            min2d = pmaxd
            min2 = pmax
          END IF
        ELSE IF (x1 .GT. pmin) THEN
          min2d = pmind
          min2 = pmin
        ELSE
          min2d = x1d
          min2 = x1
        END IF
        dcxd(il, ij) = SIGN(1.d0, min2*tmp)*min2d
        dcx(il, ij) = SIGN(min2, tmp)
      END DO
    END DO
!--------------------------------------------------------------------
! Prior to 12/4/08:
! We need to add outer IK and IJ loops for OpenMP parallelization.
! Preserve original code here (bmy, 12/4/08)
!! Populate ghost zones of dcx (ccc, 11/20/08)
!do il = -i2/3, 0
!   dcx(il,:,:) = dcx(i2+il,:,:)
!enddo
!
!do il = i2+1, i2+i2/3
!   dcx(il,:,:) = dcx(il-i2,:,:)
!enddo
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!--------------------------------------------------------------------
! Populate ghost zones of dcx (ccc, 11/20/08)
    DO ij=julo,jhi
      DO il=-(i2/3),0
        dcxd(il, ij) = dcxd(i2+il, ij)
        dcx(il, ij) = dcx(i2+il, ij)
      END DO
      DO il=i2+1,i2+i2/3
        dcxd(il, ij) = dcxd(il-i2, ij)
        dcx(il, ij) = dcx(il-i2, ij)
      END DO
    END DO
  END SUBROUTINE XMIST_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Xmist
!
! !DESCRIPTION: Subroutine Xmist computes the linear tracer slope in the
!  E-W direction. It uses the Lin et. al. 1994 algorithm.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE XMIST(dcx, qqv, j1p, j2p, i2_gl, ju1_gl, j2_gl, ilo, ihi, &
&   julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Concentration contribution from N-S advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqv(-(i2/3):i2+i2/3, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Slope of concentration distribution in E-W direction [mixing ratio]
    REAL*8, INTENT(OUT) :: dcx(-(i2/3):i2+i2/3, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il, ij
    REAL*8 :: pmax, pmin
    REAL*8 :: r24
    REAL*8 :: tmp
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL*8 :: x1
    REAL*8 :: max1
    REAL*8 :: min1
    REAL*8 :: min2
!   ----------------
!   Begin execution.
!   ----------------
    r24 = 1.0d0/24.0d0
    DO ij=j1p+1,j2p-1
      DO il=i1,i2
        tmp = (8.0d0*(qqv(il+1, ij)-qqv(il-1, ij))+qqv(il-2, ij)-qqv(il+&
&         2, ij))*r24
        IF (qqv(il-1, ij) .LT. qqv(il, ij)) THEN
          IF (qqv(il, ij) .LT. qqv(il+1, ij)) THEN
            max1 = qqv(il+1, ij)
          ELSE
            max1 = qqv(il, ij)
          END IF
        ELSE IF (qqv(il-1, ij) .LT. qqv(il+1, ij)) THEN
          max1 = qqv(il+1, ij)
        ELSE
          max1 = qqv(il-1, ij)
        END IF
        pmax = max1 - qqv(il, ij)
        IF (qqv(il-1, ij) .GT. qqv(il, ij)) THEN
          IF (qqv(il, ij) .GT. qqv(il+1, ij)) THEN
            min1 = qqv(il+1, ij)
          ELSE
            min1 = qqv(il, ij)
          END IF
        ELSE IF (qqv(il-1, ij) .GT. qqv(il+1, ij)) THEN
          min1 = qqv(il+1, ij)
        ELSE
          min1 = qqv(il-1, ij)
        END IF
        pmin = qqv(il, ij) - min1
        IF (tmp .GE. 0.) THEN
          x1 = tmp
        ELSE
          x1 = -tmp
        END IF
        IF (x1 .GT. pmax) THEN
          IF (pmax .GT. pmin) THEN
            min2 = pmin
          ELSE
            min2 = pmax
          END IF
        ELSE IF (x1 .GT. pmin) THEN
          min2 = pmin
        ELSE
          min2 = x1
        END IF
        dcx(il, ij) = SIGN(min2, tmp)
      END DO
    END DO
!--------------------------------------------------------------------
! Prior to 12/4/08:
! We need to add outer IK and IJ loops for OpenMP parallelization.
! Preserve original code here (bmy, 12/4/08)
!! Populate ghost zones of dcx (ccc, 11/20/08)
!do il = -i2/3, 0
!   dcx(il,:,:) = dcx(i2+il,:,:)
!enddo
!
!do il = i2+1, i2+i2/3
!   dcx(il,:,:) = dcx(il-i2,:,:)
!enddo
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!--------------------------------------------------------------------
! Populate ghost zones of dcx (ccc, 11/20/08)
    DO ij=julo,jhi
      DO il=-(i2/3),0
        dcx(il, ij) = dcx(i2+il, ij)
      END DO
      DO il=i2+1,i2+i2/3
        dcx(il, ij) = dcx(il-i2, ij)
      END DO
    END DO
  END SUBROUTINE XMIST

!  Differentiation of fxppm in forward (tangent) mode:
!   variations   of useful results: qqv fx dcx
!   with respect to varying inputs: qqv fx dcx
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Fxppm
!
! !DESCRIPTION: Subroutine Fxppm is the 1D "outer" flux form operator based
!  on the Piecewise Parabolic Method (PPM; see also Lin and Rood 1996) for
!  computing the fluxes in the E-W direction.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE FXPPM_D(ij, ilmt, crx, dcx, dcxd, fx, fxd, qqv, qqvd, ilo, &
&   ihi, julo, jhi, i1, i2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Local min & max longitude (I) and altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Latitude (IJ) and altitude (IK) indices
    INTEGER, INTENT(IN) :: ij
! Controls various options in E-W advection
    INTEGER, INTENT(IN) :: ilmt
! Courant number in E-W direction
    REAL*8, INTENT(IN) :: crx(i1:i2, julo:jhi)
!
! !INPUT/OUTPUT PARAMETERS:
!
! Concentration contribution from N-S advection [mixing ratio]
    REAL*8, INTENT(INOUT) :: qqv(ilo:ihi, julo:jhi)
    REAL*8, INTENT(INOUT) :: qqvd(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Slope of concentration distribution in E-W direction (mixing ratio)
    REAL*8, INTENT(OUT) :: dcx(ilo:ihi, julo:jhi)
    REAL*8, INTENT(OUT) :: dcxd(ilo:ihi, julo:jhi)
! E-W flux [mixing ratio]
    REAL*8, INTENT(OUT) :: fx(i1:i2, julo:jhi)
    REAL*8, INTENT(OUT) :: fxd(i1:i2, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REMARKS:
!   This routine is called from w/in a OpenMP parallel loop fro
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!                               Also remove the allocatable arrays, which
!                               interfere w/ OpenMP parallelization.
!   01 Apr 2009 - C. Carouge  - The input arrays are now 2D only.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
!-------------------------------------------------------------------------
! Prior to 12/5/08:
! Remove this (explanation below).
!LOGICAL,             SAVE :: first = .true.
!-------------------------------------------------------------------------
    INTEGER :: il
    INTEGER :: ilm1
    INTEGER :: lenx
    REAL*8 :: r13, r23
    REAL*8 :: rval
    REAL*8 :: rvald
!------------------------------------------------------------------------
! Prior to 12/5/08:
! NOTE: It is a bad idea to make these arrays allocatable.  The way this
! was implemented, it tried to create these arrays once for each thread.
! This led to a segmentation fault.  Better to just define these arrays
! with the appropriate dimensions.  Also note, we don't really need to
! use SAVE since these arrays are being reset to zero on each call
! to Fxppm. (bmy, 12/5/08)
!
!! Arrays
!REAL*8, ALLOCATABLE, SAVE :: a6(:)
!REAL*8, ALLOCATABLE, SAVE :: al(:)
!REAL*8, ALLOCATABLE, SAVE :: ar(:)
!REAL*8, ALLOCATABLE, SAVE :: a61(:)
!REAL*8, ALLOCATABLE, SAVE :: al1(:)
!REAL*8, ALLOCATABLE, SAVE :: ar1(:)
!REAL*8, ALLOCATABLE, SAVE :: dcxi1(:)
!REAL*8, ALLOCATABLE, SAVE :: qqvi1(:)
!------------------------------------------------------------------------
! Arrays
    REAL*8 :: a6(ilo:ihi)
    REAL*8 :: a6d(ilo:ihi)
    REAL*8 :: al(ilo:ihi)
    REAL*8 :: ald(ilo:ihi)
    REAL*8 :: ar(ilo:ihi)
    REAL*8 :: ard(ilo:ihi)
    REAL*8 :: a61(ihi-1-(ilo+1)+1)
    REAL*8 :: a61d(ihi-1-(ilo+1)+1)
    REAL*8 :: al1(ihi-1-(ilo+1)+1)
    REAL*8 :: al1d(ihi-1-(ilo+1)+1)
    REAL*8 :: ar1(ihi-1-(ilo+1)+1)
    REAL*8 :: ar1d(ihi-1-(ilo+1)+1)
    REAL*8 :: dcxi1(ihi-1-(ilo+1)+1)
    REAL*8 :: dcxi1d(ihi-1-(ilo+1)+1)
    REAL*8 :: qqvi1(ihi-1-(ilo+1)+1)
    REAL*8 :: qqvi1d(ihi-1-(ilo+1)+1)
    REAL*8 :: temp
    REAL*8 :: temp0
!     ----------------
!     Begin execution.
!     ----------------
!------------------------------------------------------------------------------
! Prior to 12/5/08:
! Remove the ALLOCATE command, since we are now declaring these as regular
! subroutine arrays and not making them allocatable. (bmy, 12/5/08)
!!   ==========
!    if (first) then
!!   ==========
!
!       first = .false.
!
!       Allocate (a6(ilo:ihi))
!       Allocate (al(ilo:ihi))
!       Allocate (ar(ilo:ihi))
!       a6 = 0.0d0; al = 0.0d0; ar = 0.0d0
!
!       Allocate (a61((ihi-1)-(ilo+1)+1))
!       Allocate (al1((ihi-1)-(ilo+1)+1))
!       Allocate (ar1((ihi-1)-(ilo+1)+1))
!       a61 = 0.0d0; al1 = 0.0d0; ar1 = 0.0d0
!
!       Allocate (dcxi1((ihi-1)-(ilo+1)+1))
!       Allocate (qqvi1((ihi-1)-(ilo+1)+1))
!       dcxi1 = 0.0d0; qqvi1 = 0.0d0
!
!    end if
!------------------------------------------------------------------------------
! Zero arrays (bmy, 12/5/08)
    a6 = 0.0d0
    al = 0.0d0
    ar = 0.0d0
    a61 = 0.0d0
    al1 = 0.0d0
    ar1 = 0.0d0
    dcxi1 = 0.0d0
    qqvi1 = 0.0d0
    r13 = 1.0d0/3.0d0
    r23 = 2.0d0/3.0d0
    ald = 0.0_8
    ard = 0.0_8
    DO il=ilo+1,ihi
      rvald = 0.5d0*(qqvd(il-1, ij)+qqvd(il, ij)) + r13*(dcxd(il-1, ij)-&
&       dcxd(il, ij))
      rval = 0.5d0*(qqv(il-1, ij)+qqv(il, ij)) + (dcx(il-1, ij)-dcx(il, &
&       ij))*r13
      ald(il) = rvald
      al(il) = rval
      ard(il-1) = rvald
      ar(il-1) = rval
    END DO
    a6d = 0.0_8
    DO il=ilo+1,ihi-1
      a6d(il) = 3.0d0*(2*qqvd(il, ij)-ald(il)-ard(il))
      a6(il) = 3.0d0*(qqv(il, ij)+qqv(il, ij)-(al(il)+ar(il)))
    END DO
!   ==============
    IF (ilmt .LE. 2) THEN
!   ==============
      a61(:) = 0.0d0
      al1(:) = 0.0d0
      ar1(:) = 0.0d0
      dcxi1(:) = 0.0d0
      qqvi1(:) = 0.0d0
      lenx = 0
      ar1d = 0.0_8
      al1d = 0.0_8
      dcxi1d = 0.0_8
      a61d = 0.0_8
      qqvi1d = 0.0_8
      DO il=ilo+1,ihi-1
        lenx = lenx + 1
        a61d(lenx) = a6d(il)
        a61(lenx) = a6(il)
        al1d(lenx) = ald(il)
        al1(lenx) = al(il)
        ar1d(lenx) = ard(il)
        ar1(lenx) = ar(il)
        dcxi1d(lenx) = dcxd(il, ij)
        dcxi1(lenx) = dcx(il, ij)
        qqvi1d(lenx) = qqvd(il, ij)
        qqvi1(lenx) = qqv(il, ij)
      END DO
!      ===========
      CALL LMTPPM_D(lenx, ilmt, a61, a61d, al1, al1d, ar1, ar1d, dcxi1, &
&             qqvi1, qqvi1d)
!      ===========
      lenx = 0
      DO il=ilo+1,ihi-1
        lenx = lenx + 1
        a6d(il) = a61d(lenx)
        a6(il) = a61(lenx)
        ald(il) = al1d(lenx)
        al(il) = al1(lenx)
        ard(il) = ar1d(lenx)
        ar(il) = ar1(lenx)
        dcxd(il, ij) = dcxi1d(lenx)
        dcx(il, ij) = dcxi1(lenx)
        qqvd(il, ij) = qqvi1d(lenx)
        qqv(il, ij) = qqvi1(lenx)
      END DO
! Populate ghost zones of qqv and dcx with new values (ccc, 11/20/08)
      DO il=-(i2/3),0
        dcxd(il, ij) = dcxd(i2+il, ij)
        dcx(il, ij) = dcx(i2+il, ij)
        qqvd(il, ij) = qqvd(i2+il, ij)
        qqv(il, ij) = qqv(i2+il, ij)
      END DO
      DO il=i2+1,i2+i2/3
        dcxd(il, ij) = dcxd(il-i2, ij)
        dcx(il, ij) = dcx(il-i2, ij)
        qqvd(il, ij) = qqvd(il-i2, ij)
        qqv(il, ij) = qqv(il-i2, ij)
      END DO
    END IF
    DO il=i1+1,i2
      IF (crx(il, ij) .GT. 0.0d0) THEN
        ilm1 = il - 1
        temp = 0.5d0*crx(il, ij)
        temp0 = -(r23*crx(il, ij)) + 1.0d0
        fxd(il, ij) = ard(ilm1) + temp*(ald(ilm1)-ard(ilm1)+temp0*a6d(&
&         ilm1))
        fx(il, ij) = ar(ilm1) + temp*(al(ilm1)-ar(ilm1)+temp0*a6(ilm1))
      ELSE
        temp0 = 0.5d0*crx(il, ij)
        temp = r23*crx(il, ij) + 1.0d0
        fxd(il, ij) = ald(il) - temp0*(ard(il)-ald(il)+temp*a6d(il))
        fx(il, ij) = al(il) - temp0*(ar(il)-al(il)+temp*a6(il))
      END IF
    END DO
! First box case (ccc, 11/20/08)
    IF (crx(i1, ij) .GT. 0.0d0) THEN
      ilm1 = i2
      temp0 = 0.5d0*crx(i1, ij)
      temp = -(r23*crx(i1, ij)) + 1.0d0
      fxd(i1, ij) = ard(ilm1) + temp0*(ald(ilm1)-ard(ilm1)+temp*a6d(ilm1&
&       ))
      fx(i1, ij) = ar(ilm1) + temp0*(al(ilm1)-ar(ilm1)+temp*a6(ilm1))
    ELSE
      temp0 = 0.5d0*crx(i1, ij)
      temp = r23*crx(i1, ij) + 1.0d0
      fxd(i1, ij) = ald(i1) - temp0*(ard(i1)-ald(i1)+temp*a6d(i1))
      fx(i1, ij) = al(i1) - temp0*(ar(i1)-al(i1)+temp*a6(i1))
    END IF
  END SUBROUTINE FXPPM_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Fxppm
!
! !DESCRIPTION: Subroutine Fxppm is the 1D "outer" flux form operator based
!  on the Piecewise Parabolic Method (PPM; see also Lin and Rood 1996) for
!  computing the fluxes in the E-W direction.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE FXPPM(ij, ilmt, crx, dcx, fx, qqv, ilo, ihi, julo, jhi, i1&
&   , i2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Local min & max longitude (I) and altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Latitude (IJ) and altitude (IK) indices
    INTEGER, INTENT(IN) :: ij
! Controls various options in E-W advection
    INTEGER, INTENT(IN) :: ilmt
! Courant number in E-W direction
    REAL*8, INTENT(IN) :: crx(i1:i2, julo:jhi)
!
! !INPUT/OUTPUT PARAMETERS:
!
! Concentration contribution from N-S advection [mixing ratio]
    REAL*8, INTENT(INOUT) :: qqv(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Slope of concentration distribution in E-W direction (mixing ratio)
    REAL*8, INTENT(OUT) :: dcx(ilo:ihi, julo:jhi)
! E-W flux [mixing ratio]
    REAL*8, INTENT(OUT) :: fx(i1:i2, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REMARKS:
!   This routine is called from w/in a OpenMP parallel loop fro
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!                               Also remove the allocatable arrays, which
!                               interfere w/ OpenMP parallelization.
!   01 Apr 2009 - C. Carouge  - The input arrays are now 2D only.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
!-------------------------------------------------------------------------
! Prior to 12/5/08:
! Remove this (explanation below).
!LOGICAL,             SAVE :: first = .true.
!-------------------------------------------------------------------------
    INTEGER :: il
    INTEGER :: ilm1
    INTEGER :: lenx
    REAL*8 :: r13, r23
    REAL*8 :: rval
!------------------------------------------------------------------------
! Prior to 12/5/08:
! NOTE: It is a bad idea to make these arrays allocatable.  The way this
! was implemented, it tried to create these arrays once for each thread.
! This led to a segmentation fault.  Better to just define these arrays
! with the appropriate dimensions.  Also note, we don't really need to
! use SAVE since these arrays are being reset to zero on each call
! to Fxppm. (bmy, 12/5/08)
!
!! Arrays
!REAL*8, ALLOCATABLE, SAVE :: a6(:)
!REAL*8, ALLOCATABLE, SAVE :: al(:)
!REAL*8, ALLOCATABLE, SAVE :: ar(:)
!REAL*8, ALLOCATABLE, SAVE :: a61(:)
!REAL*8, ALLOCATABLE, SAVE :: al1(:)
!REAL*8, ALLOCATABLE, SAVE :: ar1(:)
!REAL*8, ALLOCATABLE, SAVE :: dcxi1(:)
!REAL*8, ALLOCATABLE, SAVE :: qqvi1(:)
!------------------------------------------------------------------------
! Arrays
    REAL*8 :: a6(ilo:ihi)
    REAL*8 :: al(ilo:ihi)
    REAL*8 :: ar(ilo:ihi)
    REAL*8 :: a61(ihi-1-(ilo+1)+1)
    REAL*8 :: al1(ihi-1-(ilo+1)+1)
    REAL*8 :: ar1(ihi-1-(ilo+1)+1)
    REAL*8 :: dcxi1(ihi-1-(ilo+1)+1)
    REAL*8 :: qqvi1(ihi-1-(ilo+1)+1)
!     ----------------
!     Begin execution.
!     ----------------
!------------------------------------------------------------------------------
! Prior to 12/5/08:
! Remove the ALLOCATE command, since we are now declaring these as regular
! subroutine arrays and not making them allocatable. (bmy, 12/5/08)
!!   ==========
!    if (first) then
!!   ==========
!
!       first = .false.
!
!       Allocate (a6(ilo:ihi))
!       Allocate (al(ilo:ihi))
!       Allocate (ar(ilo:ihi))
!       a6 = 0.0d0; al = 0.0d0; ar = 0.0d0
!
!       Allocate (a61((ihi-1)-(ilo+1)+1))
!       Allocate (al1((ihi-1)-(ilo+1)+1))
!       Allocate (ar1((ihi-1)-(ilo+1)+1))
!       a61 = 0.0d0; al1 = 0.0d0; ar1 = 0.0d0
!
!       Allocate (dcxi1((ihi-1)-(ilo+1)+1))
!       Allocate (qqvi1((ihi-1)-(ilo+1)+1))
!       dcxi1 = 0.0d0; qqvi1 = 0.0d0
!
!    end if
!------------------------------------------------------------------------------
! Zero arrays (bmy, 12/5/08)
    a6 = 0.0d0
    al = 0.0d0
    ar = 0.0d0
    a61 = 0.0d0
    al1 = 0.0d0
    ar1 = 0.0d0
    dcxi1 = 0.0d0
    qqvi1 = 0.0d0
    r13 = 1.0d0/3.0d0
    r23 = 2.0d0/3.0d0
    DO il=ilo+1,ihi
      rval = 0.5d0*(qqv(il-1, ij)+qqv(il, ij)) + (dcx(il-1, ij)-dcx(il, &
&       ij))*r13
      al(il) = rval
      ar(il-1) = rval
    END DO
    DO il=ilo+1,ihi-1
      a6(il) = 3.0d0*(qqv(il, ij)+qqv(il, ij)-(al(il)+ar(il)))
    END DO
!   ==============
    IF (ilmt .LE. 2) THEN
!   ==============
      a61(:) = 0.0d0
      al1(:) = 0.0d0
      ar1(:) = 0.0d0
      dcxi1(:) = 0.0d0
      qqvi1(:) = 0.0d0
      lenx = 0
      DO il=ilo+1,ihi-1
        lenx = lenx + 1
        a61(lenx) = a6(il)
        al1(lenx) = al(il)
        ar1(lenx) = ar(il)
        dcxi1(lenx) = dcx(il, ij)
        qqvi1(lenx) = qqv(il, ij)
      END DO
!      ===========
      CALL LMTPPM(lenx, ilmt, a61, al1, ar1, dcxi1, qqvi1)
!      ===========
      lenx = 0
      DO il=ilo+1,ihi-1
        lenx = lenx + 1
        a6(il) = a61(lenx)
        al(il) = al1(lenx)
        ar(il) = ar1(lenx)
        dcx(il, ij) = dcxi1(lenx)
        qqv(il, ij) = qqvi1(lenx)
      END DO
! Populate ghost zones of qqv and dcx with new values (ccc, 11/20/08)
      DO il=-(i2/3),0
        dcx(il, ij) = dcx(i2+il, ij)
        qqv(il, ij) = qqv(i2+il, ij)
      END DO
      DO il=i2+1,i2+i2/3
        dcx(il, ij) = dcx(il-i2, ij)
        qqv(il, ij) = qqv(il-i2, ij)
      END DO
    END IF
    DO il=i1+1,i2
      IF (crx(il, ij) .GT. 0.0d0) THEN
        ilm1 = il - 1
        fx(il, ij) = ar(ilm1) + 0.5d0*crx(il, ij)*(al(ilm1)-ar(ilm1)+a6(&
&         ilm1)*(1.0d0-r23*crx(il, ij)))
      ELSE
        fx(il, ij) = al(il) - 0.5d0*crx(il, ij)*(ar(il)-al(il)+a6(il)*(&
&         1.0d0+r23*crx(il, ij)))
      END IF
    END DO
! First box case (ccc, 11/20/08)
    IF (crx(i1, ij) .GT. 0.0d0) THEN
      ilm1 = i2
      fx(i1, ij) = ar(ilm1) + 0.5d0*crx(i1, ij)*(al(ilm1)-ar(ilm1)+a6(&
&       ilm1)*(1.0d0-r23*crx(i1, ij)))
    ELSE
      fx(i1, ij) = al(i1) - 0.5d0*crx(i1, ij)*(ar(i1)-al(i1)+a6(i1)*(&
&       1.0d0+r23*crx(i1, ij)))
    END IF
  END SUBROUTINE FXPPM

!  Differentiation of lmtppm in forward (tangent) mode:
!   variations   of useful results: al ar a6
!   with respect to varying inputs: qa al ar a6
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Lmtppm
!
! !DESCRIPTION: Subroutine Lmtppm enforces the full monotonic, semi-monotonic,
!  or the positive-definite constraint to the sub-grid parabolic distribution
!  of the Piecewise Parabolic Method (PPM).
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE LMTPPM_D(lenx, lmt, a6, a6d, al, ald, ar, ard, dc, qa, qad)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
! If 0 => full monotonicity;
! If 1 => semi-monotonic constraint (no undershoots);
! If 2 => positive-definite constraint
    INTEGER, INTENT(IN) :: lmt
! Vector length
    INTEGER, INTENT(IN) :: lenx
!
! !INPUT/OUTPUT PARAMETERS:
!
! Curvature of the test parabola
    REAL*8, INTENT(INOUT) :: a6(lenx)
    REAL*8, INTENT(INOUT) :: a6d(lenx)
! Left edge value of the test parabola
    REAL*8, INTENT(INOUT) :: al(lenx)
    REAL*8, INTENT(INOUT) :: ald(lenx)
! Right edge value of the test parabola
    REAL*8, INTENT(INOUT) :: ar(lenx)
    REAL*8, INTENT(INOUT) :: ard(lenx)
! 0.5 * mismatch
    REAL*8, INTENT(INOUT) :: dc(lenx)
! Cell-averaged value
    REAL*8, INTENT(INOUT) :: qa(lenx)
    REAL*8, INTENT(INOUT) :: qad(lenx)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il
    REAL*8 :: a6da
    REAL*8 :: da1, da2
    REAL*8 :: fmin, ftmp
    REAL*8 :: r12
    INTRINSIC ABS
    REAL*8 :: abs0
    REAL*8 :: abs1
!   ----------------
!   Begin execution.
!   ----------------
    r12 = 1.0d0/12.0d0
!   =============
    IF (lmt .EQ. 0) THEN
!   =============
!      ----------------
!      Full constraint.
!      ----------------
      DO il=1,lenx
        IF (dc(il) .EQ. 0.0d0) THEN
          a6d(il) = 0.0_8
          a6(il) = 0.0d0
          ald(il) = qad(il)
          al(il) = qa(il)
          ard(il) = qad(il)
          ar(il) = qa(il)
        ELSE
          da1 = ar(il) - al(il)
          da2 = da1*da1
          a6da = a6(il)*da1
          IF (a6da .LT. -da2) THEN
            a6d(il) = 3.0d0*(ald(il)-qad(il))
            a6(il) = 3.0d0*(al(il)-qa(il))
            ard(il) = ald(il) - a6d(il)
            ar(il) = al(il) - a6(il)
          ELSE IF (a6da .GT. da2) THEN
            a6d(il) = 3.0d0*(ard(il)-qad(il))
            a6(il) = 3.0d0*(ar(il)-qa(il))
            ald(il) = ard(il) - a6d(il)
            al(il) = ar(il) - a6(il)
          END IF
        END IF
      END DO
    ELSE IF (lmt .EQ. 1) THEN
!   ==================
!   ==================
!      --------------------------
!      Semi-monotonic constraint.
!      --------------------------
      DO il=1,lenx
        IF (ar(il) - al(il) .GE. 0.) THEN
          abs0 = ar(il) - al(il)
        ELSE
          abs0 = -(ar(il)-al(il))
        END IF
        IF (abs0 .LT. -a6(il)) THEN
          IF (qa(il) .LT. ar(il) .AND. qa(il) .LT. al(il)) THEN
            a6d(il) = 0.0_8
            a6(il) = 0.0d0
            ald(il) = qad(il)
            al(il) = qa(il)
            ard(il) = qad(il)
            ar(il) = qa(il)
          ELSE IF (ar(il) .GT. al(il)) THEN
            a6d(il) = 3.0d0*(ald(il)-qad(il))
            a6(il) = 3.0d0*(al(il)-qa(il))
            ard(il) = ald(il) - a6d(il)
            ar(il) = al(il) - a6(il)
          ELSE
            a6d(il) = 3.0d0*(ard(il)-qad(il))
            a6(il) = 3.0d0*(ar(il)-qa(il))
            ald(il) = ard(il) - a6d(il)
            al(il) = ar(il) - a6(il)
          END IF
        END IF
      END DO
    ELSE IF (lmt .EQ. 2) THEN
!   ==================
!   ==================
      DO il=1,lenx
        IF (ar(il) - al(il) .GE. 0.) THEN
          abs1 = ar(il) - al(il)
        ELSE
          abs1 = -(ar(il)-al(il))
        END IF
        IF (abs1 .LT. -a6(il)) THEN
          ftmp = ar(il) - al(il)
          fmin = qa(il) + 0.25d0*(ftmp*ftmp)/a6(il) + a6(il)*r12
          IF (fmin .LT. 0.0d0) THEN
            IF (qa(il) .LT. ar(il) .AND. qa(il) .LT. al(il)) THEN
              a6d(il) = 0.0_8
              a6(il) = 0.0d0
              ald(il) = qad(il)
              al(il) = qa(il)
              ard(il) = qad(il)
              ar(il) = qa(il)
            ELSE IF (ar(il) .GT. al(il)) THEN
              a6d(il) = 3.0d0*(ald(il)-qad(il))
              a6(il) = 3.0d0*(al(il)-qa(il))
              ard(il) = ald(il) - a6d(il)
              ar(il) = al(il) - a6(il)
            ELSE
              a6d(il) = 3.0d0*(ard(il)-qad(il))
              a6(il) = 3.0d0*(ar(il)-qa(il))
              ald(il) = ard(il) - a6d(il)
              al(il) = ar(il) - a6(il)
            END IF
          END IF
        END IF
      END DO
    END IF
  END SUBROUTINE LMTPPM_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Lmtppm
!
! !DESCRIPTION: Subroutine Lmtppm enforces the full monotonic, semi-monotonic,
!  or the positive-definite constraint to the sub-grid parabolic distribution
!  of the Piecewise Parabolic Method (PPM).
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE LMTPPM(lenx, lmt, a6, al, ar, dc, qa)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
! If 0 => full monotonicity;
! If 1 => semi-monotonic constraint (no undershoots);
! If 2 => positive-definite constraint
    INTEGER, INTENT(IN) :: lmt
! Vector length
    INTEGER, INTENT(IN) :: lenx
!
! !INPUT/OUTPUT PARAMETERS:
!
! Curvature of the test parabola
    REAL*8, INTENT(INOUT) :: a6(lenx)
! Left edge value of the test parabola
    REAL*8, INTENT(INOUT) :: al(lenx)
! Right edge value of the test parabola
    REAL*8, INTENT(INOUT) :: ar(lenx)
! 0.5 * mismatch
    REAL*8, INTENT(INOUT) :: dc(lenx)
! Cell-averaged value
    REAL*8, INTENT(INOUT) :: qa(lenx)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il
    REAL*8 :: a6da
    REAL*8 :: da1, da2
    REAL*8 :: fmin, ftmp
    REAL*8 :: r12
    INTRINSIC ABS
    REAL*8 :: abs0
    REAL*8 :: abs1
!   ----------------
!   Begin execution.
!   ----------------
    r12 = 1.0d0/12.0d0
!   =============
    IF (lmt .EQ. 0) THEN
!   =============
!      ----------------
!      Full constraint.
!      ----------------
      DO il=1,lenx
        IF (dc(il) .EQ. 0.0d0) THEN
          a6(il) = 0.0d0
          al(il) = qa(il)
          ar(il) = qa(il)
        ELSE
          da1 = ar(il) - al(il)
          da2 = da1*da1
          a6da = a6(il)*da1
          IF (a6da .LT. -da2) THEN
            a6(il) = 3.0d0*(al(il)-qa(il))
            ar(il) = al(il) - a6(il)
          ELSE IF (a6da .GT. da2) THEN
            a6(il) = 3.0d0*(ar(il)-qa(il))
            al(il) = ar(il) - a6(il)
          END IF
        END IF
      END DO
    ELSE IF (lmt .EQ. 1) THEN
!   ==================
!   ==================
!      --------------------------
!      Semi-monotonic constraint.
!      --------------------------
      DO il=1,lenx
        IF (ar(il) - al(il) .GE. 0.) THEN
          abs0 = ar(il) - al(il)
        ELSE
          abs0 = -(ar(il)-al(il))
        END IF
        IF (abs0 .LT. -a6(il)) THEN
          IF (qa(il) .LT. ar(il) .AND. qa(il) .LT. al(il)) THEN
            a6(il) = 0.0d0
            al(il) = qa(il)
            ar(il) = qa(il)
          ELSE IF (ar(il) .GT. al(il)) THEN
            a6(il) = 3.0d0*(al(il)-qa(il))
            ar(il) = al(il) - a6(il)
          ELSE
            a6(il) = 3.0d0*(ar(il)-qa(il))
            al(il) = ar(il) - a6(il)
          END IF
        END IF
      END DO
    ELSE IF (lmt .EQ. 2) THEN
!   ==================
!   ==================
      DO il=1,lenx
        IF (ar(il) - al(il) .GE. 0.) THEN
          abs1 = ar(il) - al(il)
        ELSE
          abs1 = -(ar(il)-al(il))
        END IF
        IF (abs1 .LT. -a6(il)) THEN
          ftmp = ar(il) - al(il)
          fmin = qa(il) + 0.25d0*(ftmp*ftmp)/a6(il) + a6(il)*r12
          IF (fmin .LT. 0.0d0) THEN
            IF (qa(il) .LT. ar(il) .AND. qa(il) .LT. al(il)) THEN
              a6(il) = 0.0d0
              al(il) = qa(il)
              ar(il) = qa(il)
            ELSE IF (ar(il) .GT. al(il)) THEN
              a6(il) = 3.0d0*(al(il)-qa(il))
              ar(il) = al(il) - a6(il)
            ELSE
              a6(il) = 3.0d0*(ar(il)-qa(il))
              al(il) = ar(il) - a6(il)
            END IF
          END IF
        END IF
      END DO
    END IF
  END SUBROUTINE LMTPPM

!  Differentiation of ytp in forward (tangent) mode:
!   variations   of useful results: dq1
!   with respect to varying inputs: qqu qqv dq1
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE:  Ytp
!
! !DESCRIPTION: Subroutine Ytp does horizontal advection in the N-S direction.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE YTP_D(jlmt, geofac_pc, geofac, cry, dq1, dq1d, qqu, qqud, &
&   qqv, qqvd, ymass, fy, j1p, j2p, i1_gl, i2_gl, ju1_gl, j2_gl, ilong, &
&   ilo, ihi, julo, jhi, i1, i2, ju1, j2, jord)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! ???
    INTEGER, INTENT(IN) :: ilong
! Controls various options in N-S advection
    INTEGER, INTENT(IN) :: jlmt
! N-S transport scheme (see module header for more info)
    INTEGER, INTENT(IN) :: jord
! special geometrical factor (geofac) for Polar cap
    REAL*8, INTENT(IN) :: geofac_pc
! geometrical factor for meridional advection; geofac uses correct
! spherical geometry, and replaces acosp as the  meridional geometrical
! factor in tpcore
    REAL*8, INTENT(IN) :: geofac(ju1_gl:j2_gl)
! Courant number in N-S direction
    REAL*8, INTENT(IN) :: cry(ilo:ihi, julo:jhi)
! Concentration contribution from E-W advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqu(ilo:ihi, julo:jhi)
    REAL*8, INTENT(IN) :: qqud(ilo:ihi, julo:jhi)
! Horizontal mass flux in N-S direction [hPa]
    REAL*8, INTENT(IN) :: ymass(ilo:ihi, julo:jhi)
!
! !INPUT/OUTPUT PARAMETERS:
!
! Species density [hPa]
    REAL*8, INTENT(INOUT) :: dq1(ilo:ihi, julo:jhi)
    REAL*8, INTENT(INOUT) :: dq1d(ilo:ihi, julo:jhi)
! Concentration contribution from N-S advection [mixing ratio]
    REAL*8, INTENT(INOUT) :: qqv(ilo:ihi, julo:jhi)
    REAL*8, INTENT(INOUT) :: qqvd(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! N-S flux [mixing ratio]
    REAL*8, INTENT(OUT) :: fy(ilo:ihi, julo:jhi+1)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il, ij
    INTEGER :: jv
    REAL*8 :: rj1p
! Arrays
    REAL*8 :: dcy(ilo:ihi, julo:jhi)
    REAL*8 :: dcyd(ilo:ihi, julo:jhi)
    INTRINSIC SIGN
    REAL*8 :: temp
!   ----------------
!   Begin execution.
!   ----------------
    dcy(:, :) = 0.0d0
    fy(:, :) = 0.0d0
    rj1p = j1p
!   ==============
    IF (jord .EQ. 1) THEN
!   ==============
      DO ij=j1p,j2p+1
        DO il=i1,i2
!c?
          jv = rj1p - cry(il, ij)
          qqvd(il, ij) = qqud(il, jv)
          qqv(il, ij) = qqu(il, jv)
        END DO
      END DO
    ELSE
!   ====
!   ====
!      ==========
!     ==========
      CALL YMIST_D(4, dcy, dcyd, qqu, qqud, i1_gl, i2_gl, ju1_gl, j2_gl&
&            , j1p, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
      IF (jord .LE. 0 .OR. jord .GE. 3) THEN
!         ==========
!         ==========
        CALL FYPPM_D(jlmt, cry, dcy, dcyd, qqu, qqud, qqv, qqvd, j1p, &
&              j2p, i1_gl, i2_gl, ju1_gl, j2_gl, ilong, ilo, ihi, julo, &
&              jhi, i1, i2, ju1, j2)
      ELSE
        DO ij=j1p,j2p+1
          DO il=i1,i2
!c?
            jv = rj1p - cry(il, ij)
            temp = SIGN(1.0d0, cry(il, ij)) - cry(il, ij)
            qqvd(il, ij) = qqud(il, jv) + temp*dcyd(il, jv)
            qqv(il, ij) = qqu(il, jv) + temp*dcy(il, jv)
          END DO
        END DO
      END IF
    END IF
!-----------------------------------------------------------------------
! Prior to 12/5/08:
! We need to add an outer IK loop for OpenMP parallelization.
! Preserve original code here (bmy, 12/5/08)
!do ij = j1p, j2p+1
!   qqv(i1:i2,ij,:) = qqv(i1:i2,ij,:) * ymass(i1:i2,ij,:)
!end do
! The IK loop is moved outside the subroutine (ccc, 4/1/09)
!-----------------------------------------------------------------------
    DO ij=j1p,j2p+1
      qqvd(i1:i2, ij) = ymass(i1:i2, ij)*qqvd(i1:i2, ij)
      qqv(i1:i2, ij) = qqv(i1:i2, ij)*ymass(i1:i2, ij)
    END DO
!.sds.. save N-S species flux as diagnostic
    DO ij=i1,i2
      fy(ij, j1p:j2p+1) = qqv(ij, j1p:j2p+1)*geofac(j1p:j2p+1)
    END DO
!--------------------------------------------------------------------
! Prior to 12/5/08:
! We need to add an outer IK loop for OpenMP parallelization.
! Preserve original code here (bmy, 12/5/08)
!!... meridional flux update
!do ij = j1p, j2p
!
!   dq1(i1:i2,ij,:) =  &
!        dq1(i1:i2,ij,:) +  &
!        (qqv(i1:i2,ij,:) - qqv(i1:i2,ij+1,:)) * geofac(ij)
!
!end do
! The IK loop is moved outside the subroutine (ccc, 4/1/09)
!--------------------------------------------------------------------
!... meridional flux update
    DO ij=j1p,j2p
      dq1d(i1:i2, ij) = dq1d(i1:i2, ij) + geofac(ij)*(qqvd(i1:i2, ij)-&
&       qqvd(i1:i2, ij+1))
      dq1(i1:i2, ij) = dq1(i1:i2, ij) + (qqv(i1:i2, ij)-qqv(i1:i2, ij+1)&
&       )*geofac(ij)
    END DO
!   ====================
!   ====================
    CALL DO_YTP_POLE_SUM_D(geofac_pc, dq1, dq1d, qqv, qqvd, fy, i1_gl, &
&                    i2_gl, ju1_gl, j2_gl, j1p, j2p, ilo, ihi, julo, jhi&
&                    , i1, i2, ju1, j2)
  END SUBROUTINE YTP_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE:  Ytp
!
! !DESCRIPTION: Subroutine Ytp does horizontal advection in the N-S direction.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE YTP(jlmt, geofac_pc, geofac, cry, dq1, qqu, qqv, ymass, fy&
&   , j1p, j2p, i1_gl, i2_gl, ju1_gl, j2_gl, ilong, ilo, ihi, julo, jhi&
&   , i1, i2, ju1, j2, jord)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! ???
    INTEGER, INTENT(IN) :: ilong
! Controls various options in N-S advection
    INTEGER, INTENT(IN) :: jlmt
! N-S transport scheme (see module header for more info)
    INTEGER, INTENT(IN) :: jord
! special geometrical factor (geofac) for Polar cap
    REAL*8, INTENT(IN) :: geofac_pc
! geometrical factor for meridional advection; geofac uses correct
! spherical geometry, and replaces acosp as the  meridional geometrical
! factor in tpcore
    REAL*8, INTENT(IN) :: geofac(ju1_gl:j2_gl)
! Courant number in N-S direction
    REAL*8, INTENT(IN) :: cry(ilo:ihi, julo:jhi)
! Concentration contribution from E-W advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqu(ilo:ihi, julo:jhi)
! Horizontal mass flux in N-S direction [hPa]
    REAL*8, INTENT(IN) :: ymass(ilo:ihi, julo:jhi)
!
! !INPUT/OUTPUT PARAMETERS:
!
! Species density [hPa]
    REAL*8, INTENT(INOUT) :: dq1(ilo:ihi, julo:jhi)
! Concentration contribution from N-S advection [mixing ratio]
    REAL*8, INTENT(INOUT) :: qqv(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! N-S flux [mixing ratio]
    REAL*8, INTENT(OUT) :: fy(ilo:ihi, julo:jhi+1)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il, ij
    INTEGER :: jv
    REAL*8 :: rj1p
! Arrays
    REAL*8 :: dcy(ilo:ihi, julo:jhi)
    INTRINSIC SIGN
!   ----------------
!   Begin execution.
!   ----------------
    dcy(:, :) = 0.0d0
    fy(:, :) = 0.0d0
    rj1p = j1p
!   ==============
    IF (jord .EQ. 1) THEN
!   ==============
      DO ij=j1p,j2p+1
        DO il=i1,i2
!c?
          jv = rj1p - cry(il, ij)
          qqv(il, ij) = qqu(il, jv)
        END DO
      END DO
    ELSE
!   ====
!   ====
!      ==========
!     ==========
      CALL YMIST(4, dcy, qqu, i1_gl, i2_gl, ju1_gl, j2_gl, j1p, ilo, ihi&
&          , julo, jhi, i1, i2, ju1, j2)
      IF (jord .LE. 0 .OR. jord .GE. 3) THEN
!         ==========
!         ==========
        CALL FYPPM(jlmt, cry, dcy, qqu, qqv, j1p, j2p, i1_gl, i2_gl, &
&            ju1_gl, j2_gl, ilong, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
      ELSE
        DO ij=j1p,j2p+1
          DO il=i1,i2
!c?
            jv = rj1p - cry(il, ij)
            qqv(il, ij) = qqu(il, jv) + (SIGN(1.0d0, cry(il, ij))-cry(il&
&             , ij))*dcy(il, jv)
          END DO
        END DO
      END IF
    END IF
!-----------------------------------------------------------------------
! Prior to 12/5/08:
! We need to add an outer IK loop for OpenMP parallelization.
! Preserve original code here (bmy, 12/5/08)
!do ij = j1p, j2p+1
!   qqv(i1:i2,ij,:) = qqv(i1:i2,ij,:) * ymass(i1:i2,ij,:)
!end do
! The IK loop is moved outside the subroutine (ccc, 4/1/09)
!-----------------------------------------------------------------------
    DO ij=j1p,j2p+1
      qqv(i1:i2, ij) = qqv(i1:i2, ij)*ymass(i1:i2, ij)
    END DO
!.sds.. save N-S species flux as diagnostic
    DO ij=i1,i2
      fy(ij, j1p:j2p+1) = qqv(ij, j1p:j2p+1)*geofac(j1p:j2p+1)
    END DO
!--------------------------------------------------------------------
! Prior to 12/5/08:
! We need to add an outer IK loop for OpenMP parallelization.
! Preserve original code here (bmy, 12/5/08)
!!... meridional flux update
!do ij = j1p, j2p
!
!   dq1(i1:i2,ij,:) =  &
!        dq1(i1:i2,ij,:) +  &
!        (qqv(i1:i2,ij,:) - qqv(i1:i2,ij+1,:)) * geofac(ij)
!
!end do
! The IK loop is moved outside the subroutine (ccc, 4/1/09)
!--------------------------------------------------------------------
!... meridional flux update
    DO ij=j1p,j2p
      dq1(i1:i2, ij) = dq1(i1:i2, ij) + (qqv(i1:i2, ij)-qqv(i1:i2, ij+1)&
&       )*geofac(ij)
    END DO
!   ====================
!   ====================
    CALL DO_YTP_POLE_SUM(geofac_pc, dq1, qqv, fy, i1_gl, i2_gl, ju1_gl, &
&                  j2_gl, j1p, j2p, ilo, ihi, julo, jhi, i1, i2, ju1, j2&
&                 )
  END SUBROUTINE YTP

!  Differentiation of ymist in forward (tangent) mode:
!   variations   of useful results: dcy
!   with respect to varying inputs: qqu
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Ymist
!
! !DESCRIPTION: Subroutine Ymist computes the linear tracer slope in the N-S
!  direction.  It uses the Lin et. al. 1994 algorithm.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE YMIST_D(id, dcy, dcyd, qqu, qqud, i1_gl, i2_gl, ju1_gl, &
&   j2_gl, j1p, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude index at the edge of the South polar cap
! J1P=JU1_GL+1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! The "order" of the accuracy in the computed linear "slope"
! (or mismatch, Lin et al. 1994); it is either 2 or 4.
    INTEGER, INTENT(IN) :: id
! Concentration contribution from E-W advection (mixing ratio)
    REAL*8, INTENT(IN) :: qqu(ilo:ihi, julo:jhi)
    REAL*8, INTENT(IN) :: qqud(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Slope of concentration distribution in N-S direction [mixing ratio]
    REAL*8, INTENT(OUT) :: dcy(ilo:ihi, julo:jhi)
    REAL*8, INTENT(OUT) :: dcyd(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il, ij
    REAL*8 :: pmax, pmin
    REAL*8 :: pmaxd, pmind
    REAL*8 :: r24
    REAL*8 :: tmp
    REAL*8 :: tmpd
! Arrays
! I suppose the values for these indexes are 0.
! It should work as the pole values are re-calculated in the
! pole functions. (ccc)
    REAL*8 :: qtmp(ilo:ihi, julo-2:jhi+2)
    REAL*8 :: qtmpd(ilo:ihi, julo-2:jhi+2)
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL*8 :: x1
    REAL*8 :: x1d
    REAL*8 :: x2
    REAL*8 :: x2d
    REAL*8 :: max1
    REAL*8 :: max1d
    REAL*8 :: min1
    REAL*8 :: min1d
    REAL*8 :: min2
    REAL*8 :: min2d
    REAL*8 :: max2
    REAL*8 :: max2d
    REAL*8 :: min3
    REAL*8 :: min3d
    REAL*8 :: min4
    REAL*8 :: min4d
!   ----------------
!   Begin execution.
!   ----------------
    r24 = 1.0d0/24.0d0
! Populate qtmp
    qtmp = 0.
    qtmpd = 0.0_8
    DO ij=ju1,j2
      qtmpd(:, ij) = qqud(:, ij)
      qtmp(:, ij) = qqu(:, ij)
    END DO
!   ============
    IF (id .EQ. 2) THEN
      dcyd = 0.0_8
!   ============
      DO ij=ju1-1,j2-1
        DO il=i1,i2
          tmpd = 0.25d0*(qtmpd(il, ij+2)-qtmpd(il, ij))
          tmp = 0.25d0*(qtmp(il, ij+2)-qtmp(il, ij))
          IF (qtmp(il, ij) .LT. qtmp(il, ij+1)) THEN
            IF (qtmp(il, ij+1) .LT. qtmp(il, ij+2)) THEN
              max1d = qtmpd(il, ij+2)
              max1 = qtmp(il, ij+2)
            ELSE
              max1d = qtmpd(il, ij+1)
              max1 = qtmp(il, ij+1)
            END IF
          ELSE IF (qtmp(il, ij) .LT. qtmp(il, ij+2)) THEN
            max1d = qtmpd(il, ij+2)
            max1 = qtmp(il, ij+2)
          ELSE
            max1d = qtmpd(il, ij)
            max1 = qtmp(il, ij)
          END IF
          pmaxd = max1d - qtmpd(il, ij+1)
          pmax = max1 - qtmp(il, ij+1)
          IF (qtmp(il, ij) .GT. qtmp(il, ij+1)) THEN
            IF (qtmp(il, ij+1) .GT. qtmp(il, ij+2)) THEN
              min1d = qtmpd(il, ij+2)
              min1 = qtmp(il, ij+2)
            ELSE
              min1d = qtmpd(il, ij+1)
              min1 = qtmp(il, ij+1)
            END IF
          ELSE IF (qtmp(il, ij) .GT. qtmp(il, ij+2)) THEN
            min1d = qtmpd(il, ij+2)
            min1 = qtmp(il, ij+2)
          ELSE
            min1d = qtmpd(il, ij)
            min1 = qtmp(il, ij)
          END IF
          pmind = qtmpd(il, ij+1) - min1d
          pmin = qtmp(il, ij+1) - min1
          IF (tmp .GE. 0.) THEN
            x1d = tmpd
            x1 = tmp
          ELSE
            x1d = -tmpd
            x1 = -tmp
          END IF
          IF (x1 .GT. pmin) THEN
            IF (pmin .GT. pmax) THEN
              min2d = pmaxd
              min2 = pmax
            ELSE
              min2d = pmind
              min2 = pmin
            END IF
          ELSE IF (x1 .GT. pmax) THEN
            min2d = pmaxd
            min2 = pmax
          ELSE
            min2d = x1d
            min2 = x1
          END IF
          dcyd(il, ij+1) = SIGN(1.d0, min2*tmp)*min2d
          dcy(il, ij+1) = SIGN(min2, tmp)
        END DO
      END DO
    ELSE
!   ====
!   ====
!      ========================
!      ========================
      CALL DO_YMIST_POLE1_I2D2_D(dcy, dcyd, qtmp, qtmpd, i1_gl, i2_gl, &
&                          ju1_gl, j2_gl, ilo, ihi, julo, jhi, i1, i2, &
&                          ju1, j2)
      DO ij=ju1-2,j2-2
        DO il=i1,i2
          tmpd = r24*(8.0d0*(qtmpd(il, ij+3)-qtmpd(il, ij+1))+qtmpd(il, &
&           ij)-qtmpd(il, ij+4))
          tmp = (8.0d0*(qtmp(il, ij+3)-qtmp(il, ij+1))+qtmp(il, ij)-qtmp&
&           (il, ij+4))*r24
          IF (qtmp(il, ij+1) .LT. qtmp(il, ij+2)) THEN
            IF (qtmp(il, ij+2) .LT. qtmp(il, ij+3)) THEN
              max2d = qtmpd(il, ij+3)
              max2 = qtmp(il, ij+3)
            ELSE
              max2d = qtmpd(il, ij+2)
              max2 = qtmp(il, ij+2)
            END IF
          ELSE IF (qtmp(il, ij+1) .LT. qtmp(il, ij+3)) THEN
            max2d = qtmpd(il, ij+3)
            max2 = qtmp(il, ij+3)
          ELSE
            max2d = qtmpd(il, ij+1)
            max2 = qtmp(il, ij+1)
          END IF
          pmaxd = max2d - qtmpd(il, ij+2)
          pmax = max2 - qtmp(il, ij+2)
          IF (qtmp(il, ij+1) .GT. qtmp(il, ij+2)) THEN
            IF (qtmp(il, ij+2) .GT. qtmp(il, ij+3)) THEN
              min3d = qtmpd(il, ij+3)
              min3 = qtmp(il, ij+3)
            ELSE
              min3d = qtmpd(il, ij+2)
              min3 = qtmp(il, ij+2)
            END IF
          ELSE IF (qtmp(il, ij+1) .GT. qtmp(il, ij+3)) THEN
            min3d = qtmpd(il, ij+3)
            min3 = qtmp(il, ij+3)
          ELSE
            min3d = qtmpd(il, ij+1)
            min3 = qtmp(il, ij+1)
          END IF
          pmind = qtmpd(il, ij+2) - min3d
          pmin = qtmp(il, ij+2) - min3
          IF (tmp .GE. 0.) THEN
            x2d = tmpd
            x2 = tmp
          ELSE
            x2d = -tmpd
            x2 = -tmp
          END IF
          IF (x2 .GT. pmin) THEN
            IF (pmin .GT. pmax) THEN
              min4d = pmaxd
              min4 = pmax
            ELSE
              min4d = pmind
              min4 = pmin
            END IF
          ELSE IF (x2 .GT. pmax) THEN
            min4d = pmaxd
            min4 = pmax
          ELSE
            min4d = x2d
            min4 = x2
          END IF
          dcyd(il, ij+2) = SIGN(1.d0, min4*tmp)*min4d
          dcy(il, ij+2) = SIGN(min4, tmp)
        END DO
      END DO
    END IF
!   ========================
!   ========================
    CALL DO_YMIST_POLE2_I2D2_D(dcy, dcyd, qtmp, qtmpd, i1_gl, i2_gl, &
&                        ju1_gl, j2_gl, j1p, ilo, ihi, julo, jhi, i1, i2&
&                        , ju1, j2)
  END SUBROUTINE YMIST_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Ymist
!
! !DESCRIPTION: Subroutine Ymist computes the linear tracer slope in the N-S
!  direction.  It uses the Lin et. al. 1994 algorithm.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE YMIST(id, dcy, qqu, i1_gl, i2_gl, ju1_gl, j2_gl, j1p, ilo, &
&   ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude index at the edge of the South polar cap
! J1P=JU1_GL+1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! The "order" of the accuracy in the computed linear "slope"
! (or mismatch, Lin et al. 1994); it is either 2 or 4.
    INTEGER, INTENT(IN) :: id
! Concentration contribution from E-W advection (mixing ratio)
    REAL*8, INTENT(IN) :: qqu(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Slope of concentration distribution in N-S direction [mixing ratio]
    REAL*8, INTENT(OUT) :: dcy(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il, ij
    REAL*8 :: pmax, pmin
    REAL*8 :: r24
    REAL*8 :: tmp
! Arrays
! I suppose the values for these indexes are 0.
! It should work as the pole values are re-calculated in the
! pole functions. (ccc)
    REAL*8 :: qtmp(ilo:ihi, julo-2:jhi+2)
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL*8 :: x1
    REAL*8 :: x2
    REAL*8 :: max1
    REAL*8 :: min1
    REAL*8 :: min2
    REAL*8 :: max2
    REAL*8 :: min3
    REAL*8 :: min4
!   ----------------
!   Begin execution.
!   ----------------
    r24 = 1.0d0/24.0d0
! Populate qtmp
    qtmp = 0.
    DO ij=ju1,j2
      qtmp(:, ij) = qqu(:, ij)
    END DO
!   ============
    IF (id .EQ. 2) THEN
!   ============
      DO ij=ju1-1,j2-1
        DO il=i1,i2
          tmp = 0.25d0*(qtmp(il, ij+2)-qtmp(il, ij))
          IF (qtmp(il, ij) .LT. qtmp(il, ij+1)) THEN
            IF (qtmp(il, ij+1) .LT. qtmp(il, ij+2)) THEN
              max1 = qtmp(il, ij+2)
            ELSE
              max1 = qtmp(il, ij+1)
            END IF
          ELSE IF (qtmp(il, ij) .LT. qtmp(il, ij+2)) THEN
            max1 = qtmp(il, ij+2)
          ELSE
            max1 = qtmp(il, ij)
          END IF
          pmax = max1 - qtmp(il, ij+1)
          IF (qtmp(il, ij) .GT. qtmp(il, ij+1)) THEN
            IF (qtmp(il, ij+1) .GT. qtmp(il, ij+2)) THEN
              min1 = qtmp(il, ij+2)
            ELSE
              min1 = qtmp(il, ij+1)
            END IF
          ELSE IF (qtmp(il, ij) .GT. qtmp(il, ij+2)) THEN
            min1 = qtmp(il, ij+2)
          ELSE
            min1 = qtmp(il, ij)
          END IF
          pmin = qtmp(il, ij+1) - min1
          IF (tmp .GE. 0.) THEN
            x1 = tmp
          ELSE
            x1 = -tmp
          END IF
          IF (x1 .GT. pmin) THEN
            IF (pmin .GT. pmax) THEN
              min2 = pmax
            ELSE
              min2 = pmin
            END IF
          ELSE IF (x1 .GT. pmax) THEN
            min2 = pmax
          ELSE
            min2 = x1
          END IF
          dcy(il, ij+1) = SIGN(min2, tmp)
        END DO
      END DO
    ELSE
!   ====
!   ====
!      ========================
!      ========================
      CALL DO_YMIST_POLE1_I2D2(dcy, qtmp, i1_gl, i2_gl, ju1_gl, j2_gl, &
&                        ilo, ihi, julo, jhi, i1, i2, ju1, j2)
      DO ij=ju1-2,j2-2
        DO il=i1,i2
          tmp = (8.0d0*(qtmp(il, ij+3)-qtmp(il, ij+1))+qtmp(il, ij)-qtmp&
&           (il, ij+4))*r24
          IF (qtmp(il, ij+1) .LT. qtmp(il, ij+2)) THEN
            IF (qtmp(il, ij+2) .LT. qtmp(il, ij+3)) THEN
              max2 = qtmp(il, ij+3)
            ELSE
              max2 = qtmp(il, ij+2)
            END IF
          ELSE IF (qtmp(il, ij+1) .LT. qtmp(il, ij+3)) THEN
            max2 = qtmp(il, ij+3)
          ELSE
            max2 = qtmp(il, ij+1)
          END IF
          pmax = max2 - qtmp(il, ij+2)
          IF (qtmp(il, ij+1) .GT. qtmp(il, ij+2)) THEN
            IF (qtmp(il, ij+2) .GT. qtmp(il, ij+3)) THEN
              min3 = qtmp(il, ij+3)
            ELSE
              min3 = qtmp(il, ij+2)
            END IF
          ELSE IF (qtmp(il, ij+1) .GT. qtmp(il, ij+3)) THEN
            min3 = qtmp(il, ij+3)
          ELSE
            min3 = qtmp(il, ij+1)
          END IF
          pmin = qtmp(il, ij+2) - min3
          IF (tmp .GE. 0.) THEN
            x2 = tmp
          ELSE
            x2 = -tmp
          END IF
          IF (x2 .GT. pmin) THEN
            IF (pmin .GT. pmax) THEN
              min4 = pmax
            ELSE
              min4 = pmin
            END IF
          ELSE IF (x2 .GT. pmax) THEN
            min4 = pmax
          ELSE
            min4 = x2
          END IF
          dcy(il, ij+2) = SIGN(min4, tmp)
        END DO
      END DO
    END IF
!   ========================
!   ========================
    CALL DO_YMIST_POLE2_I2D2(dcy, qtmp, i1_gl, i2_gl, ju1_gl, j2_gl, j1p&
&                      , ilo, ihi, julo, jhi, i1, i2, ju1, j2)
  END SUBROUTINE YMIST

!  Differentiation of do_ymist_pole1_i2d2 in forward (tangent) mode:
!   variations   of useful results: dcy
!   with respect to varying inputs: qqu
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Do_Ymist_Pole1_I2d2
!
! !DESCRIPTION: Subroutine Do\_Ymist\_Pole1\_I2d2 sets "dcy" at the Poles.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE DO_YMIST_POLE1_I2D2_D(dcy, dcyd, qqu, qqud, i1_gl, i2_gl, &
&   ju1_gl, j2_gl, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!   ======
!   ======
!
! !INPUT PARAMETERS:
!
! Global min & max longitude (I) and latitude (J) indices
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Concentration contribution from E-W advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqu(ilo:ihi, julo-2:jhi+2)
    REAL*8, INTENT(IN) :: qqud(ilo:ihi, julo-2:jhi+2)
!
! !OUTPUT PARAMETERS:
!
! Slope of concentration distribution in N-S direction [mixing ratio]
    REAL*8, INTENT(OUT) :: dcy(ilo:ihi, julo:jhi)
    REAL*8, INTENT(OUT) :: dcyd(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
    INTEGER :: i2d2
    INTEGER :: il
    REAL*8 :: pmax, pmin
    REAL*8 :: pmaxd, pmind
    REAL*8 :: r24
    REAL*8 :: tmp
    REAL*8 :: tmpd
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL*8 :: x1
    REAL*8 :: x1d
    REAL*8 :: x2
    REAL*8 :: x2d
    REAL*8 :: x3
    REAL*8 :: x3d
    REAL*8 :: x4
    REAL*8 :: x4d
    REAL*8 :: max1
    REAL*8 :: max1d
    REAL*8 :: min1
    REAL*8 :: min1d
    REAL*8 :: min2
    REAL*8 :: min2d
    REAL*8 :: max2
    REAL*8 :: max2d
    REAL*8 :: min3
    REAL*8 :: min3d
    REAL*8 :: min4
    REAL*8 :: min4d
    REAL*8 :: max3
    REAL*8 :: max3d
    REAL*8 :: min5
    REAL*8 :: min5d
    REAL*8 :: min6
    REAL*8 :: min6d
    REAL*8 :: max4
    REAL*8 :: max4d
    REAL*8 :: min7
    REAL*8 :: min7d
    REAL*8 :: min8
    REAL*8 :: min8d
!   ----------------
!   Begin execution.
!   ----------------
    i2d2 = i2_gl/2
    r24 = 1.0d0/24.0d0
!   ==================
    IF (ju1 .EQ. ju1_gl) THEN
      dcyd = 0.0_8
!   ==================
      DO il=i1,i2d2
        tmpd = r24*(8.0d0*(qqud(il, ju1+2)-qqud(il, ju1))+qqud(il+i2d2, &
&         ju1+1)-qqud(il, ju1+3))
        tmp = (8.0d0*(qqu(il, ju1+2)-qqu(il, ju1))+qqu(il+i2d2, ju1+1)-&
&         qqu(il, ju1+3))*r24
        IF (qqu(il, ju1) .LT. qqu(il, ju1+1)) THEN
          IF (qqu(il, ju1+1) .LT. qqu(il, ju1+2)) THEN
            max1d = qqud(il, ju1+2)
            max1 = qqu(il, ju1+2)
          ELSE
            max1d = qqud(il, ju1+1)
            max1 = qqu(il, ju1+1)
          END IF
        ELSE IF (qqu(il, ju1) .LT. qqu(il, ju1+2)) THEN
          max1d = qqud(il, ju1+2)
          max1 = qqu(il, ju1+2)
        ELSE
          max1d = qqud(il, ju1)
          max1 = qqu(il, ju1)
        END IF
        pmaxd = max1d - qqud(il, ju1+1)
        pmax = max1 - qqu(il, ju1+1)
        IF (qqu(il, ju1) .GT. qqu(il, ju1+1)) THEN
          IF (qqu(il, ju1+1) .GT. qqu(il, ju1+2)) THEN
            min1d = qqud(il, ju1+2)
            min1 = qqu(il, ju1+2)
          ELSE
            min1d = qqud(il, ju1+1)
            min1 = qqu(il, ju1+1)
          END IF
        ELSE IF (qqu(il, ju1) .GT. qqu(il, ju1+2)) THEN
          min1d = qqud(il, ju1+2)
          min1 = qqu(il, ju1+2)
        ELSE
          min1d = qqud(il, ju1)
          min1 = qqu(il, ju1)
        END IF
        pmind = qqud(il, ju1+1) - min1d
        pmin = qqu(il, ju1+1) - min1
        IF (tmp .GE. 0.) THEN
          x1d = tmpd
          x1 = tmp
        ELSE
          x1d = -tmpd
          x1 = -tmp
        END IF
        IF (x1 .GT. pmin) THEN
          IF (pmin .GT. pmax) THEN
            min2d = pmaxd
            min2 = pmax
          ELSE
            min2d = pmind
            min2 = pmin
          END IF
        ELSE IF (x1 .GT. pmax) THEN
          min2d = pmaxd
          min2 = pmax
        ELSE
          min2d = x1d
          min2 = x1
        END IF
        dcyd(il, ju1+1) = SIGN(1.d0, min2*tmp)*min2d
        dcy(il, ju1+1) = SIGN(min2, tmp)
      END DO
      DO il=i1+i2d2,i2
        tmpd = r24*(8.0d0*(qqud(il, ju1+2)-qqud(il, ju1))+qqud(il-i2d2, &
&         ju1+1)-qqud(il, ju1+3))
        tmp = (8.0d0*(qqu(il, ju1+2)-qqu(il, ju1))+qqu(il-i2d2, ju1+1)-&
&         qqu(il, ju1+3))*r24
        IF (qqu(il, ju1) .LT. qqu(il, ju1+1)) THEN
          IF (qqu(il, ju1+1) .LT. qqu(il, ju1+2)) THEN
            max2d = qqud(il, ju1+2)
            max2 = qqu(il, ju1+2)
          ELSE
            max2d = qqud(il, ju1+1)
            max2 = qqu(il, ju1+1)
          END IF
        ELSE IF (qqu(il, ju1) .LT. qqu(il, ju1+2)) THEN
          max2d = qqud(il, ju1+2)
          max2 = qqu(il, ju1+2)
        ELSE
          max2d = qqud(il, ju1)
          max2 = qqu(il, ju1)
        END IF
        pmaxd = max2d - qqud(il, ju1+1)
        pmax = max2 - qqu(il, ju1+1)
        IF (qqu(il, ju1) .GT. qqu(il, ju1+1)) THEN
          IF (qqu(il, ju1+1) .GT. qqu(il, ju1+2)) THEN
            min3d = qqud(il, ju1+2)
            min3 = qqu(il, ju1+2)
          ELSE
            min3d = qqud(il, ju1+1)
            min3 = qqu(il, ju1+1)
          END IF
        ELSE IF (qqu(il, ju1) .GT. qqu(il, ju1+2)) THEN
          min3d = qqud(il, ju1+2)
          min3 = qqu(il, ju1+2)
        ELSE
          min3d = qqud(il, ju1)
          min3 = qqu(il, ju1)
        END IF
        pmind = qqud(il, ju1+1) - min3d
        pmin = qqu(il, ju1+1) - min3
        IF (tmp .GE. 0.) THEN
          x2d = tmpd
          x2 = tmp
        ELSE
          x2d = -tmpd
          x2 = -tmp
        END IF
        IF (x2 .GT. pmin) THEN
          IF (pmin .GT. pmax) THEN
            min4d = pmaxd
            min4 = pmax
          ELSE
            min4d = pmind
            min4 = pmin
          END IF
        ELSE IF (x2 .GT. pmax) THEN
          min4d = pmaxd
          min4 = pmax
        ELSE
          min4d = x2d
          min4 = x2
        END IF
        dcyd(il, ju1+1) = SIGN(1.d0, min4*tmp)*min4d
        dcy(il, ju1+1) = SIGN(min4, tmp)
      END DO
    ELSE
      dcyd = 0.0_8
    END IF
!   ======
!   ======
!   ================
    IF (j2 .EQ. j2_gl) THEN
!   ================
      DO il=i1,i2d2
        tmpd = r24*(8.0d0*(qqud(il, j2)-qqud(il, j2-2))+qqud(il, j2-3)-&
&         qqud(il+i2d2, j2-1))
        tmp = (8.0d0*(qqu(il, j2)-qqu(il, j2-2))+qqu(il, j2-3)-qqu(il+&
&         i2d2, j2-1))*r24
        IF (qqu(il, j2-2) .LT. qqu(il, j2-1)) THEN
          IF (qqu(il, j2-1) .LT. qqu(il, j2)) THEN
            max3d = qqud(il, j2)
            max3 = qqu(il, j2)
          ELSE
            max3d = qqud(il, j2-1)
            max3 = qqu(il, j2-1)
          END IF
        ELSE IF (qqu(il, j2-2) .LT. qqu(il, j2)) THEN
          max3d = qqud(il, j2)
          max3 = qqu(il, j2)
        ELSE
          max3d = qqud(il, j2-2)
          max3 = qqu(il, j2-2)
        END IF
        pmaxd = max3d - qqud(il, j2-1)
        pmax = max3 - qqu(il, j2-1)
        IF (qqu(il, j2-2) .GT. qqu(il, j2-1)) THEN
          IF (qqu(il, j2-1) .GT. qqu(il, j2)) THEN
            min5d = qqud(il, j2)
            min5 = qqu(il, j2)
          ELSE
            min5d = qqud(il, j2-1)
            min5 = qqu(il, j2-1)
          END IF
        ELSE IF (qqu(il, j2-2) .GT. qqu(il, j2)) THEN
          min5d = qqud(il, j2)
          min5 = qqu(il, j2)
        ELSE
          min5d = qqud(il, j2-2)
          min5 = qqu(il, j2-2)
        END IF
        pmind = qqud(il, j2-1) - min5d
        pmin = qqu(il, j2-1) - min5
        IF (tmp .GE. 0.) THEN
          x3d = tmpd
          x3 = tmp
        ELSE
          x3d = -tmpd
          x3 = -tmp
        END IF
        IF (x3 .GT. pmin) THEN
          IF (pmin .GT. pmax) THEN
            min6d = pmaxd
            min6 = pmax
          ELSE
            min6d = pmind
            min6 = pmin
          END IF
        ELSE IF (x3 .GT. pmax) THEN
          min6d = pmaxd
          min6 = pmax
        ELSE
          min6d = x3d
          min6 = x3
        END IF
        dcyd(il, j2-1) = SIGN(1.d0, min6*tmp)*min6d
        dcy(il, j2-1) = SIGN(min6, tmp)
      END DO
      DO il=i1+i2d2,i2
        tmpd = r24*(8.0d0*(qqud(il, j2)-qqud(il, j2-2))+qqud(il, j2-3)-&
&         qqud(il-i2d2, j2-1))
        tmp = (8.0d0*(qqu(il, j2)-qqu(il, j2-2))+qqu(il, j2-3)-qqu(il-&
&         i2d2, j2-1))*r24
        IF (qqu(il, j2-2) .LT. qqu(il, j2-1)) THEN
          IF (qqu(il, j2-1) .LT. qqu(il, j2)) THEN
            max4d = qqud(il, j2)
            max4 = qqu(il, j2)
          ELSE
            max4d = qqud(il, j2-1)
            max4 = qqu(il, j2-1)
          END IF
        ELSE IF (qqu(il, j2-2) .LT. qqu(il, j2)) THEN
          max4d = qqud(il, j2)
          max4 = qqu(il, j2)
        ELSE
          max4d = qqud(il, j2-2)
          max4 = qqu(il, j2-2)
        END IF
        pmaxd = max4d - qqud(il, j2-1)
        pmax = max4 - qqu(il, j2-1)
        IF (qqu(il, j2-2) .GT. qqu(il, j2-1)) THEN
          IF (qqu(il, j2-1) .GT. qqu(il, j2)) THEN
            min7d = qqud(il, j2)
            min7 = qqu(il, j2)
          ELSE
            min7d = qqud(il, j2-1)
            min7 = qqu(il, j2-1)
          END IF
        ELSE IF (qqu(il, j2-2) .GT. qqu(il, j2)) THEN
          min7d = qqud(il, j2)
          min7 = qqu(il, j2)
        ELSE
          min7d = qqud(il, j2-2)
          min7 = qqu(il, j2-2)
        END IF
        pmind = qqud(il, j2-1) - min7d
        pmin = qqu(il, j2-1) - min7
        IF (tmp .GE. 0.) THEN
          x4d = tmpd
          x4 = tmp
        ELSE
          x4d = -tmpd
          x4 = -tmp
        END IF
        IF (x4 .GT. pmin) THEN
          IF (pmin .GT. pmax) THEN
            min8d = pmaxd
            min8 = pmax
          ELSE
            min8d = pmind
            min8 = pmin
          END IF
        ELSE IF (x4 .GT. pmax) THEN
          min8d = pmaxd
          min8 = pmax
        ELSE
          min8d = x4d
          min8 = x4
        END IF
        dcyd(il, j2-1) = SIGN(1.d0, min8*tmp)*min8d
        dcy(il, j2-1) = SIGN(min8, tmp)
      END DO
    END IF
  END SUBROUTINE DO_YMIST_POLE1_I2D2_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Do_Ymist_Pole1_I2d2
!
! !DESCRIPTION: Subroutine Do\_Ymist\_Pole1\_I2d2 sets "dcy" at the Poles.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE DO_YMIST_POLE1_I2D2(dcy, qqu, i1_gl, i2_gl, ju1_gl, j2_gl, &
&   ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!   ======
!   ======
!
! !INPUT PARAMETERS:
!
! Global min & max longitude (I) and latitude (J) indices
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Concentration contribution from E-W advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqu(ilo:ihi, julo-2:jhi+2)
!
! !OUTPUT PARAMETERS:
!
! Slope of concentration distribution in N-S direction [mixing ratio]
    REAL*8, INTENT(OUT) :: dcy(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
    INTEGER :: i2d2
    INTEGER :: il
    REAL*8 :: pmax, pmin
    REAL*8 :: r24
    REAL*8 :: tmp
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL*8 :: x1
    REAL*8 :: x2
    REAL*8 :: x3
    REAL*8 :: x4
    REAL*8 :: max1
    REAL*8 :: min1
    REAL*8 :: min2
    REAL*8 :: max2
    REAL*8 :: min3
    REAL*8 :: min4
    REAL*8 :: max3
    REAL*8 :: min5
    REAL*8 :: min6
    REAL*8 :: max4
    REAL*8 :: min7
    REAL*8 :: min8
!   ----------------
!   Begin execution.
!   ----------------
    i2d2 = i2_gl/2
    r24 = 1.0d0/24.0d0
!   ==================
    IF (ju1 .EQ. ju1_gl) THEN
!   ==================
      DO il=i1,i2d2
        tmp = (8.0d0*(qqu(il, ju1+2)-qqu(il, ju1))+qqu(il+i2d2, ju1+1)-&
&         qqu(il, ju1+3))*r24
        IF (qqu(il, ju1) .LT. qqu(il, ju1+1)) THEN
          IF (qqu(il, ju1+1) .LT. qqu(il, ju1+2)) THEN
            max1 = qqu(il, ju1+2)
          ELSE
            max1 = qqu(il, ju1+1)
          END IF
        ELSE IF (qqu(il, ju1) .LT. qqu(il, ju1+2)) THEN
          max1 = qqu(il, ju1+2)
        ELSE
          max1 = qqu(il, ju1)
        END IF
        pmax = max1 - qqu(il, ju1+1)
        IF (qqu(il, ju1) .GT. qqu(il, ju1+1)) THEN
          IF (qqu(il, ju1+1) .GT. qqu(il, ju1+2)) THEN
            min1 = qqu(il, ju1+2)
          ELSE
            min1 = qqu(il, ju1+1)
          END IF
        ELSE IF (qqu(il, ju1) .GT. qqu(il, ju1+2)) THEN
          min1 = qqu(il, ju1+2)
        ELSE
          min1 = qqu(il, ju1)
        END IF
        pmin = qqu(il, ju1+1) - min1
        IF (tmp .GE. 0.) THEN
          x1 = tmp
        ELSE
          x1 = -tmp
        END IF
        IF (x1 .GT. pmin) THEN
          IF (pmin .GT. pmax) THEN
            min2 = pmax
          ELSE
            min2 = pmin
          END IF
        ELSE IF (x1 .GT. pmax) THEN
          min2 = pmax
        ELSE
          min2 = x1
        END IF
        dcy(il, ju1+1) = SIGN(min2, tmp)
      END DO
      DO il=i1+i2d2,i2
        tmp = (8.0d0*(qqu(il, ju1+2)-qqu(il, ju1))+qqu(il-i2d2, ju1+1)-&
&         qqu(il, ju1+3))*r24
        IF (qqu(il, ju1) .LT. qqu(il, ju1+1)) THEN
          IF (qqu(il, ju1+1) .LT. qqu(il, ju1+2)) THEN
            max2 = qqu(il, ju1+2)
          ELSE
            max2 = qqu(il, ju1+1)
          END IF
        ELSE IF (qqu(il, ju1) .LT. qqu(il, ju1+2)) THEN
          max2 = qqu(il, ju1+2)
        ELSE
          max2 = qqu(il, ju1)
        END IF
        pmax = max2 - qqu(il, ju1+1)
        IF (qqu(il, ju1) .GT. qqu(il, ju1+1)) THEN
          IF (qqu(il, ju1+1) .GT. qqu(il, ju1+2)) THEN
            min3 = qqu(il, ju1+2)
          ELSE
            min3 = qqu(il, ju1+1)
          END IF
        ELSE IF (qqu(il, ju1) .GT. qqu(il, ju1+2)) THEN
          min3 = qqu(il, ju1+2)
        ELSE
          min3 = qqu(il, ju1)
        END IF
        pmin = qqu(il, ju1+1) - min3
        IF (tmp .GE. 0.) THEN
          x2 = tmp
        ELSE
          x2 = -tmp
        END IF
        IF (x2 .GT. pmin) THEN
          IF (pmin .GT. pmax) THEN
            min4 = pmax
          ELSE
            min4 = pmin
          END IF
        ELSE IF (x2 .GT. pmax) THEN
          min4 = pmax
        ELSE
          min4 = x2
        END IF
        dcy(il, ju1+1) = SIGN(min4, tmp)
      END DO
    END IF
!   ======
!   ======
!   ================
    IF (j2 .EQ. j2_gl) THEN
!   ================
      DO il=i1,i2d2
        tmp = (8.0d0*(qqu(il, j2)-qqu(il, j2-2))+qqu(il, j2-3)-qqu(il+&
&         i2d2, j2-1))*r24
        IF (qqu(il, j2-2) .LT. qqu(il, j2-1)) THEN
          IF (qqu(il, j2-1) .LT. qqu(il, j2)) THEN
            max3 = qqu(il, j2)
          ELSE
            max3 = qqu(il, j2-1)
          END IF
        ELSE IF (qqu(il, j2-2) .LT. qqu(il, j2)) THEN
          max3 = qqu(il, j2)
        ELSE
          max3 = qqu(il, j2-2)
        END IF
        pmax = max3 - qqu(il, j2-1)
        IF (qqu(il, j2-2) .GT. qqu(il, j2-1)) THEN
          IF (qqu(il, j2-1) .GT. qqu(il, j2)) THEN
            min5 = qqu(il, j2)
          ELSE
            min5 = qqu(il, j2-1)
          END IF
        ELSE IF (qqu(il, j2-2) .GT. qqu(il, j2)) THEN
          min5 = qqu(il, j2)
        ELSE
          min5 = qqu(il, j2-2)
        END IF
        pmin = qqu(il, j2-1) - min5
        IF (tmp .GE. 0.) THEN
          x3 = tmp
        ELSE
          x3 = -tmp
        END IF
        IF (x3 .GT. pmin) THEN
          IF (pmin .GT. pmax) THEN
            min6 = pmax
          ELSE
            min6 = pmin
          END IF
        ELSE IF (x3 .GT. pmax) THEN
          min6 = pmax
        ELSE
          min6 = x3
        END IF
        dcy(il, j2-1) = SIGN(min6, tmp)
      END DO
      DO il=i1+i2d2,i2
        tmp = (8.0d0*(qqu(il, j2)-qqu(il, j2-2))+qqu(il, j2-3)-qqu(il-&
&         i2d2, j2-1))*r24
        IF (qqu(il, j2-2) .LT. qqu(il, j2-1)) THEN
          IF (qqu(il, j2-1) .LT. qqu(il, j2)) THEN
            max4 = qqu(il, j2)
          ELSE
            max4 = qqu(il, j2-1)
          END IF
        ELSE IF (qqu(il, j2-2) .LT. qqu(il, j2)) THEN
          max4 = qqu(il, j2)
        ELSE
          max4 = qqu(il, j2-2)
        END IF
        pmax = max4 - qqu(il, j2-1)
        IF (qqu(il, j2-2) .GT. qqu(il, j2-1)) THEN
          IF (qqu(il, j2-1) .GT. qqu(il, j2)) THEN
            min7 = qqu(il, j2)
          ELSE
            min7 = qqu(il, j2-1)
          END IF
        ELSE IF (qqu(il, j2-2) .GT. qqu(il, j2)) THEN
          min7 = qqu(il, j2)
        ELSE
          min7 = qqu(il, j2-2)
        END IF
        pmin = qqu(il, j2-1) - min7
        IF (tmp .GE. 0.) THEN
          x4 = tmp
        ELSE
          x4 = -tmp
        END IF
        IF (x4 .GT. pmin) THEN
          IF (pmin .GT. pmax) THEN
            min8 = pmax
          ELSE
            min8 = pmin
          END IF
        ELSE IF (x4 .GT. pmax) THEN
          min8 = pmax
        ELSE
          min8 = x4
        END IF
        dcy(il, j2-1) = SIGN(min8, tmp)
      END DO
    END IF
  END SUBROUTINE DO_YMIST_POLE1_I2D2

!  Differentiation of do_ymist_pole2_i2d2 in forward (tangent) mode:
!   variations   of useful results: dcy
!   with respect to varying inputs: qqu dcy
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Do_Ymist_Pole2_I2d2
!
! !DESCRIPTION: Subroutine Do\_Ymist\_Pole2\_I2d2 sets "dcy" at the Poles.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE DO_YMIST_POLE2_I2D2_D(dcy, dcyd, qqu, qqud, i1_gl, i2_gl, &
&   ju1_gl, j2_gl, j1p, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!   ======
!   ======
!
! !INPUT PARAMETERS:
!
! Global latitude index at the edge of the South polar cap
! J1P=JU1_GL+1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Concentration contribution from E-W advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqu(ilo:ihi, julo-2:jhi+2)
    REAL*8, INTENT(IN) :: qqud(ilo:ihi, julo-2:jhi+2)
!
! !OUTPUT PARAMETERS:
!
! Slope of concentration distribution in N-S direction [mixing ratio]
    REAL*8, INTENT(OUT) :: dcy(ilo:ihi, julo:jhi)
    REAL*8, INTENT(OUT) :: dcyd(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: i2d2
    INTEGER :: il
    REAL*8 :: pmax, pmin
    REAL*8 :: pmaxd, pmind
    REAL*8 :: tmp
    REAL*8 :: tmpd
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL*8 :: x1
    REAL*8 :: x1d
    REAL*8 :: x2
    REAL*8 :: x2d
    REAL*8 :: max1
    REAL*8 :: max1d
    REAL*8 :: min1
    REAL*8 :: min1d
    REAL*8 :: min2
    REAL*8 :: min2d
    REAL*8 :: max2
    REAL*8 :: max2d
    REAL*8 :: min3
    REAL*8 :: min3d
    REAL*8 :: min4
    REAL*8 :: min4d
!   ----------------
!   Begin execution.
!   ----------------
    i2d2 = i2_gl/2
!   ==================
    IF (ju1 .EQ. ju1_gl) THEN
!   ==================
      IF (j1p .NE. ju1_gl + 1) THEN
        dcyd(i1:i2, ju1) = 0.0_8
        dcy(i1:i2, ju1) = 0.0d0
      ELSE
!         -----------------------------------------------
!         Determine slope in South Polar cap for scalars.
!         -----------------------------------------------
        DO il=i1,i2d2
          tmpd = 0.25d0*(qqud(il, ju1+1)-qqud(il+i2d2, ju1+1))
          tmp = 0.25d0*(qqu(il, ju1+1)-qqu(il+i2d2, ju1+1))
          IF (qqu(il, ju1+1) .LT. qqu(il, ju1)) THEN
            IF (qqu(il, ju1) .LT. qqu(il+i2d2, ju1+1)) THEN
              max1d = qqud(il+i2d2, ju1+1)
              max1 = qqu(il+i2d2, ju1+1)
            ELSE
              max1d = qqud(il, ju1)
              max1 = qqu(il, ju1)
            END IF
          ELSE IF (qqu(il, ju1+1) .LT. qqu(il+i2d2, ju1+1)) THEN
            max1d = qqud(il+i2d2, ju1+1)
            max1 = qqu(il+i2d2, ju1+1)
          ELSE
            max1d = qqud(il, ju1+1)
            max1 = qqu(il, ju1+1)
          END IF
          pmaxd = max1d - qqud(il, ju1)
          pmax = max1 - qqu(il, ju1)
          IF (qqu(il, ju1+1) .GT. qqu(il, ju1)) THEN
            IF (qqu(il, ju1) .GT. qqu(il+i2d2, ju1+1)) THEN
              min1d = qqud(il+i2d2, ju1+1)
              min1 = qqu(il+i2d2, ju1+1)
            ELSE
              min1d = qqud(il, ju1)
              min1 = qqu(il, ju1)
            END IF
          ELSE IF (qqu(il, ju1+1) .GT. qqu(il+i2d2, ju1+1)) THEN
            min1d = qqud(il+i2d2, ju1+1)
            min1 = qqu(il+i2d2, ju1+1)
          ELSE
            min1d = qqud(il, ju1+1)
            min1 = qqu(il, ju1+1)
          END IF
          pmind = qqud(il, ju1) - min1d
          pmin = qqu(il, ju1) - min1
          IF (tmp .GE. 0.) THEN
            x1d = tmpd
            x1 = tmp
          ELSE
            x1d = -tmpd
            x1 = -tmp
          END IF
          IF (x1 .GT. pmax) THEN
            IF (pmax .GT. pmin) THEN
              min2d = pmind
              min2 = pmin
            ELSE
              min2d = pmaxd
              min2 = pmax
            END IF
          ELSE IF (x1 .GT. pmin) THEN
            min2d = pmind
            min2 = pmin
          ELSE
            min2d = x1d
            min2 = x1
          END IF
          dcyd(il, ju1) = SIGN(1.d0, min2*tmp)*min2d
          dcy(il, ju1) = SIGN(min2, tmp)
        END DO
!----------------------------------------------------------------
! Prior to 12/5/08:
! We need to add and outer IK loop for OpenMP parallelization.
! Preserve original code here (bmy, 12/5/08)
!do il = i1 + i2d2, i2
!   dcy(il,ju1,:) = -dcy(il-i2d2,ju1,:)
!end do
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!----------------------------------------------------------------
        DO il=i1+i2d2,i2
          dcyd(il, ju1) = -dcyd(il-i2d2, ju1)
          dcy(il, ju1) = -dcy(il-i2d2, ju1)
        END DO
      END IF
    END IF
!   ======
!   ======
!   ================
    IF (j2 .EQ. j2_gl) THEN
!   ================
      IF (j1p .NE. ju1_gl + 1) THEN
        dcyd(i1:i2, j2) = 0.0_8
        dcy(i1:i2, j2) = 0.0d0
      ELSE
!         -----------------------------------------------
!         Determine slope in North Polar cap for scalars.
!         -----------------------------------------------
        DO il=i1,i2d2
          tmpd = 0.25d0*(qqud(il+i2d2, j2-1)-qqud(il, j2-1))
          tmp = 0.25d0*(qqu(il+i2d2, j2-1)-qqu(il, j2-1))
          IF (qqu(il+i2d2, j2-1) .LT. qqu(il, j2)) THEN
            IF (qqu(il, j2) .LT. qqu(il, j2-1)) THEN
              max2d = qqud(il, j2-1)
              max2 = qqu(il, j2-1)
            ELSE
              max2d = qqud(il, j2)
              max2 = qqu(il, j2)
            END IF
          ELSE IF (qqu(il+i2d2, j2-1) .LT. qqu(il, j2-1)) THEN
            max2d = qqud(il, j2-1)
            max2 = qqu(il, j2-1)
          ELSE
            max2d = qqud(il+i2d2, j2-1)
            max2 = qqu(il+i2d2, j2-1)
          END IF
          pmaxd = max2d - qqud(il, j2)
          pmax = max2 - qqu(il, j2)
          IF (qqu(il+i2d2, j2-1) .GT. qqu(il, j2)) THEN
            IF (qqu(il, j2) .GT. qqu(il, j2-1)) THEN
              min3d = qqud(il, j2-1)
              min3 = qqu(il, j2-1)
            ELSE
              min3d = qqud(il, j2)
              min3 = qqu(il, j2)
            END IF
          ELSE IF (qqu(il+i2d2, j2-1) .GT. qqu(il, j2-1)) THEN
            min3d = qqud(il, j2-1)
            min3 = qqu(il, j2-1)
          ELSE
            min3d = qqud(il+i2d2, j2-1)
            min3 = qqu(il+i2d2, j2-1)
          END IF
          pmind = qqud(il, j2) - min3d
          pmin = qqu(il, j2) - min3
          IF (tmp .GE. 0.) THEN
            x2d = tmpd
            x2 = tmp
          ELSE
            x2d = -tmpd
            x2 = -tmp
          END IF
          IF (x2 .GT. pmax) THEN
            IF (pmax .GT. pmin) THEN
              min4d = pmind
              min4 = pmin
            ELSE
              min4d = pmaxd
              min4 = pmax
            END IF
          ELSE IF (x2 .GT. pmin) THEN
            min4d = pmind
            min4 = pmin
          ELSE
            min4d = x2d
            min4 = x2
          END IF
          dcyd(il, j2) = SIGN(1.d0, min4*tmp)*min4d
          dcy(il, j2) = SIGN(min4, tmp)
        END DO
!----------------------------------------------------------------
! Prior to 12/5/08:
! We need to add and outer IK loop for OpenMP parallelization.
! Preserve original code here (bmy, 12/5/08)
!do il = i1 + i2d2, i2
!   dcy(il,j2,:) = -dcy(il-i2d2,j2,:)
!end do
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!----------------------------------------------------------------
        DO il=i1+i2d2,i2
          dcyd(il, j2) = -dcyd(il-i2d2, j2)
          dcy(il, j2) = -dcy(il-i2d2, j2)
        END DO
      END IF
    END IF
  END SUBROUTINE DO_YMIST_POLE2_I2D2_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Do_Ymist_Pole2_I2d2
!
! !DESCRIPTION: Subroutine Do\_Ymist\_Pole2\_I2d2 sets "dcy" at the Poles.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE DO_YMIST_POLE2_I2D2(dcy, qqu, i1_gl, i2_gl, ju1_gl, j2_gl, &
&   j1p, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!   ======
!   ======
!
! !INPUT PARAMETERS:
!
! Global latitude index at the edge of the South polar cap
! J1P=JU1_GL+1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Concentration contribution from E-W advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqu(ilo:ihi, julo-2:jhi+2)
!
! !OUTPUT PARAMETERS:
!
! Slope of concentration distribution in N-S direction [mixing ratio]
    REAL*8, INTENT(OUT) :: dcy(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: i2d2
    INTEGER :: il
    REAL*8 :: pmax, pmin
    REAL*8 :: tmp
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL*8 :: x1
    REAL*8 :: x2
    REAL*8 :: max1
    REAL*8 :: min1
    REAL*8 :: min2
    REAL*8 :: max2
    REAL*8 :: min3
    REAL*8 :: min4
!   ----------------
!   Begin execution.
!   ----------------
    i2d2 = i2_gl/2
!   ==================
    IF (ju1 .EQ. ju1_gl) THEN
!   ==================
      IF (j1p .NE. ju1_gl + 1) THEN
        dcy(i1:i2, ju1) = 0.0d0
      ELSE
!         -----------------------------------------------
!         Determine slope in South Polar cap for scalars.
!         -----------------------------------------------
        DO il=i1,i2d2
          tmp = 0.25d0*(qqu(il, ju1+1)-qqu(il+i2d2, ju1+1))
          IF (qqu(il, ju1+1) .LT. qqu(il, ju1)) THEN
            IF (qqu(il, ju1) .LT. qqu(il+i2d2, ju1+1)) THEN
              max1 = qqu(il+i2d2, ju1+1)
            ELSE
              max1 = qqu(il, ju1)
            END IF
          ELSE IF (qqu(il, ju1+1) .LT. qqu(il+i2d2, ju1+1)) THEN
            max1 = qqu(il+i2d2, ju1+1)
          ELSE
            max1 = qqu(il, ju1+1)
          END IF
          pmax = max1 - qqu(il, ju1)
          IF (qqu(il, ju1+1) .GT. qqu(il, ju1)) THEN
            IF (qqu(il, ju1) .GT. qqu(il+i2d2, ju1+1)) THEN
              min1 = qqu(il+i2d2, ju1+1)
            ELSE
              min1 = qqu(il, ju1)
            END IF
          ELSE IF (qqu(il, ju1+1) .GT. qqu(il+i2d2, ju1+1)) THEN
            min1 = qqu(il+i2d2, ju1+1)
          ELSE
            min1 = qqu(il, ju1+1)
          END IF
          pmin = qqu(il, ju1) - min1
          IF (tmp .GE. 0.) THEN
            x1 = tmp
          ELSE
            x1 = -tmp
          END IF
          IF (x1 .GT. pmax) THEN
            IF (pmax .GT. pmin) THEN
              min2 = pmin
            ELSE
              min2 = pmax
            END IF
          ELSE IF (x1 .GT. pmin) THEN
            min2 = pmin
          ELSE
            min2 = x1
          END IF
          dcy(il, ju1) = SIGN(min2, tmp)
        END DO
!----------------------------------------------------------------
! Prior to 12/5/08:
! We need to add and outer IK loop for OpenMP parallelization.
! Preserve original code here (bmy, 12/5/08)
!do il = i1 + i2d2, i2
!   dcy(il,ju1,:) = -dcy(il-i2d2,ju1,:)
!end do
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!----------------------------------------------------------------
        DO il=i1+i2d2,i2
          dcy(il, ju1) = -dcy(il-i2d2, ju1)
        END DO
      END IF
    END IF
!   ======
!   ======
!   ================
    IF (j2 .EQ. j2_gl) THEN
!   ================
      IF (j1p .NE. ju1_gl + 1) THEN
        dcy(i1:i2, j2) = 0.0d0
      ELSE
!         -----------------------------------------------
!         Determine slope in North Polar cap for scalars.
!         -----------------------------------------------
        DO il=i1,i2d2
          tmp = 0.25d0*(qqu(il+i2d2, j2-1)-qqu(il, j2-1))
          IF (qqu(il+i2d2, j2-1) .LT. qqu(il, j2)) THEN
            IF (qqu(il, j2) .LT. qqu(il, j2-1)) THEN
              max2 = qqu(il, j2-1)
            ELSE
              max2 = qqu(il, j2)
            END IF
          ELSE IF (qqu(il+i2d2, j2-1) .LT. qqu(il, j2-1)) THEN
            max2 = qqu(il, j2-1)
          ELSE
            max2 = qqu(il+i2d2, j2-1)
          END IF
          pmax = max2 - qqu(il, j2)
          IF (qqu(il+i2d2, j2-1) .GT. qqu(il, j2)) THEN
            IF (qqu(il, j2) .GT. qqu(il, j2-1)) THEN
              min3 = qqu(il, j2-1)
            ELSE
              min3 = qqu(il, j2)
            END IF
          ELSE IF (qqu(il+i2d2, j2-1) .GT. qqu(il, j2-1)) THEN
            min3 = qqu(il, j2-1)
          ELSE
            min3 = qqu(il+i2d2, j2-1)
          END IF
          pmin = qqu(il, j2) - min3
          IF (tmp .GE. 0.) THEN
            x2 = tmp
          ELSE
            x2 = -tmp
          END IF
          IF (x2 .GT. pmax) THEN
            IF (pmax .GT. pmin) THEN
              min4 = pmin
            ELSE
              min4 = pmax
            END IF
          ELSE IF (x2 .GT. pmin) THEN
            min4 = pmin
          ELSE
            min4 = x2
          END IF
          dcy(il, j2) = SIGN(min4, tmp)
        END DO
!----------------------------------------------------------------
! Prior to 12/5/08:
! We need to add and outer IK loop for OpenMP parallelization.
! Preserve original code here (bmy, 12/5/08)
!do il = i1 + i2d2, i2
!   dcy(il,j2,:) = -dcy(il-i2d2,j2,:)
!end do
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!----------------------------------------------------------------
        DO il=i1+i2d2,i2
          dcy(il, j2) = -dcy(il-i2d2, j2)
        END DO
      END IF
    END IF
  END SUBROUTINE DO_YMIST_POLE2_I2D2

!  Differentiation of fyppm in forward (tangent) mode:
!   variations   of useful results: qqv
!   with respect to varying inputs: qqu qqv dcy
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Fyppm
!
! !DESCRIPTION: Subroutine Fyppm is the 1D "outer" flux form operator based
!  on the Piecewise Parabolic Method (PPM; see also Lin and Rood 1996) for
!  computing the fluxes in the N-S direction.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE FYPPM_D(jlmt, cry, dcy, dcyd, qqu, qqud, qqv, qqvd, j1p, &
&   j2p, i1_gl, i2_gl, ju1_gl, j2_gl, ilong, ilo, ihi, julo, jhi, i1, i2&
&   , ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! ILONG ??
    INTEGER, INTENT(IN) :: ilong
! Controls various options in N-S advection
    INTEGER, INTENT(IN) :: jlmt
! Courant number in N-S direction
    REAL*8, INTENT(IN) :: cry(ilo:ihi, julo:jhi)
! Slope of concentration distribution in N-S direction [mixing ratio]
    REAL*8, INTENT(IN) :: dcy(ilo:ihi, julo:jhi)
    REAL*8, INTENT(IN) :: dcyd(ilo:ihi, julo:jhi)
! Concentration contribution from E-W advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqu(ilo:ihi, julo:jhi)
    REAL*8, INTENT(IN) :: qqud(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Concentration contribution from N-S advection [mixing ratio]
    REAL*8, INTENT(OUT) :: qqv(ilo:ihi, julo:jhi)
    REAL*8, INTENT(OUT) :: qqvd(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: ijm1
    INTEGER :: il, ij
    INTEGER :: lenx
    REAL*8 :: r13, r23
! Arrays
    REAL*8 :: a61(ilong*(jhi-1-(julo+1)+1))
    REAL*8 :: a61d(ilong*(jhi-1-(julo+1)+1))
    REAL*8 :: al1(ilong*(jhi-1-(julo+1)+1))
    REAL*8 :: al1d(ilong*(jhi-1-(julo+1)+1))
    REAL*8 :: ar1(ilong*(jhi-1-(julo+1)+1))
    REAL*8 :: ar1d(ilong*(jhi-1-(julo+1)+1))
    REAL*8 :: dcy1(ilong*(jhi-1-(julo+1)+1))
    REAL*8 :: qqu1(ilong*(jhi-1-(julo+1)+1))
    REAL*8 :: qqu1d(ilong*(jhi-1-(julo+1)+1))
    REAL*8 :: a6(ilo:ihi, julo:jhi)
    REAL*8 :: a6d(ilo:ihi, julo:jhi)
    REAL*8 :: al(ilo:ihi, julo:jhi)
    REAL*8 :: ald(ilo:ihi, julo:jhi)
    REAL*8 :: ar(ilo:ihi, julo:jhi)
    REAL*8 :: ard(ilo:ihi, julo:jhi)
    REAL*8 :: temp
    REAL*8 :: temp0
! NOTE: The code was writtein with I1:I2 as the first dimension of AL,
! AR, A6, AL1, A61, AR1.  However, the limits should really should be
! ILO:IHI.  In practice, however, for a global grid (and OpenMP
! parallelization) ILO=I1 and IHI=I2.  Nevertheless, we will change the
! limits to ILO:IHI to be consistent and to avoid future problems.
! (bmy, 12/5/08)
!   ----------------
!   Begin execution.
!   ----------------
    a6(:, :) = 0.0d0
    al(:, :) = 0.0d0
    ar(:, :) = 0.0d0
    r13 = 1.0d0/3.0d0
    r23 = 2.0d0/3.0d0
    ald = 0.0_8
    ard = 0.0_8
!-----------------------------------------------------------------------
! Prior to 12/5/08:
! We need to add IK and IL loops for OpenMP parallelization.
! Preserve original code here (bmy, 12/5/08)
!do ij = julo + 1, jhi
!   al(i1:i2,ij,:) =  &
!        0.5d0 * (qqu(i1:i2,ij-1,:) + qqu(i1:i2,ij,:)) +  &
!        (dcy(i1:i2,ij-1,:) - dcy(i1:i2,ij,:)) * r13
!end do
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!-----------------------------------------------------------------------
    DO ij=julo+1,jhi
      DO il=ilo,ihi
        ald(il, ij) = 0.5d0*(qqud(il, ij-1)+qqud(il, ij)) + r13*(dcyd(il&
&         , ij-1)-dcyd(il, ij))
        al(il, ij) = 0.5d0*(qqu(il, ij-1)+qqu(il, ij)) + (dcy(il, ij-1)-&
&         dcy(il, ij))*r13
        ard(il, ij-1) = ald(il, ij)
        ar(il, ij-1) = al(il, ij)
      END DO
    END DO
!-------------------------------------------------------------------------
! Prior to 12/5/08:
! We need to add IK and IL loops for OpenMP parallelization.
! Preserve original code here (bmy, 12/5/08)
! NOTE: This DO loop doesn't parallelize, so leave it alone (bmy, 12/5/08)
!do ij = julo, jhi - 1
!   ar(i1:i2,ij,:) = al(i1:i2,ij+1,:)
!end do
!-------------------------------------------------------------------------
!   =======================
!   =======================
    CALL DO_FYPPM_POLE_I2D2_D(al, ald, ar, ard, i1_gl, i2_gl, ju1_gl, &
&                       j2_gl, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    a6d = 0.0_8
!-----------------------------------------------------------------------
! Prior to 12/5/08:
! We need to add IK and IL loops for OpenMP parallelization.
! Preserve original code here (bmy, 12/5/08)
!do ij = julo + 1, jhi - 1
!
!   a6(i1:i2,ij,:) =  &
!        3.0d0 *  &
!        (qqu(i1:i2,ij,:) + qqu(i1:i2,ij,:) -  &
!        (al(i1:i2,ij,:) + ar(i1:i2,ij,:)))
!
!end do
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!-----------------------------------------------------------------------
    DO ij=julo+1,jhi-1
      DO il=ilo,ihi
        a6d(il, ij) = 3.0d0*(2*qqud(il, ij)-ald(il, ij)-ard(il, ij))
        a6(il, ij) = 3.0d0*(qqu(il, ij)+qqu(il, ij)-(al(il, ij)+ar(il, &
&         ij)))
      END DO
    END DO
!   ==============
    IF (jlmt .LE. 2) THEN
!   ==============
      lenx = 0
      ar1d = 0.0_8
      al1d = 0.0_8
      a61d = 0.0_8
      qqu1d = 0.0_8
      DO ij=julo+1,jhi-1
!=== Prior to 12/5/08
!do il = i1, i2
        DO il=ilo,ihi
          lenx = lenx + 1
          a61d(lenx) = a6d(il, ij)
          a61(lenx) = a6(il, ij)
          al1d(lenx) = ald(il, ij)
          al1(lenx) = al(il, ij)
          ar1d(lenx) = ard(il, ij)
          ar1(lenx) = ar(il, ij)
          dcy1(lenx) = dcy(il, ij)
          qqu1d(lenx) = qqud(il, ij)
          qqu1(lenx) = qqu(il, ij)
        END DO
      END DO
!         ===========
      CALL LMTPPM_D(lenx, jlmt, a61, a61d, al1, al1d, ar1, ar1d, dcy1, &
&             qqu1, qqu1d)
!         ===========
      lenx = 0
      DO ij=julo+1,jhi-1
!=== Prior to 12/5/08
!do il = i1, i2
        DO il=ilo,ihi
          lenx = lenx + 1
          a6d(il, ij) = a61d(lenx)
          a6(il, ij) = a61(lenx)
          ald(il, ij) = al1d(lenx)
          al(il, ij) = al1(lenx)
          ard(il, ij) = ar1d(lenx)
          ar(il, ij) = ar1(lenx)
        END DO
      END DO
    END IF
    DO ij=j1p,j2p+1
      ijm1 = ij - 1
!=== Prior to 12/5/08
!do il = i1, i2
      DO il=ilo,ihi
        IF (cry(il, ij) .GT. 0.0d0) THEN
          temp = 0.5d0*cry(il, ij)
          temp0 = -(r23*cry(il, ij)) + 1.0d0
          qqvd(il, ij) = ard(il, ijm1) + temp*(ald(il, ijm1)-ard(il, &
&           ijm1)+temp0*a6d(il, ijm1))
          qqv(il, ij) = ar(il, ijm1) + temp*(al(il, ijm1)-ar(il, ijm1)+&
&           temp0*a6(il, ijm1))
        ELSE
          temp0 = 0.5d0*cry(il, ij)
          temp = r23*cry(il, ij) + 1.0d0
          qqvd(il, ij) = ald(il, ij) - temp0*(ard(il, ij)-ald(il, ij)+&
&           temp*a6d(il, ij))
          qqv(il, ij) = al(il, ij) - temp0*(ar(il, ij)-al(il, ij)+temp*&
&           a6(il, ij))
        END IF
      END DO
    END DO
  END SUBROUTINE FYPPM_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Fyppm
!
! !DESCRIPTION: Subroutine Fyppm is the 1D "outer" flux form operator based
!  on the Piecewise Parabolic Method (PPM; see also Lin and Rood 1996) for
!  computing the fluxes in the N-S direction.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE FYPPM(jlmt, cry, dcy, qqu, qqv, j1p, j2p, i1_gl, i2_gl, &
&   ju1_gl, j2_gl, ilong, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! ILONG ??
    INTEGER, INTENT(IN) :: ilong
! Controls various options in N-S advection
    INTEGER, INTENT(IN) :: jlmt
! Courant number in N-S direction
    REAL*8, INTENT(IN) :: cry(ilo:ihi, julo:jhi)
! Slope of concentration distribution in N-S direction [mixing ratio]
    REAL*8, INTENT(IN) :: dcy(ilo:ihi, julo:jhi)
! Concentration contribution from E-W advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqu(ilo:ihi, julo:jhi)
!
! !OUTPUT PARAMETERS:
!
! Concentration contribution from N-S advection [mixing ratio]
    REAL*8, INTENT(OUT) :: qqv(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: ijm1
    INTEGER :: il, ij
    INTEGER :: lenx
    REAL*8 :: r13, r23
! Arrays
    REAL*8 :: a61(ilong*(jhi-1-(julo+1)+1))
    REAL*8 :: al1(ilong*(jhi-1-(julo+1)+1))
    REAL*8 :: ar1(ilong*(jhi-1-(julo+1)+1))
    REAL*8 :: dcy1(ilong*(jhi-1-(julo+1)+1))
    REAL*8 :: qqu1(ilong*(jhi-1-(julo+1)+1))
    REAL*8 :: a6(ilo:ihi, julo:jhi)
    REAL*8 :: al(ilo:ihi, julo:jhi)
    REAL*8 :: ar(ilo:ihi, julo:jhi)
! NOTE: The code was writtein with I1:I2 as the first dimension of AL,
! AR, A6, AL1, A61, AR1.  However, the limits should really should be
! ILO:IHI.  In practice, however, for a global grid (and OpenMP
! parallelization) ILO=I1 and IHI=I2.  Nevertheless, we will change the
! limits to ILO:IHI to be consistent and to avoid future problems.
! (bmy, 12/5/08)
!   ----------------
!   Begin execution.
!   ----------------
    a6(:, :) = 0.0d0
    al(:, :) = 0.0d0
    ar(:, :) = 0.0d0
    r13 = 1.0d0/3.0d0
    r23 = 2.0d0/3.0d0
!-----------------------------------------------------------------------
! Prior to 12/5/08:
! We need to add IK and IL loops for OpenMP parallelization.
! Preserve original code here (bmy, 12/5/08)
!do ij = julo + 1, jhi
!   al(i1:i2,ij,:) =  &
!        0.5d0 * (qqu(i1:i2,ij-1,:) + qqu(i1:i2,ij,:)) +  &
!        (dcy(i1:i2,ij-1,:) - dcy(i1:i2,ij,:)) * r13
!end do
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!-----------------------------------------------------------------------
    DO ij=julo+1,jhi
      DO il=ilo,ihi
        al(il, ij) = 0.5d0*(qqu(il, ij-1)+qqu(il, ij)) + (dcy(il, ij-1)-&
&         dcy(il, ij))*r13
        ar(il, ij-1) = al(il, ij)
      END DO
    END DO
!-------------------------------------------------------------------------
! Prior to 12/5/08:
! We need to add IK and IL loops for OpenMP parallelization.
! Preserve original code here (bmy, 12/5/08)
! NOTE: This DO loop doesn't parallelize, so leave it alone (bmy, 12/5/08)
!do ij = julo, jhi - 1
!   ar(i1:i2,ij,:) = al(i1:i2,ij+1,:)
!end do
!-------------------------------------------------------------------------
!   =======================
!   =======================
    CALL DO_FYPPM_POLE_I2D2(al, ar, i1_gl, i2_gl, ju1_gl, j2_gl, ilo, &
&                     ihi, julo, jhi, i1, i2, ju1, j2)
!-----------------------------------------------------------------------
! Prior to 12/5/08:
! We need to add IK and IL loops for OpenMP parallelization.
! Preserve original code here (bmy, 12/5/08)
!do ij = julo + 1, jhi - 1
!
!   a6(i1:i2,ij,:) =  &
!        3.0d0 *  &
!        (qqu(i1:i2,ij,:) + qqu(i1:i2,ij,:) -  &
!        (al(i1:i2,ij,:) + ar(i1:i2,ij,:)))
!
!end do
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!-----------------------------------------------------------------------
    DO ij=julo+1,jhi-1
      DO il=ilo,ihi
        a6(il, ij) = 3.0d0*(qqu(il, ij)+qqu(il, ij)-(al(il, ij)+ar(il, &
&         ij)))
      END DO
    END DO
!   ==============
    IF (jlmt .LE. 2) THEN
!   ==============
      lenx = 0
      DO ij=julo+1,jhi-1
!=== Prior to 12/5/08
!do il = i1, i2
        DO il=ilo,ihi
          lenx = lenx + 1
          a61(lenx) = a6(il, ij)
          al1(lenx) = al(il, ij)
          ar1(lenx) = ar(il, ij)
          dcy1(lenx) = dcy(il, ij)
          qqu1(lenx) = qqu(il, ij)
        END DO
      END DO
!         ===========
      CALL LMTPPM(lenx, jlmt, a61, al1, ar1, dcy1, qqu1)
!         ===========
      lenx = 0
      DO ij=julo+1,jhi-1
!=== Prior to 12/5/08
!do il = i1, i2
        DO il=ilo,ihi
          lenx = lenx + 1
          a6(il, ij) = a61(lenx)
          al(il, ij) = al1(lenx)
          ar(il, ij) = ar1(lenx)
        END DO
      END DO
    END IF
    DO ij=j1p,j2p+1
      ijm1 = ij - 1
!=== Prior to 12/5/08
!do il = i1, i2
      DO il=ilo,ihi
        IF (cry(il, ij) .GT. 0.0d0) THEN
          qqv(il, ij) = ar(il, ijm1) + 0.5d0*cry(il, ij)*(al(il, ijm1)-&
&           ar(il, ijm1)+a6(il, ijm1)*(1.0d0-r23*cry(il, ij)))
        ELSE
          qqv(il, ij) = al(il, ij) - 0.5d0*cry(il, ij)*(ar(il, ij)-al(il&
&           , ij)+a6(il, ij)*(1.0d0+r23*cry(il, ij)))
        END IF
      END DO
    END DO
  END SUBROUTINE FYPPM

!  Differentiation of do_fyppm_pole_i2d2 in forward (tangent) mode:
!   variations   of useful results: al ar
!   with respect to varying inputs: al ar
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Do_Fyppm_Pole_I2d2
!
! !DESCRIPTION: Subroutine Do\_Fyppm\_Pole\_I2d2  sets "al" \& "ar" at
!  the Poles.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE DO_FYPPM_POLE_I2D2_D(al, ald, ar, ard, i1_gl, i2_gl, ju1_gl&
&   , j2_gl, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
!
! !OUTPUT PARAMETERS:
!
! Left (al) and right (ar) edge values of the test parabola
    REAL*8, INTENT(INOUT) :: al(ilo:ihi, julo:jhi)
    REAL*8, INTENT(INOUT) :: ald(ilo:ihi, julo:jhi)
    REAL*8, INTENT(INOUT) :: ar(ilo:ihi, julo:jhi)
    REAL*8, INTENT(INOUT) :: ard(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: i2d2
    INTEGER :: il
!   ----------------
!   Begin execution.
!   ----------------
    i2d2 = i2_gl/2
!-----------------------------------------------------------
! Prior to 12/5/08:
! We need to add an IK loop for OpenMP parallelization.
! Preserve original code here. (bmy, 12/5/08)
!do il = i1, i2d2
!   al(il,     ju1,:) = al(il+i2d2,ju1+1,:)
!   al(il+i2d2,ju1,:) = al(il,     ju1+1,:)
!end do
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!-----------------------------------------------------------
    DO il=i1,i2d2
      ald(il, ju1) = ald(il+i2d2, ju1+1)
      al(il, ju1) = al(il+i2d2, ju1+1)
      ald(il+i2d2, ju1) = ald(il, ju1+1)
      al(il+i2d2, ju1) = al(il, ju1+1)
      ard(il, j2) = ard(il+i2d2, j2-1)
      ar(il, j2) = ar(il+i2d2, j2-1)
      ard(il+i2d2, j2) = ard(il, j2-1)
      ar(il+i2d2, j2) = ar(il, j2-1)
    END DO
  END SUBROUTINE DO_FYPPM_POLE_I2D2_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Do_Fyppm_Pole_I2d2
!
! !DESCRIPTION: Subroutine Do\_Fyppm\_Pole\_I2d2  sets "al" \& "ar" at
!  the Poles.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE DO_FYPPM_POLE_I2D2(al, ar, i1_gl, i2_gl, ju1_gl, j2_gl, ilo&
&   , ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
!
! !OUTPUT PARAMETERS:
!
! Left (al) and right (ar) edge values of the test parabola
    REAL*8, INTENT(INOUT) :: al(ilo:ihi, julo:jhi)
    REAL*8, INTENT(INOUT) :: ar(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: i2d2
    INTEGER :: il
!   ----------------
!   Begin execution.
!   ----------------
    i2d2 = i2_gl/2
!-----------------------------------------------------------
! Prior to 12/5/08:
! We need to add an IK loop for OpenMP parallelization.
! Preserve original code here. (bmy, 12/5/08)
!do il = i1, i2d2
!   al(il,     ju1,:) = al(il+i2d2,ju1+1,:)
!   al(il+i2d2,ju1,:) = al(il,     ju1+1,:)
!end do
! The IK loop was moved outside the subroutine (ccc, 4/1/09)
!-----------------------------------------------------------
    DO il=i1,i2d2
      al(il, ju1) = al(il+i2d2, ju1+1)
      al(il+i2d2, ju1) = al(il, ju1+1)
      ar(il, j2) = ar(il+i2d2, j2-1)
      ar(il+i2d2, j2) = ar(il, j2-1)
    END DO
  END SUBROUTINE DO_FYPPM_POLE_I2D2

!  Differentiation of do_ytp_pole_sum in forward (tangent) mode:
!   variations   of useful results: dq1
!   with respect to varying inputs: qqv dq1
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Do_Ytp_Pole_Sum
!
! !DESCRIPTION: Subroutine Do\_Ytp\_Pole\_Sum sets "dq1" at the Poles.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE DO_YTP_POLE_SUM_D(geofac_pc, dq1, dq1d, qqv, qqvd, fy, &
&   i1_gl, i2_gl, ju1_gl, j2_gl, j1p, j2p, ilo, ihi, julo, jhi, i1, i2, &
&   ju1, j2)
    IMPLICIT NONE
!
! !input PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Special geometrical factor (geofac) for Polar cap
    REAL*8, INTENT(IN) :: geofac_pc
! Concentration contribution from N-S advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqv(ilo:ihi, julo:jhi)
    REAL*8, INTENT(IN) :: qqvd(ilo:ihi, julo:jhi)
!
! !INPUT/OUTPUT PARAMETERS:
!
! Species density [hPa]
    REAL*8, INTENT(INOUT) :: dq1(ilo:ihi, julo:jhi)
    REAL*8, INTENT(INOUT) :: dq1d(ilo:ihi, julo:jhi)
! N-S mass flux [mixing ratio]
    REAL*8, INTENT(INOUT) :: fy(ilo:ihi, julo:jhi+1)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il, ik
    REAL*8 :: ri2
! Arrays
    REAL*8 :: dq_np
    REAL*8 :: dq_npd
    REAL*8 :: dq_sp
    REAL*8 :: dq_spd
! 2 elements array for each pole value.
    REAL*8 :: dqik(2)
    REAL*8 :: dqikd(2)
    REAL*8 :: sumnp
    REAL*8 :: sumnpd
    REAL*8 :: sumsp
    REAL*8 :: sumspd
!   ----------------
!   Begin execution.
!   ----------------
    ri2 = i2_gl
    dqik(:) = 0.0d0
!... Integrate N-S flux around polar cap lat circle for each level
    sumsp = 0.0d0
    sumnp = 0.0d0
    sumnpd = 0.0_8
    sumspd = 0.0_8
    DO il=i1,i2
      sumspd = sumspd + qqvd(il, j1p)
      sumsp = sumsp + qqv(il, j1p)
      sumnpd = sumnpd + qqvd(il, j2p+1)
      sumnp = sumnp + qqv(il, j2p+1)
    END DO
!... wrap in E-W direction
    IF (i1 .EQ. i1_gl) THEN
      dqikd = 0.0_8
      dqikd(1) = dq1d(i1, ju1)
      dqik(1) = dq1(i1, ju1)
      dqikd(2) = dq1d(i1, j2)
      dqik(2) = dq1(i1, j2)
    ELSE
      dqikd = 0.0_8
    END IF
!... normalize and set inside polar cap
    dq_spd = dqikd(1) - geofac_pc*sumspd/ri2
    dq_sp = dqik(1) - sumsp/ri2*geofac_pc
    dq_npd = dqikd(2) + geofac_pc*sumnpd/ri2
    dq_np = dqik(2) + sumnp/ri2*geofac_pc
    DO il=i1,i2
      dq1d(il, ju1) = dq_spd
      dq1(il, ju1) = dq_sp
      dq1d(il, j2) = dq_npd
      dq1(il, j2) = dq_np
!... save polar flux
      fy(il, ju1) = -(sumsp/ri2*geofac_pc)
      fy(il, j2+1) = sumnp/ri2*geofac_pc
    END DO
    IF (j1p .NE. ju1_gl + 1) THEN
      DO il=i1,i2
        dq1d(il, ju1+1) = dq_spd
        dq1(il, ju1+1) = dq_sp
        dq1d(il, j2-1) = dq_npd
        dq1(il, j2-1) = dq_np
!... save polar flux
        fy(il, ju1+1) = -(sumsp/ri2*geofac_pc)
        fy(il, j2) = sumnp/ri2*geofac_pc
      END DO
    END IF
  END SUBROUTINE DO_YTP_POLE_SUM_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Do_Ytp_Pole_Sum
!
! !DESCRIPTION: Subroutine Do\_Ytp\_Pole\_Sum sets "dq1" at the Poles.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE DO_YTP_POLE_SUM(geofac_pc, dq1, qqv, fy, i1_gl, i2_gl, &
&   ju1_gl, j2_gl, j1p, j2p, ilo, ihi, julo, jhi, i1, i2, ju1, j2)
    IMPLICIT NONE
!
! !input PARAMETERS:
!
! Global latitude indices at the edges of the S/N polar caps
! J1P=JU1_GL+1; J2P=J2_GL-1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2; J2P=J2_GL-2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p, j2p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: i1_gl, i2_gl
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Special geometrical factor (geofac) for Polar cap
    REAL*8, INTENT(IN) :: geofac_pc
! Concentration contribution from N-S advection [mixing ratio]
    REAL*8, INTENT(IN) :: qqv(ilo:ihi, julo:jhi)
!
! !INPUT/OUTPUT PARAMETERS:
!
! Species density [hPa]
    REAL*8, INTENT(INOUT) :: dq1(ilo:ihi, julo:jhi)
! N-S mass flux [mixing ratio]
    REAL*8, INTENT(INOUT) :: fy(ilo:ihi, julo:jhi+1)
!
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.  Added
!                               OpenMP parallel DO loops.
!   01 Apr 2009 - C. Carouge  - Moved the IK loop outside the subroutine.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il, ik
    REAL*8 :: ri2
! Arrays
    REAL*8 :: dq_np
    REAL*8 :: dq_sp
! 2 elements array for each pole value.
    REAL*8 :: dqik(2)
    REAL*8 :: sumnp
    REAL*8 :: sumsp
!   ----------------
!   Begin execution.
!   ----------------
    ri2 = i2_gl
    dqik(:) = 0.0d0
!... Integrate N-S flux around polar cap lat circle for each level
    sumsp = 0.0d0
    sumnp = 0.0d0
    DO il=i1,i2
      sumsp = sumsp + qqv(il, j1p)
      sumnp = sumnp + qqv(il, j2p+1)
    END DO
!... wrap in E-W direction
    IF (i1 .EQ. i1_gl) THEN
      dqik(1) = dq1(i1, ju1)
      dqik(2) = dq1(i1, j2)
    END IF
!... normalize and set inside polar cap
    dq_sp = dqik(1) - sumsp/ri2*geofac_pc
    dq_np = dqik(2) + sumnp/ri2*geofac_pc
    DO il=i1,i2
      dq1(il, ju1) = dq_sp
      dq1(il, j2) = dq_np
!... save polar flux
      fy(il, ju1) = -(sumsp/ri2*geofac_pc)
      fy(il, j2+1) = sumnp/ri2*geofac_pc
    END DO
    IF (j1p .NE. ju1_gl + 1) THEN
      DO il=i1,i2
        dq1(il, ju1+1) = dq_sp
        dq1(il, j2-1) = dq_np
!... save polar flux
        fy(il, ju1+1) = -(sumsp/ri2*geofac_pc)
        fy(il, j2) = sumnp/ri2*geofac_pc
      END DO
    END IF
  END SUBROUTINE DO_YTP_POLE_SUM

!  Differentiation of fzppm in forward (tangent) mode:
!   variations   of useful results: dq1
!   with respect to varying inputs: qq1 dq1
!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Fzppm
!
! !DESCRIPTION: Subroutine Fzppm is the 1D "outer" flux form operator based
!  on the Piecewise Parabolic Method (PPM; see also Lin and Rood 1996) for
!  computing the fluxes in the vertical direction.
!\\
!\\
!  Fzppm was modified by S.-J. Lin, 12/14/98, to allow the use of the KORD=7
!  (klmt=4) option.  KORD=7 enforces the 2nd monotonicity constraint of
!  Huynh (1996).  Note that in Huynh's original scheme, two constraints are
!  necessary for the preservation of monotonicity.  To use Huynh's
!  algorithm, it was modified as follows.  The original PPM is still used to
!  obtain the first guesses for the cell edges, and as such Huynh's 1st
!  constraint is no longer needed.  Huynh's median function is also replaced
!  by a simpler yet functionally equivalent in-line algorithm.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE FZPPM_D(klmt, delp1, wz, dq1, dq1d, qq1, qq1d, fz, j1p, &
&   ju1_gl, j2_gl, ilo, ihi, julo, jhi, ilong, ivert, i1, i2, ju1, j2, &
&   k1, k2)
    IMPLICIT NONE
!   =============
!   =============
!
! !INPUT PARAMETERS:
!
! Global latitude index at the edges of the South polar cap
! J1P=JU1_GL+1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
    INTEGER, INTENT(IN) :: k1, k2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Dimensions in longitude & altitude ???
    INTEGER, INTENT(IN) :: ilong, ivert
! Controls various options in vertical advection
    INTEGER, INTENT(IN) :: klmt
! Pressure thickness, the pseudo-density in a
! hydrostatic system at t1 [hPa]
    REAL*8, INTENT(IN) :: delp1(ilo:ihi, julo:jhi, k1:k2)
! Large scale mass flux (per time step tdt) in the vertical
! direction as diagnosed from the hydrostatic relationship [hPa]
    REAL*8, INTENT(IN) :: wz(i1:i2, ju1:j2, k1:k2)
! Species concentration [mixing ratio]
    REAL*8, INTENT(IN) :: qq1(ilo:ihi, julo:jhi, k1:k2)
    REAL*8, INTENT(IN) :: qq1d(ilo:ihi, julo:jhi, k1:k2)
!
! !INPUT/OUTPUT PARAMETERS:
!
! Species density [hPa]
    REAL*8, INTENT(INOUT) :: dq1(ilo:ihi, julo:jhi, k1:k2)
    REAL*8, INTENT(INOUT) :: dq1d(ilo:ihi, julo:jhi, k1:k2)
!
! !OUTPUT PARAMETERS:
!
! Vertical flux [mixing ratio]
    REAL*8, INTENT(OUT) :: fz(ilo:ihi, julo:jhi, k1:k2)
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il, ij, ik
    INTEGER :: k1p1, k1p2
    INTEGER :: k2m1, k2m2
    INTEGER :: lenx
    REAL*8 :: a1, a2
    REAL*8 :: aa, bb
    REAL*8 :: aad, bbd
    REAL*8 :: c0, c1, c2
    REAL*8 :: c1d
    REAL*8 :: cm, cp
    REAL*8 :: fac1, fac2
    REAL*8 :: fac1d
    REAL*8 :: lac
    REAL*8 :: lacd
    REAL*8 :: qmax, qmin
    REAL*8 :: qmaxd, qmind
    REAL*8 :: qmp
    REAL*8 :: qmpd
    REAL*8 :: r13, r23
    REAL*8 :: tmp
    REAL*8 :: tmpd
! Arrays
    REAL*8 :: a61(ilong*(ivert-4))
    REAL*8 :: a61d(ilong*(ivert-4))
    REAL*8 :: al1(ilong*(ivert-4))
    REAL*8 :: al1d(ilong*(ivert-4))
    REAL*8 :: ar1(ilong*(ivert-4))
    REAL*8 :: ar1d(ilong*(ivert-4))
    REAL*8 :: dca1(ilong*(ivert-4))
    REAL*8 :: dca1d(ilong*(ivert-4))
    REAL*8 :: qq1a1(ilong*(ivert-4))
    REAL*8 :: qq1a1d(ilong*(ivert-4))
    REAL*8 :: a6(i1:i2, k1:k2)
    REAL*8 :: a6d(i1:i2, k1:k2)
    REAL*8 :: al(i1:i2, k1:k2)
    REAL*8 :: ald(i1:i2, k1:k2)
    REAL*8 :: ar(i1:i2, k1:k2)
    REAL*8 :: ard(i1:i2, k1:k2)
    REAL*8 :: dca(i1:i2, k1:k2)
    REAL*8 :: dcad(i1:i2, k1:k2)
    REAL*8 :: dlp1a(i1:i2, k1:k2)
    REAL*8 :: qq1a(i1:i2, k1:k2)
    REAL*8 :: qq1ad(i1:i2, k1:k2)
    REAL*8 :: wza(i1:i2, k1:k2)
    REAL*8 :: dc(i1:i2, ju1:j2, k1:k2)
    REAL*8 :: dcd(i1:i2, ju1:j2, k1:k2)
! Work array
    REAL*8 :: dpi(i1:i2, ju1:j2, k1:k2)
    REAL*8 :: dpid(i1:i2, ju1:j2, k1:k2)
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL*8 :: x1
    REAL*8 :: x1d
    REAL*8 :: x2
    REAL*8 :: x2d
    REAL*8 :: x3
    REAL*8 :: x3d
    REAL*8 :: max1
    REAL*8 :: max1d
    REAL*8 :: min1
    REAL*8 :: min1d
    REAL*8 :: min2
    REAL*8 :: min2d
    REAL*8 :: temp
    REAL*8 :: temp0
!     ----------------
!     Begin execution.
!     ----------------
    a6(:, :) = 0.0d0
    al(:, :) = 0.0d0
    ar(:, :) = 0.0d0
    dc(:, :, :) = 0.0d0
!.sds... diagnostic vertical flux for species - set top to 0.0
    fz(:, :, :) = 0.0
    k1p1 = k1 + 1
    k1p2 = k1 + 2
    k2m1 = k2 - 1
    k2m2 = k2 - 2
    r13 = 1.0d0/3.0d0
    r23 = 2.0d0/3.0d0
    dpid = 0.0_8
!   -------------------
!   Compute dc for PPM.
!   -------------------
    DO ik=k1,k2m1
      dpid(:, :, ik) = qq1d(i1:i2, ju1:j2, ik+1) - qq1d(i1:i2, ju1:j2, &
&       ik)
      dpi(:, :, ik) = qq1(i1:i2, ju1:j2, ik+1) - qq1(i1:i2, ju1:j2, ik)
    END DO
    dcd = 0.0_8
    DO ik=k1p1,k2m1
      DO ij=ju1,j2
        DO il=i1,i2
          c0 = delp1(il, ij, ik)/(delp1(il, ij, ik-1)+delp1(il, ij, ik)+&
&           delp1(il, ij, ik+1))
          c1 = (delp1(il, ij, ik-1)+0.5d0*delp1(il, ij, ik))/(delp1(il, &
&           ij, ik+1)+delp1(il, ij, ik))
          c2 = (delp1(il, ij, ik+1)+0.5d0*delp1(il, ij, ik))/(delp1(il, &
&           ij, ik-1)+delp1(il, ij, ik))
          tmpd = c0*(c1*dpid(il, ij, ik)+c2*dpid(il, ij, ik-1))
          tmp = c0*(c1*dpi(il, ij, ik)+c2*dpi(il, ij, ik-1))
          IF (qq1(il, ij, ik-1) .LT. qq1(il, ij, ik)) THEN
            IF (qq1(il, ij, ik) .LT. qq1(il, ij, ik+1)) THEN
              max1d = qq1d(il, ij, ik+1)
              max1 = qq1(il, ij, ik+1)
            ELSE
              max1d = qq1d(il, ij, ik)
              max1 = qq1(il, ij, ik)
            END IF
          ELSE IF (qq1(il, ij, ik-1) .LT. qq1(il, ij, ik+1)) THEN
            max1d = qq1d(il, ij, ik+1)
            max1 = qq1(il, ij, ik+1)
          ELSE
            max1d = qq1d(il, ij, ik-1)
            max1 = qq1(il, ij, ik-1)
          END IF
          qmaxd = max1d - qq1d(il, ij, ik)
          qmax = max1 - qq1(il, ij, ik)
          IF (qq1(il, ij, ik-1) .GT. qq1(il, ij, ik)) THEN
            IF (qq1(il, ij, ik) .GT. qq1(il, ij, ik+1)) THEN
              min1d = qq1d(il, ij, ik+1)
              min1 = qq1(il, ij, ik+1)
            ELSE
              min1d = qq1d(il, ij, ik)
              min1 = qq1(il, ij, ik)
            END IF
          ELSE IF (qq1(il, ij, ik-1) .GT. qq1(il, ij, ik+1)) THEN
            min1d = qq1d(il, ij, ik+1)
            min1 = qq1(il, ij, ik+1)
          ELSE
            min1d = qq1d(il, ij, ik-1)
            min1 = qq1(il, ij, ik-1)
          END IF
          qmind = qq1d(il, ij, ik) - min1d
          qmin = qq1(il, ij, ik) - min1
          IF (tmp .GE. 0.) THEN
            x1d = tmpd
            x1 = tmp
          ELSE
            x1d = -tmpd
            x1 = -tmp
          END IF
          IF (x1 .GT. qmax) THEN
            IF (qmax .GT. qmin) THEN
              min2d = qmind
              min2 = qmin
            ELSE
              min2d = qmaxd
              min2 = qmax
            END IF
          ELSE IF (x1 .GT. qmin) THEN
            min2d = qmind
            min2 = qmin
          ELSE
            min2d = x1d
            min2 = x1
          END IF
          dcd(il, ij, ik) = SIGN(1.d0, min2*tmp)*min2d
          dc(il, ij, ik) = SIGN(min2, tmp)
        END DO
      END DO
    END DO
    ar1d = 0.0_8
    qq1a1d = 0.0_8
    al1d = 0.0_8
    ald = 0.0_8
    ard = 0.0_8
    a61d = 0.0_8
    a6d = 0.0_8
    dcad = 0.0_8
    qq1ad = 0.0_8
    dca1d = 0.0_8
!c?
!   -------------------------------------
!   Loop over latitudes (to save memory).
!   -------------------------------------
!   =======================
ijloop:DO ij=ju1,j2
!   =======================
      IF (.NOT.((ij .EQ. ju1_gl + 1 .OR. ij .EQ. j2_gl - 1) .AND. j1p &
&         .NE. ju1_gl + 1)) THEN
!         ============
!         ============
!----------------------------------------------------------------
! Prior to 12/5/08:
! Replace these with explicit loops below to facilitate
! OpenMP parallelization.  Preserve original code here.
! (bmy, 12/5/08)
!
!dca(:,:) = dc(:,ij,:)  ! the monotone slope
!wza(:,:) = wz(:,ij,:)
!
!dlp1a(:,:) = delp1(i1:i2,ij,:)
!qq1a (:,:) = qq1  (i1:i2,ij,:)
!----------------------------------------------------------------
        DO ik=k1,k2
          DO il=i1,i2
! the monotone slope
            dcad(il, ik) = dcd(il, ij, ik)
            dca(il, ik) = dc(il, ij, ik)
            wza(il, ik) = wz(il, ij, ik)
            dlp1a(il, ik) = delp1(il, ij, ik)
            qq1ad(il, ik) = qq1d(il, ij, ik)
            qq1a(il, ik) = qq1(il, ij, ik)
          END DO
        END DO
!     ----------------------------------------------------------------
!     Compute first guesses at cell interfaces.  First guesses are
!     required to be continuous.  Three-cell parabolic subgrid
!     distribution at model top; two-cell parabolic with zero gradient
!     subgrid distribution at the surface.
!     ----------------------------------------------------------------
!     ---------------------------
!     First guess top edge value.
!     ---------------------------
        DO il=i1,i2
!         ------------------------------------------------------------
!         Three-cell PPM; compute a, b, & c of q = aP^2 + bP + c using
!         cell averages and dlp1a.
!         ------------------------------------------------------------
          temp = dlp1a(il, k1p1) + dlp1a(il, k1p2)
          temp0 = dlp1a(il, k1) + dlp1a(il, k1p1)
          fac1d = dpid(il, ij, k1p1) - temp*dpid(il, ij, k1)/temp0
          fac1 = dpi(il, ij, k1p1) - temp*(dpi(il, ij, k1)/temp0)
          fac2 = (dlp1a(il, k1p1)+dlp1a(il, k1p2))*(dlp1a(il, k1)+dlp1a(&
&           il, k1p1)+dlp1a(il, k1p2))
          aad = 3.0d0*fac1d/fac2
          aa = 3.0d0*fac1/fac2
          temp0 = dlp1a(il, k1) + dlp1a(il, k1p1)
          temp = 2.0d0*dlp1a(il, k1) + dlp1a(il, k1p1)
          bbd = 2.0d0*dpid(il, ij, k1)/temp0 - temp*r23*aad
          bb = 2.0d0*(dpi(il, ij, k1)/temp0) - temp*(r23*aa)
          ald(il, k1) = qq1ad(il, k1) - dlp1a(il, k1)*(dlp1a(il, k1)*r13&
&           *aad+0.5d0*bbd)
          al(il, k1) = qq1a(il, k1) - dlp1a(il, k1)*(r13*aa*dlp1a(il, k1&
&           )+0.5d0*bb)
          ald(il, k1p1) = dlp1a(il, k1)*(dlp1a(il, k1)*aad+bbd) + ald(il&
&           , k1)
          al(il, k1p1) = dlp1a(il, k1)*(aa*dlp1a(il, k1)+bb) + al(il, k1&
&           )
!         ---------------------
!         Check if change sign.
!         ---------------------
          IF (qq1a(il, k1)*al(il, k1) .LE. 0.0d0) THEN
            ald(il, k1) = 0.0_8
            al(il, k1) = 0.0d0
            dcad(il, k1) = 0.0_8
            dca(il, k1) = 0.0d0
          ELSE
            dcad(il, k1) = qq1ad(il, k1) - ald(il, k1)
            dca(il, k1) = qq1a(il, k1) - al(il, k1)
          END IF
        END DO
!      -------
!      Bottom.
!      -------
        DO il=i1,i2
!         ---------------------------------------------------
!         2-cell PPM with zero gradient right at the surface.
!         ---------------------------------------------------
          temp0 = dlp1a(il, k2)*dlp1a(il, k2)
          temp = (dlp1a(il, k2)+dlp1a(il, k2m1))*(2.0d0*dlp1a(il, k2)+&
&           dlp1a(il, k2m1))
          fac1d = temp0*dpid(il, ij, k2m1)/temp
          fac1 = temp0*(dpi(il, ij, k2m1)/temp)
          ard(il, k2) = qq1ad(il, k2) + fac1d
          ar(il, k2) = qq1a(il, k2) + fac1
          ald(il, k2) = qq1ad(il, k2) - 2*fac1d
          al(il, k2) = qq1a(il, k2) - (fac1+fac1)
          IF (qq1a(il, k2)*ar(il, k2) .LE. 0.0d0) THEN
            ard(il, k2) = 0.0_8
            ar(il, k2) = 0.0d0
          END IF
          dcad(il, k2) = ard(il, k2) - qq1ad(il, k2)
          dca(il, k2) = ar(il, k2) - qq1a(il, k2)
        END DO
!     ----------------------------------------
!     4th order interpolation in the interior.
!     ----------------------------------------
        DO ik=k1p2,k2m1
          DO il=i1,i2
            temp0 = dlp1a(il, ik-1) + dlp1a(il, ik)
            c1d = dlp1a(il, ik-1)*dpid(il, ij, ik-1)/temp0
            c1 = dlp1a(il, ik-1)*(dpi(il, ij, ik-1)/temp0)
            c2 = 2.0d0/(dlp1a(il, ik-2)+dlp1a(il, ik-1)+dlp1a(il, ik)+&
&             dlp1a(il, ik+1))
            a1 = (dlp1a(il, ik-2)+dlp1a(il, ik-1))/(2.0d0*dlp1a(il, ik-1&
&             )+dlp1a(il, ik))
            a2 = (dlp1a(il, ik)+dlp1a(il, ik+1))/(2.0d0*dlp1a(il, ik)+&
&             dlp1a(il, ik-1))
            ald(il, ik) = qq1ad(il, ik-1) + c1d + c2*(dlp1a(il, ik)*((a1&
&             -a2)*c1d+a2*dcad(il, ik-1))-dlp1a(il, ik-1)*a1*dcad(il, ik&
&             ))
            al(il, ik) = qq1a(il, ik-1) + c1 + c2*(dlp1a(il, ik)*(c1*(a1&
&             -a2)+a2*dca(il, ik-1))-dlp1a(il, ik-1)*a1*dca(il, ik))
          END DO
        END DO
!-----------------------------------------------------------------
! Prior to 12/5/08:
!  Replace these with explicit loops below to facilitate
! OpenMP parallelization.  Preserve original code here.
! (bmy, 12/5/08)
!
!do ik = k1, k2m1
!   ar(:,ik) = al(:,ik+1)
!end do
!-----------------------------------------------------------------
        DO ik=k1,k2m1
          DO il=i1,i2
            ard(il, ik) = ald(il, ik+1)
            ar(il, ik) = al(il, ik+1)
          END DO
        END DO
!      ---------------------------------------
!      Top & Bottom 2 layers always monotonic.
!      ---------------------------------------
        lenx = i2 - i1 + 1
        DO ik=k1,k1p1
          DO il=i1,i2
            a6d(il, ik) = 3.0d0*(2*qq1ad(il, ik)-ald(il, ik)-ard(il, ik)&
&             )
            a6(il, ik) = 3.0d0*(qq1a(il, ik)+qq1a(il, ik)-(al(il, ik)+ar&
&             (il, ik)))
          END DO
!         ===========
          CALL LMTPPM_D(lenx, 0, a6(i1, ik), a6d(i1, ik), al(i1, ik), &
&                 ald(i1, ik), ar(i1, ik), ard(i1, ik), dca(i1, ik), &
&                 qq1a(i1, ik), qq1ad(i1, ik))
        END DO
!         ===========
        DO ik=k2m1,k2
          DO il=i1,i2
            a6d(il, ik) = 3.0d0*(2*qq1ad(il, ik)-ald(il, ik)-ard(il, ik)&
&             )
            a6(il, ik) = 3.0d0*(qq1a(il, ik)+qq1a(il, ik)-(al(il, ik)+ar&
&             (il, ik)))
          END DO
!         ===========
          CALL LMTPPM_D(lenx, 0, a6(i1, ik), a6d(i1, ik), al(i1, ik), &
&                 ald(i1, ik), ar(i1, ik), ard(i1, ik), dca(i1, ik), &
&                 qq1a(i1, ik), qq1ad(i1, ik))
        END DO
!         ===========
!      ---------------------------
!      Interior depending on klmt.
!      ---------------------------
!      ==============
        IF (klmt .EQ. 4) THEN
!       ==============
!         -------------------------------
!         KORD=7, Huynh's 2nd constraint.
!         -------------------------------
!-----------------------------------------------------------------
! Prior to 12/5/08:
! Replace these with explicit loops below to facilitate
! OpenMP parallelization.  Preserve original code here.
! (bmy, 12/5/08)
!
!do ik = k1p1, k2m1
!   dca(:,ik) = dpi(:,ij,ik) - dpi(:,ij,ik-1)
!end do
!-----------------------------------------------------------------
          DO ik=k1p1,k2m1
            DO il=i1,i2
              dcad(il, ik) = dpid(il, ij, ik) - dpid(il, ij, ik-1)
              dca(il, ik) = dpi(il, ij, ik) - dpi(il, ij, ik-1)
            END DO
          END DO
          DO ik=k1p2,k2m2
            DO il=i1,i2
!             ------------
!             Right edges.
!             ------------
              qmpd = qq1ad(il, ik) + 2.0d0*dpid(il, ij, ik-1)
              qmp = qq1a(il, ik) + 2.0d0*dpi(il, ij, ik-1)
              lacd = qq1ad(il, ik) + 1.5d0*dcad(il, ik-1) + 0.5d0*dpid(&
&               il, ij, ik-1)
              lac = qq1a(il, ik) + 1.5d0*dca(il, ik-1) + 0.5d0*dpi(il, &
&               ij, ik-1)
              IF (qq1a(il, ik) .GT. qmp) THEN
                IF (qmp .GT. lac) THEN
                  qmind = lacd
                  qmin = lac
                ELSE
                  qmind = qmpd
                  qmin = qmp
                END IF
              ELSE IF (qq1a(il, ik) .GT. lac) THEN
                qmind = lacd
                qmin = lac
              ELSE
                qmind = qq1ad(il, ik)
                qmin = qq1a(il, ik)
              END IF
              IF (qq1a(il, ik) .LT. qmp) THEN
                IF (qmp .LT. lac) THEN
                  qmaxd = lacd
                  qmax = lac
                ELSE
                  qmaxd = qmpd
                  qmax = qmp
                END IF
              ELSE IF (qq1a(il, ik) .LT. lac) THEN
                qmaxd = lacd
                qmax = lac
              ELSE
                qmaxd = qq1ad(il, ik)
                qmax = qq1a(il, ik)
              END IF
              IF (ar(il, ik) .LT. qmin) THEN
                x2d = qmind
                x2 = qmin
              ELSE
                x2d = ard(il, ik)
                x2 = ar(il, ik)
              END IF
              IF (x2 .GT. qmax) THEN
                ard(il, ik) = qmaxd
                ar(il, ik) = qmax
              ELSE
                ard(il, ik) = x2d
                ar(il, ik) = x2
              END IF
!             -----------
!             Left edges.
!             -----------
              qmpd = qq1ad(il, ik) - 2.0d0*dpid(il, ij, ik)
              qmp = qq1a(il, ik) - 2.0d0*dpi(il, ij, ik)
              lacd = qq1ad(il, ik) + 1.5d0*dcad(il, ik+1) - 0.5d0*dpid(&
&               il, ij, ik)
              lac = qq1a(il, ik) + 1.5d0*dca(il, ik+1) - 0.5d0*dpi(il, &
&               ij, ik)
              IF (qq1a(il, ik) .GT. qmp) THEN
                IF (qmp .GT. lac) THEN
                  qmind = lacd
                  qmin = lac
                ELSE
                  qmind = qmpd
                  qmin = qmp
                END IF
              ELSE IF (qq1a(il, ik) .GT. lac) THEN
                qmind = lacd
                qmin = lac
              ELSE
                qmind = qq1ad(il, ik)
                qmin = qq1a(il, ik)
              END IF
              IF (qq1a(il, ik) .LT. qmp) THEN
                IF (qmp .LT. lac) THEN
                  qmaxd = lacd
                  qmax = lac
                ELSE
                  qmaxd = qmpd
                  qmax = qmp
                END IF
              ELSE IF (qq1a(il, ik) .LT. lac) THEN
                qmaxd = lacd
                qmax = lac
              ELSE
                qmaxd = qq1ad(il, ik)
                qmax = qq1a(il, ik)
              END IF
              IF (al(il, ik) .LT. qmin) THEN
                x3d = qmind
                x3 = qmin
              ELSE
                x3d = ald(il, ik)
                x3 = al(il, ik)
              END IF
              IF (x3 .GT. qmax) THEN
                ald(il, ik) = qmaxd
                al(il, ik) = qmax
              ELSE
                ald(il, ik) = x3d
                al(il, ik) = x3
              END IF
!             -------------
!             Recompute a6.
!             -------------
              a6d(il, ik) = 3.0d0*(2*qq1ad(il, ik)-ard(il, ik)-ald(il, &
&               ik))
              a6(il, ik) = 3.0d0*(qq1a(il, ik)+qq1a(il, ik)-(ar(il, ik)+&
&               al(il, ik)))
            END DO
          END DO
        ELSE IF (klmt .LE. 2) THEN
!      ===================
!      ===================
          lenx = 0
          DO ik=k1p2,k2m2
            DO il=i1,i2
              lenx = lenx + 1
              al1d(lenx) = ald(il, ik)
              al1(lenx) = al(il, ik)
              ar1d(lenx) = ard(il, ik)
              ar1(lenx) = ar(il, ik)
              dca1d(lenx) = dcad(il, ik)
              dca1(lenx) = dca(il, ik)
              qq1a1d(lenx) = qq1ad(il, ik)
              qq1a1(lenx) = qq1a(il, ik)
              a61d(lenx) = 3.0d0*(2*qq1a1d(lenx)-al1d(lenx)-ar1d(lenx))
              a61(lenx) = 3.0d0*(qq1a1(lenx)+qq1a1(lenx)-(al1(lenx)+ar1(&
&               lenx)))
            END DO
          END DO
!         ===========
          CALL LMTPPM_D(lenx, klmt, a61, a61d, al1, al1d, ar1, ar1d, &
&                 dca1, qq1a1, qq1a1d)
!         ===========
          lenx = 0
          DO ik=k1p2,k2m2
            DO il=i1,i2
              lenx = lenx + 1
              a6d(il, ik) = a61d(lenx)
              a6(il, ik) = a61(lenx)
              ald(il, ik) = al1d(lenx)
              al(il, ik) = al1(lenx)
              ard(il, ik) = ar1d(lenx)
              ar(il, ik) = ar1(lenx)
              dcad(il, ik) = dca1d(lenx)
              dca(il, ik) = dca1(lenx)
              qq1ad(il, ik) = qq1a1d(lenx)
              qq1a(il, ik) = qq1a1(lenx)
            END DO
          END DO
        END IF
        DO ik=k1,k2m1
          DO il=i1,i2
            IF (wza(il, ik) .GT. 0.0d0) THEN
              cm = wza(il, ik)/dlp1a(il, ik)
              dcad(il, ik+1) = ard(il, ik) + cm*0.5d0*(ald(il, ik)-ard(&
&               il, ik)+(1.0d0-r23*cm)*a6d(il, ik))
              dca(il, ik+1) = ar(il, ik) + 0.5d0*cm*(al(il, ik)-ar(il, &
&               ik)+a6(il, ik)*(1.0d0-r23*cm))
            ELSE
              cp = wza(il, ik)/dlp1a(il, ik+1)
              dcad(il, ik+1) = ald(il, ik+1) + cp*0.5d0*(ald(il, ik+1)-&
&               ard(il, ik+1)-(r23*cp+1.0d0)*a6d(il, ik+1))
              dca(il, ik+1) = al(il, ik+1) + 0.5d0*cp*(al(il, ik+1)-ar(&
&               il, ik+1)-a6(il, ik+1)*(1.0d0+r23*cp))
            END IF
          END DO
        END DO
!-----------------------------------------------------------------
! Prior to 12/5/08:
! Replace these with explicit loops below to facilitate
! OpenMP parallelization.  Preserve original code here.
! (bmy, 12/5/08)
!
!do ik = k1, k2m1
!   dca(:,ik+1) = wza(:,ik) * dca(:,ik+1)
!   !.sds.. save vertical flux for species as diagnostic
!   fz(i1:i2,ij,ik+1) = dca(:,ik+1)
!end do
!
!dq1(i1:i2,ij,k1) = dq1(i1:i2,ij,k1) - dca(:,k1p1)
!dq1(i1:i2,ij,k2) = dq1(i1:i2,ij,k2) + dca(:,k2)
!
!do ik = k1p1, k2m1
!
!   dq1(i1:i2,ij,ik) =  &
!        dq1(i1:i2,ij,ik) + dca(:,ik) - dca(:,ik+1)
!
!end do
!-----------------------------------------------------------------
        DO ik=k1,k2m1
          DO il=i1,i2
            dcad(il, ik+1) = wza(il, ik)*dcad(il, ik+1)
            dca(il, ik+1) = wza(il, ik)*dca(il, ik+1)
!.sds.. save vertical flux for species as diagnostic
            fz(il, ij, ik+1) = dca(il, ik+1)
          END DO
        END DO
        DO il=i1,i2
          dq1d(il, ij, k1) = dq1d(il, ij, k1) - dcad(il, k1p1)
          dq1(il, ij, k1) = dq1(il, ij, k1) - dca(il, k1p1)
          dq1d(il, ij, k2) = dq1d(il, ij, k2) + dcad(il, k2)
          dq1(il, ij, k2) = dq1(il, ij, k2) + dca(il, k2)
        END DO
        DO ik=k1p1,k2m1
          DO il=i1,i2
            dq1d(il, ij, ik) = dq1d(il, ij, ik) + dcad(il, ik) - dcad(il&
&             , ik+1)
            dq1(il, ij, ik) = dq1(il, ij, ik) + dca(il, ik) - dca(il, ik&
&             +1)
          END DO
        END DO
      END IF
    END DO ijloop
  END SUBROUTINE FZPPM_D

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Fzppm
!
! !DESCRIPTION: Subroutine Fzppm is the 1D "outer" flux form operator based
!  on the Piecewise Parabolic Method (PPM; see also Lin and Rood 1996) for
!  computing the fluxes in the vertical direction.
!\\
!\\
!  Fzppm was modified by S.-J. Lin, 12/14/98, to allow the use of the KORD=7
!  (klmt=4) option.  KORD=7 enforces the 2nd monotonicity constraint of
!  Huynh (1996).  Note that in Huynh's original scheme, two constraints are
!  necessary for the preservation of monotonicity.  To use Huynh's
!  algorithm, it was modified as follows.  The original PPM is still used to
!  obtain the first guesses for the cell edges, and as such Huynh's 1st
!  constraint is no longer needed.  Huynh's median function is also replaced
!  by a simpler yet functionally equivalent in-line algorithm.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE FZPPM(klmt, delp1, wz, dq1, qq1, fz, j1p, ju1_gl, j2_gl, &
&   ilo, ihi, julo, jhi, ilong, ivert, i1, i2, ju1, j2, k1, k2)
    IMPLICIT NONE
!   =============
!   =============
!
! !INPUT PARAMETERS:
!
! Global latitude index at the edges of the South polar cap
! J1P=JU1_GL+1 for a polar cap of 1 latitude band
! J1P=JU1_GL+2 for a polar cap of 2 latitude bands
    INTEGER, INTENT(IN) :: j1p
! Global min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ju1_gl, j2_gl
! Local min & max longitude (I), latitude (J), altitude (K) indices
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
    INTEGER, INTENT(IN) :: k1, k2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Dimensions in longitude & altitude ???
    INTEGER, INTENT(IN) :: ilong, ivert
! Controls various options in vertical advection
    INTEGER, INTENT(IN) :: klmt
! Pressure thickness, the pseudo-density in a
! hydrostatic system at t1 [hPa]
    REAL*8, INTENT(IN) :: delp1(ilo:ihi, julo:jhi, k1:k2)
! Large scale mass flux (per time step tdt) in the vertical
! direction as diagnosed from the hydrostatic relationship [hPa]
    REAL*8, INTENT(IN) :: wz(i1:i2, ju1:j2, k1:k2)
! Species concentration [mixing ratio]
    REAL*8, INTENT(IN) :: qq1(ilo:ihi, julo:jhi, k1:k2)
!
! !INPUT/OUTPUT PARAMETERS:
!
! Species density [hPa]
    REAL*8, INTENT(INOUT) :: dq1(ilo:ihi, julo:jhi, k1:k2)
!
! !OUTPUT PARAMETERS:
!
! Vertical flux [mixing ratio]
    REAL*8, INTENT(OUT) :: fz(ilo:ihi, julo:jhi, k1:k2)
! !AUTHOR:
!   Original code from Shian-Jiann Lin, DAO
!   John Tannahill, LLNL (jrt@llnl.gov)
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: il, ij, ik
    INTEGER :: k1p1, k1p2
    INTEGER :: k2m1, k2m2
    INTEGER :: lenx
    REAL*8 :: a1, a2
    REAL*8 :: aa, bb
    REAL*8 :: c0, c1, c2
    REAL*8 :: cm, cp
    REAL*8 :: fac1, fac2
    REAL*8 :: lac
    REAL*8 :: qmax, qmin
    REAL*8 :: qmp
    REAL*8 :: r13, r23
    REAL*8 :: tmp
! Arrays
    REAL*8 :: a61(ilong*(ivert-4))
    REAL*8 :: al1(ilong*(ivert-4))
    REAL*8 :: ar1(ilong*(ivert-4))
    REAL*8 :: dca1(ilong*(ivert-4))
    REAL*8 :: qq1a1(ilong*(ivert-4))
    REAL*8 :: a6(i1:i2, k1:k2)
    REAL*8 :: al(i1:i2, k1:k2)
    REAL*8 :: ar(i1:i2, k1:k2)
    REAL*8 :: dca(i1:i2, k1:k2)
    REAL*8 :: dlp1a(i1:i2, k1:k2)
    REAL*8 :: qq1a(i1:i2, k1:k2)
    REAL*8 :: wza(i1:i2, k1:k2)
    REAL*8 :: dc(i1:i2, ju1:j2, k1:k2)
! Work array
    REAL*8 :: dpi(i1:i2, ju1:j2, k1:k2)
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL*8 :: x1
    REAL*8 :: x2
    REAL*8 :: x3
    REAL*8 :: max1
    REAL*8 :: min1
    REAL*8 :: min2
!     ----------------
!     Begin execution.
!     ----------------
    a6(:, :) = 0.0d0
    al(:, :) = 0.0d0
    ar(:, :) = 0.0d0
    dc(:, :, :) = 0.0d0
!.sds... diagnostic vertical flux for species - set top to 0.0
    fz(:, :, :) = 0.0
    k1p1 = k1 + 1
    k1p2 = k1 + 2
    k2m1 = k2 - 1
    k2m2 = k2 - 2
    r13 = 1.0d0/3.0d0
    r23 = 2.0d0/3.0d0
!   -------------------
!   Compute dc for PPM.
!   -------------------
    DO ik=k1,k2m1
      dpi(:, :, ik) = qq1(i1:i2, ju1:j2, ik+1) - qq1(i1:i2, ju1:j2, ik)
    END DO
    DO ik=k1p1,k2m1
      DO ij=ju1,j2
        DO il=i1,i2
          c0 = delp1(il, ij, ik)/(delp1(il, ij, ik-1)+delp1(il, ij, ik)+&
&           delp1(il, ij, ik+1))
          c1 = (delp1(il, ij, ik-1)+0.5d0*delp1(il, ij, ik))/(delp1(il, &
&           ij, ik+1)+delp1(il, ij, ik))
          c2 = (delp1(il, ij, ik+1)+0.5d0*delp1(il, ij, ik))/(delp1(il, &
&           ij, ik-1)+delp1(il, ij, ik))
          tmp = c0*(c1*dpi(il, ij, ik)+c2*dpi(il, ij, ik-1))
          IF (qq1(il, ij, ik-1) .LT. qq1(il, ij, ik)) THEN
            IF (qq1(il, ij, ik) .LT. qq1(il, ij, ik+1)) THEN
              max1 = qq1(il, ij, ik+1)
            ELSE
              max1 = qq1(il, ij, ik)
            END IF
          ELSE IF (qq1(il, ij, ik-1) .LT. qq1(il, ij, ik+1)) THEN
            max1 = qq1(il, ij, ik+1)
          ELSE
            max1 = qq1(il, ij, ik-1)
          END IF
          qmax = max1 - qq1(il, ij, ik)
          IF (qq1(il, ij, ik-1) .GT. qq1(il, ij, ik)) THEN
            IF (qq1(il, ij, ik) .GT. qq1(il, ij, ik+1)) THEN
              min1 = qq1(il, ij, ik+1)
            ELSE
              min1 = qq1(il, ij, ik)
            END IF
          ELSE IF (qq1(il, ij, ik-1) .GT. qq1(il, ij, ik+1)) THEN
            min1 = qq1(il, ij, ik+1)
          ELSE
            min1 = qq1(il, ij, ik-1)
          END IF
          qmin = qq1(il, ij, ik) - min1
          IF (tmp .GE. 0.) THEN
            x1 = tmp
          ELSE
            x1 = -tmp
          END IF
          IF (x1 .GT. qmax) THEN
            IF (qmax .GT. qmin) THEN
              min2 = qmin
            ELSE
              min2 = qmax
            END IF
          ELSE IF (x1 .GT. qmin) THEN
            min2 = qmin
          ELSE
            min2 = x1
          END IF
          dc(il, ij, ik) = SIGN(min2, tmp)
        END DO
      END DO
    END DO
!c?
!   -------------------------------------
!   Loop over latitudes (to save memory).
!   -------------------------------------
!   =======================
ijloop:DO ij=ju1,j2
!   =======================
      IF (.NOT.((ij .EQ. ju1_gl + 1 .OR. ij .EQ. j2_gl - 1) .AND. j1p &
&         .NE. ju1_gl + 1)) THEN
!         ============
!         ============
!----------------------------------------------------------------
! Prior to 12/5/08:
! Replace these with explicit loops below to facilitate
! OpenMP parallelization.  Preserve original code here.
! (bmy, 12/5/08)
!
!dca(:,:) = dc(:,ij,:)  ! the monotone slope
!wza(:,:) = wz(:,ij,:)
!
!dlp1a(:,:) = delp1(i1:i2,ij,:)
!qq1a (:,:) = qq1  (i1:i2,ij,:)
!----------------------------------------------------------------
        DO ik=k1,k2
          DO il=i1,i2
! the monotone slope
            dca(il, ik) = dc(il, ij, ik)
            wza(il, ik) = wz(il, ij, ik)
            dlp1a(il, ik) = delp1(il, ij, ik)
            qq1a(il, ik) = qq1(il, ij, ik)
          END DO
        END DO
!     ----------------------------------------------------------------
!     Compute first guesses at cell interfaces.  First guesses are
!     required to be continuous.  Three-cell parabolic subgrid
!     distribution at model top; two-cell parabolic with zero gradient
!     subgrid distribution at the surface.
!     ----------------------------------------------------------------
!     ---------------------------
!     First guess top edge value.
!     ---------------------------
        DO il=i1,i2
!         ------------------------------------------------------------
!         Three-cell PPM; compute a, b, & c of q = aP^2 + bP + c using
!         cell averages and dlp1a.
!         ------------------------------------------------------------
          fac1 = dpi(il, ij, k1p1) - dpi(il, ij, k1)*(dlp1a(il, k1p1)+&
&           dlp1a(il, k1p2))/(dlp1a(il, k1)+dlp1a(il, k1p1))
          fac2 = (dlp1a(il, k1p1)+dlp1a(il, k1p2))*(dlp1a(il, k1)+dlp1a(&
&           il, k1p1)+dlp1a(il, k1p2))
          aa = 3.0d0*fac1/fac2
          bb = 2.0d0*dpi(il, ij, k1)/(dlp1a(il, k1)+dlp1a(il, k1p1)) - &
&           r23*aa*(2.0d0*dlp1a(il, k1)+dlp1a(il, k1p1))
          al(il, k1) = qq1a(il, k1) - dlp1a(il, k1)*(r13*aa*dlp1a(il, k1&
&           )+0.5d0*bb)
          al(il, k1p1) = dlp1a(il, k1)*(aa*dlp1a(il, k1)+bb) + al(il, k1&
&           )
!         ---------------------
!         Check if change sign.
!         ---------------------
          IF (qq1a(il, k1)*al(il, k1) .LE. 0.0d0) THEN
            al(il, k1) = 0.0d0
            dca(il, k1) = 0.0d0
          ELSE
            dca(il, k1) = qq1a(il, k1) - al(il, k1)
          END IF
        END DO
!      -------
!      Bottom.
!      -------
        DO il=i1,i2
!         ---------------------------------------------------
!         2-cell PPM with zero gradient right at the surface.
!         ---------------------------------------------------
          fac1 = dpi(il, ij, k2m1)*(dlp1a(il, k2)*dlp1a(il, k2))/((dlp1a&
&           (il, k2)+dlp1a(il, k2m1))*(2.0d0*dlp1a(il, k2)+dlp1a(il, &
&           k2m1)))
          ar(il, k2) = qq1a(il, k2) + fac1
          al(il, k2) = qq1a(il, k2) - (fac1+fac1)
          IF (qq1a(il, k2)*ar(il, k2) .LE. 0.0d0) ar(il, k2) = 0.0d0
          dca(il, k2) = ar(il, k2) - qq1a(il, k2)
        END DO
!     ----------------------------------------
!     4th order interpolation in the interior.
!     ----------------------------------------
        DO ik=k1p2,k2m1
          DO il=i1,i2
            c1 = dpi(il, ij, ik-1)*dlp1a(il, ik-1)/(dlp1a(il, ik-1)+&
&             dlp1a(il, ik))
            c2 = 2.0d0/(dlp1a(il, ik-2)+dlp1a(il, ik-1)+dlp1a(il, ik)+&
&             dlp1a(il, ik+1))
            a1 = (dlp1a(il, ik-2)+dlp1a(il, ik-1))/(2.0d0*dlp1a(il, ik-1&
&             )+dlp1a(il, ik))
            a2 = (dlp1a(il, ik)+dlp1a(il, ik+1))/(2.0d0*dlp1a(il, ik)+&
&             dlp1a(il, ik-1))
            al(il, ik) = qq1a(il, ik-1) + c1 + c2*(dlp1a(il, ik)*(c1*(a1&
&             -a2)+a2*dca(il, ik-1))-dlp1a(il, ik-1)*a1*dca(il, ik))
          END DO
        END DO
!-----------------------------------------------------------------
! Prior to 12/5/08:
!  Replace these with explicit loops below to facilitate
! OpenMP parallelization.  Preserve original code here.
! (bmy, 12/5/08)
!
!do ik = k1, k2m1
!   ar(:,ik) = al(:,ik+1)
!end do
!-----------------------------------------------------------------
        DO ik=k1,k2m1
          DO il=i1,i2
            ar(il, ik) = al(il, ik+1)
          END DO
        END DO
!      ---------------------------------------
!      Top & Bottom 2 layers always monotonic.
!      ---------------------------------------
        lenx = i2 - i1 + 1
        DO ik=k1,k1p1
          DO il=i1,i2
            a6(il, ik) = 3.0d0*(qq1a(il, ik)+qq1a(il, ik)-(al(il, ik)+ar&
&             (il, ik)))
          END DO
!         ===========
          CALL LMTPPM(lenx, 0, a6(i1, ik), al(i1, ik), ar(i1, ik), dca(&
&               i1, ik), qq1a(i1, ik))
        END DO
!         ===========
        DO ik=k2m1,k2
          DO il=i1,i2
            a6(il, ik) = 3.0d0*(qq1a(il, ik)+qq1a(il, ik)-(al(il, ik)+ar&
&             (il, ik)))
          END DO
!         ===========
          CALL LMTPPM(lenx, 0, a6(i1, ik), al(i1, ik), ar(i1, ik), dca(&
&               i1, ik), qq1a(i1, ik))
        END DO
!         ===========
!      ---------------------------
!      Interior depending on klmt.
!      ---------------------------
!      ==============
        IF (klmt .EQ. 4) THEN
!       ==============
!         -------------------------------
!         KORD=7, Huynh's 2nd constraint.
!         -------------------------------
!-----------------------------------------------------------------
! Prior to 12/5/08:
! Replace these with explicit loops below to facilitate
! OpenMP parallelization.  Preserve original code here.
! (bmy, 12/5/08)
!
!do ik = k1p1, k2m1
!   dca(:,ik) = dpi(:,ij,ik) - dpi(:,ij,ik-1)
!end do
!-----------------------------------------------------------------
          DO ik=k1p1,k2m1
            DO il=i1,i2
              dca(il, ik) = dpi(il, ij, ik) - dpi(il, ij, ik-1)
            END DO
          END DO
          DO ik=k1p2,k2m2
            DO il=i1,i2
!             ------------
!             Right edges.
!             ------------
              qmp = qq1a(il, ik) + 2.0d0*dpi(il, ij, ik-1)
              lac = qq1a(il, ik) + 1.5d0*dca(il, ik-1) + 0.5d0*dpi(il, &
&               ij, ik-1)
              IF (qq1a(il, ik) .GT. qmp) THEN
                IF (qmp .GT. lac) THEN
                  qmin = lac
                ELSE
                  qmin = qmp
                END IF
              ELSE IF (qq1a(il, ik) .GT. lac) THEN
                qmin = lac
              ELSE
                qmin = qq1a(il, ik)
              END IF
              IF (qq1a(il, ik) .LT. qmp) THEN
                IF (qmp .LT. lac) THEN
                  qmax = lac
                ELSE
                  qmax = qmp
                END IF
              ELSE IF (qq1a(il, ik) .LT. lac) THEN
                qmax = lac
              ELSE
                qmax = qq1a(il, ik)
              END IF
              IF (ar(il, ik) .LT. qmin) THEN
                x2 = qmin
              ELSE
                x2 = ar(il, ik)
              END IF
              IF (x2 .GT. qmax) THEN
                ar(il, ik) = qmax
              ELSE
                ar(il, ik) = x2
              END IF
!             -----------
!             Left edges.
!             -----------
              qmp = qq1a(il, ik) - 2.0d0*dpi(il, ij, ik)
              lac = qq1a(il, ik) + 1.5d0*dca(il, ik+1) - 0.5d0*dpi(il, &
&               ij, ik)
              IF (qq1a(il, ik) .GT. qmp) THEN
                IF (qmp .GT. lac) THEN
                  qmin = lac
                ELSE
                  qmin = qmp
                END IF
              ELSE IF (qq1a(il, ik) .GT. lac) THEN
                qmin = lac
              ELSE
                qmin = qq1a(il, ik)
              END IF
              IF (qq1a(il, ik) .LT. qmp) THEN
                IF (qmp .LT. lac) THEN
                  qmax = lac
                ELSE
                  qmax = qmp
                END IF
              ELSE IF (qq1a(il, ik) .LT. lac) THEN
                qmax = lac
              ELSE
                qmax = qq1a(il, ik)
              END IF
              IF (al(il, ik) .LT. qmin) THEN
                x3 = qmin
              ELSE
                x3 = al(il, ik)
              END IF
              IF (x3 .GT. qmax) THEN
                al(il, ik) = qmax
              ELSE
                al(il, ik) = x3
              END IF
!             -------------
!             Recompute a6.
!             -------------
              a6(il, ik) = 3.0d0*(qq1a(il, ik)+qq1a(il, ik)-(ar(il, ik)+&
&               al(il, ik)))
            END DO
          END DO
        ELSE IF (klmt .LE. 2) THEN
!      ===================
!      ===================
          lenx = 0
          DO ik=k1p2,k2m2
            DO il=i1,i2
              lenx = lenx + 1
              al1(lenx) = al(il, ik)
              ar1(lenx) = ar(il, ik)
              dca1(lenx) = dca(il, ik)
              qq1a1(lenx) = qq1a(il, ik)
              a61(lenx) = 3.0d0*(qq1a1(lenx)+qq1a1(lenx)-(al1(lenx)+ar1(&
&               lenx)))
            END DO
          END DO
!         ===========
          CALL LMTPPM(lenx, klmt, a61, al1, ar1, dca1, qq1a1)
!         ===========
          lenx = 0
          DO ik=k1p2,k2m2
            DO il=i1,i2
              lenx = lenx + 1
              a6(il, ik) = a61(lenx)
              al(il, ik) = al1(lenx)
              ar(il, ik) = ar1(lenx)
              dca(il, ik) = dca1(lenx)
              qq1a(il, ik) = qq1a1(lenx)
            END DO
          END DO
        END IF
        DO ik=k1,k2m1
          DO il=i1,i2
            IF (wza(il, ik) .GT. 0.0d0) THEN
              cm = wza(il, ik)/dlp1a(il, ik)
              dca(il, ik+1) = ar(il, ik) + 0.5d0*cm*(al(il, ik)-ar(il, &
&               ik)+a6(il, ik)*(1.0d0-r23*cm))
            ELSE
              cp = wza(il, ik)/dlp1a(il, ik+1)
              dca(il, ik+1) = al(il, ik+1) + 0.5d0*cp*(al(il, ik+1)-ar(&
&               il, ik+1)-a6(il, ik+1)*(1.0d0+r23*cp))
            END IF
          END DO
        END DO
!-----------------------------------------------------------------
! Prior to 12/5/08:
! Replace these with explicit loops below to facilitate
! OpenMP parallelization.  Preserve original code here.
! (bmy, 12/5/08)
!
!do ik = k1, k2m1
!   dca(:,ik+1) = wza(:,ik) * dca(:,ik+1)
!   !.sds.. save vertical flux for species as diagnostic
!   fz(i1:i2,ij,ik+1) = dca(:,ik+1)
!end do
!
!dq1(i1:i2,ij,k1) = dq1(i1:i2,ij,k1) - dca(:,k1p1)
!dq1(i1:i2,ij,k2) = dq1(i1:i2,ij,k2) + dca(:,k2)
!
!do ik = k1p1, k2m1
!
!   dq1(i1:i2,ij,ik) =  &
!        dq1(i1:i2,ij,ik) + dca(:,ik) - dca(:,ik+1)
!
!end do
!-----------------------------------------------------------------
        DO ik=k1,k2m1
          DO il=i1,i2
            dca(il, ik+1) = wza(il, ik)*dca(il, ik+1)
!.sds.. save vertical flux for species as diagnostic
            fz(il, ij, ik+1) = dca(il, ik+1)
          END DO
        END DO
        DO il=i1,i2
          dq1(il, ij, k1) = dq1(il, ij, k1) - dca(il, k1p1)
          dq1(il, ij, k2) = dq1(il, ij, k2) + dca(il, k2)
        END DO
        DO ik=k1p1,k2m1
          DO il=i1,i2
            dq1(il, ij, ik) = dq1(il, ij, ik) + dca(il, ik) - dca(il, ik&
&             +1)
          END DO
        END DO
      END IF
    END DO ijloop
  END SUBROUTINE FZPPM

!EOC
!------------------------------------------------------------------------------
!          Harvard University Atmospheric Chemistry Modeling Group            !
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Average_Press_Poles
!
! !DESCRIPTION: Subroutine Average\_Press\_Poles averages pressure at the
!  Poles when the Polar cap is enlarged.  It makes the last two latitudes
!  equal.
!\\
!\\
! !INTERFACE:
!
  SUBROUTINE AVERAGE_PRESS_POLES(area_1d, press, i1, i2, ju1, j2, ilo, &
&   ihi, julo, jhi)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
!
! Local min & max longitude (I), latitude (J)
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ju1, j2
! Local min & max longitude (I) and latitude (J) indices
    INTEGER, INTENT(IN) :: ilo, ihi
    INTEGER, INTENT(IN) :: julo, jhi
! Surface area of grid box
    REAL*8, INTENT(IN) :: area_1d(ju1:j2)
!
! !INPUT/OUTPUT PARAMETERS:
!
! Surface pressure [hPa]
    REAL*8, INTENT(INOUT) :: press(ilo:ihi, julo:jhi)
!
! !AUTHOR:
!   Philip Cameron-Smith and John Tannahill, GMI project @ LLNL (2003)
!   Implemented into GEOS-Chem by Claire Carouge (ccarouge@seas.harvard.edu)
!
! !REMARKS:
!  Subroutine from pjc_pfix.  Call this one once everything is working fine.
!
! !REVISION HISTORY:
!   05 Dec 2008 - C. Carouge  - Replaced TPCORE routines by S-J Lin and Kevin
!                               Yeh with the TPCORE routines from GMI model.
!                               This eliminates the polar overshoot in the
!                               stratosphere.
!   05 Dec 2008 - R. Yantosca - Updated documentation and added ProTeX headers.
!                               Declare all REAL variables as REAL*8.  Also
!                               make sure all numerical constants are declared
!                               with the "D" double-precision exponent.
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
!
! Scalars
    INTEGER :: i, j
    REAL*8 :: meanp
    REAL*8 :: rel_area(ju1:j2)
    REAL*8 :: sum_area
    INTRINSIC SUM
    INTRINSIC DBLE
!----------------
!Begin execution.
!----------------
! Compute the sum of surface area
    sum_area = SUM(area_1d)*DBLE(i2)
! Calculate rel_area for each lat. (ccc, 11/20/08)
    DO j=ju1,j2
      rel_area(j) = area_1d(j)/sum_area
    END DO
!--------------
! South Pole
!--------------
! Surface area of the S. Polar cap
    sum_area = SUM(rel_area(ju1:ju1+1))*DBLE(i2)
! Zero
    meanp = 0.d0
! Sum pressure * surface area over the S. Polar cap
    DO j=ju1,ju1+1
      DO i=i1,i2
        meanp = meanp + rel_area(j)*press(i, j)
      END DO
    END DO
! Normalize pressure in all grid boxes w/in the S. Polar cap
    press(:, ju1:ju1+1) = meanp/sum_area
!--------------
! North Pole
!--------------
! Surface area of the N. Polar cap
    sum_area = SUM(rel_area(j2-1:j2))*DBLE(i2)
! Zero
    meanp = 0.d0
! Sum pressure * surface area over the N. Polar cap
    DO j=j2-1,j2
      DO i=i1,i2
        meanp = meanp + rel_area(j)*press(i, j)
      END DO
    END DO
! Normalize pressure in all grid boxes w/in the N. Polar cap
    press(:, j2-1:j2) = meanp/sum_area
  END SUBROUTINE AVERAGE_PRESS_POLES

END MODULE TPCORE_FVDAS_ADJ_MOD_DIFF
!EOC

